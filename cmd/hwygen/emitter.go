package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"golang.org/x/tools/imports"
)

const HeaderNote = "// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.\n\n"

// formatAndFixImports formats Go source code and fixes imports using goimports.
// This replaces both gofmt formatting and manual import management by automatically
// adding missing imports and removing unused ones.
// Falls back to go/format if goimports processing fails.
func formatAndFixImports(filename string, src []byte) ([]byte, error) {
	formatted, err := imports.Process(filename, src, nil)
	if err != nil {
		// Fall back to basic formatting if goimports fails
		// (e.g., if module dependencies aren't available for import resolution)
		fmt.Fprintf(os.Stderr, "Warning: goimports processing failed for %s: %v, falling back to gofmt\n", filepath.Base(filename), err)
		formatted, fmtErr := format.Source(src)
		if fmtErr != nil {
			fmt.Fprintf(os.Stderr, "Warning: gofmt also failed: %v\n", fmtErr)
			return src, nil
		}
		return formatted, nil
	}
	return formatted, nil
}

// makeUnexported converts an exported Go identifier to an unexported one
// by lowercasing the first character. E.g., "Gelu" -> "gelu", "BaseGelu" -> "baseGelu".
func makeUnexported(name string) string {
	if len(name) == 0 {
		return name
	}
	return strings.ToLower(name[:1]) + name[1:]
}

// targetPriority returns a priority value for SIMD targets.
// Higher values are checked first in dispatch code.
// This ensures AVX512 is checked before AVX2 (since AVX512 CPUs also have AVX2),
// and SVE is checked before NEON (SVE is a superset with wider vectors).
func targetPriority(name string) int {
	switch name {
	case "AVX512":
		return 3
	case "AVX2":
		return 2
	case "SVE_DARWIN", "SVE_LINUX":
		return 2
	case "NEON":
		return 1
	default:
		return 0
	}
}

// ContribPackages tracks which contrib subpackages are needed for imports.
type ContribPackages struct {
	Math    bool // contrib/math (Exp, Log, Sin, etc.)
	Vec     bool // contrib/vec (Dot product, Norm, etc.)
	MatVec  bool // contrib/matvec (Matrix-vector ops)
	Matmul  bool // contrib/matmul (Matrix multiplication)
	Algo    bool // contrib/algo (Transform utilities)
	Image   bool // contrib/image (Image processing)
	Bitpack bool // contrib/bitpack (Bit packing)
	Sort    bool // contrib/sort (Sorting algorithms)
	HwyPkg  bool // hwy package functions (Pow2, etc.) used in SIMD targets
	StdMath bool // stdlib math package (math.Inf, math.NaN, etc.)
	HwyCore bool // hwy core ops (Load, Store, Add, etc.) that need vec package
	AsmPkg  bool // asm package needed (half-precision promoted types on AVX)
}

// detectContribPackages analyzes parsed functions to determine which contrib subpackages are used.
// Returns the combined packages across all targets (for backward compatibility).
func detectContribPackages(funcs []ParsedFunc, targets []Target) ContribPackages {
	pkgs := ContribPackages{}

	for _, pf := range funcs {
		for _, call := range pf.HwyCalls {
			// Check each target's OpMap for this function
			for _, target := range targets {
				if opInfo, ok := target.OpMap[call.FuncName]; ok {
					switch opInfo.SubPackage {
					case "math":
						pkgs.Math = true
					case "vec":
						pkgs.Vec = true
					case "matvec":
						pkgs.MatVec = true
					case "matmul":
						pkgs.Matmul = true
					case "algo":
						pkgs.Algo = true
					case "image":
						pkgs.Image = true
					case "bitpack":
						pkgs.Bitpack = true
					case "sort":
						pkgs.Sort = true
					}
					// HwyPkg is set per-target in detectContribPackagesForTarget
				}
			}
		}
	}

	return pkgs
}

// detectContribPackagesForTarget analyzes parsed functions to determine packages used for a specific target.
func detectContribPackagesForTarget(funcs []ParsedFunc, target Target) ContribPackages {
	pkgs := ContribPackages{}

	// Known stdlib math functions that might be called
	stdMathFuncs := map[string]bool{
		"Inf": true, "NaN": true, "IsInf": true, "IsNaN": true,
		"Floor": true, "Ceil": true, "Round": true, "Trunc": true,
		"Sqrt": true, "Cbrt": true, "Abs": true,
		"Sin": true, "Cos": true, "Tan": true,
		"Asin": true, "Acos": true, "Atan": true, "Atan2": true,
		"Sinh": true, "Cosh": true, "Tanh": true,
		"Asinh": true, "Acosh": true, "Atanh": true,
		"Exp": true, "Exp2": true, "Expm1": true,
		"Log": true, "Log2": true, "Log10": true, "Log1p": true,
		"Pow": true, "Hypot": true, "Erf": true, "Erfc": true,
		"Copysign": true, "Signbit": true, "Max": true, "Min": true,
	}

	for _, pf := range funcs {
		for _, call := range pf.HwyCalls {
			// Check for stdmath FIRST - it's always stdlib, never in OpMap
			if call.Package == "stdmath" {
				pkgs.StdMath = true
				continue
			}
			// Check for stdlib math package calls BEFORE OpMap lookup
			// This is needed because OpMap might have entries like "Sqrt" for hwy.Sqrt,
			// but we need to distinguish math.Sqrt (stdlib) from hwy.Sqrt
			if call.Package == "math" {
				if stdMathFuncs[call.FuncName] {
					// This is a stdlib math function call (math.Sqrt, math.Inf, etc.)
					pkgs.StdMath = true
					continue
				} else if strings.HasPrefix(call.FuncName, "Base") {
					// This is a contrib math function reference (like math.BaseExpVec)
					pkgs.Math = true
					continue
				}
			}
			if opInfo, ok := target.OpMap[call.FuncName]; ok {
				switch opInfo.SubPackage {
				case "math":
					pkgs.Math = true
				case "vec":
					pkgs.Vec = true
				case "matvec":
					pkgs.MatVec = true
				case "matmul":
					pkgs.Matmul = true
				case "algo":
					pkgs.Algo = true
				case "image":
					pkgs.Image = true
				case "bitpack":
					pkgs.Bitpack = true
				case "sort":
					pkgs.Sort = true
				}
				// Check if this is a hwy package function (like RoundToEven for AVX512) for this target
				if opInfo.Package == "hwy" && !opInfo.IsMethod && target.Name != "Fallback" {
					pkgs.HwyPkg = true
				}
				// Track if core hwy operations are used (Load, Store, Add, etc.)
				if call.Package == "hwy" {
					pkgs.HwyCore = true
				}
			} else if call.Package == "algo" && strings.HasPrefix(call.FuncName, "Base") {
				// This is a contrib algo function reference (like algo.BaseApply)
				pkgs.Algo = true
			} else if call.Package == "hwy" {
				// Other hwy package references (operations not in OpMap)
				pkgs.HwyCore = true
				// For non-Fallback targets, we need hwy import for unmapped operations
				if target.Name != "Fallback" {
					pkgs.HwyPkg = true
				}
			}
		}

		// Check if this function will generate Float16/BFloat16 specializations.
		// For SIMD targets: need hwy package for hwy.Vec[hwy.Float16] since archsimd doesn't have native half-precision support.
		// For Fallback targets: need hwy package for the hwy.Float16/hwy.BFloat16 types themselves.
		if len(pf.TypeParams) > 0 {
			for _, combo := range getTypeCombinations(&pf) {
				ct := comboPrimaryType(combo, pf.TypeParams)
				if ct == "hwy.Float16" || ct == "hwy.BFloat16" {
					if target.Name != "Fallback" {
						pkgs.HwyPkg = true
					} else {
						// Fallback needs hwy import for Float16/BFloat16 types
						pkgs.HwyCore = true
					}
					// AVX targets need asm package for promoted half-precision types
					if target.Name == "AVX2" || target.Name == "AVX512" {
						pkgs.AsmPkg = true
						// Pow on AVX promoted half-precision emits stdmath.Pow via IIFE
						for _, c := range pf.HwyCalls {
							if c.FuncName == "Pow" {
								pkgs.StdMath = true
								break
							}
						}
					}
					break
				}
			}
		}
	}

	return pkgs
}

// deriveDispatchPrefix extracts a unique prefix from function names for dispatch file naming.
// E.g., "BaseBlockedMatMul" → "blockedmatmul", "BaseMatMul" → "matmul"
func deriveDispatchPrefix(funcs []ParsedFunc) string {
	if len(funcs) == 0 {
		return ""
	}
	// Use the first function's name (without "Base" prefix)
	name := funcs[0].Name
	if strings.HasPrefix(name, "Base") {
		name = name[4:]
	}
	return strings.ToLower(name)
}

// comboAvailable checks if a dispatch combo has an implementation on a target.
// Returns true if targetComboMap is nil (no filtering) or the combo is in the map.
func comboAvailable(targetComboMap map[string]map[string]bool, targetName, dispatchName string) bool {
	if targetComboMap == nil {
		return true
	}
	available, ok := targetComboMap[targetName]
	if !ok {
		return true // target not in map → assume all available
	}
	return available[dispatchName]
}

// EmitDispatcher generates the runtime dispatch file(s).
// This generates architecture-specific dispatch files:
// - dispatch_{prefix}_amd64.gen.go for AVX2/AVX512
// - dispatch_{prefix}_arm64.gen.go for NEON
// - dispatch_{prefix}.gen.go for fallback-only (no build tags)
// If dispatchName is empty, derives prefix from function names.
// targetComboMap maps target name → set of dispatch variable names that have
// implementations on that target. If nil, all combos are assumed available.
func EmitDispatcher(funcs []ParsedFunc, targets []Target, pkgName, outPath, dispatchName string, _ []AsmAdapterInfo, targetComboMap map[string]map[string]bool) error {
	// Use provided dispatch name or derive from function names
	// Use provided dispatch name or derive from function names
	prefix := dispatchName
	useCustomPrefix := false
	if prefix == "" {
		prefix = deriveDispatchPrefix(funcs)
	} else {
		useCustomPrefix = true
	}

	// Group targets by architecture
	amd64Targets := []Target{}
	arm64Targets := []Target{}
	hasFallback := false

	for _, target := range targets {
		switch target.Arch() {
		case "amd64":
			amd64Targets = append(amd64Targets, target)
		case "arm64":
			arm64Targets = append(arm64Targets, target)
		default:
			if target.Name == "Fallback" {
				hasFallback = true
			}
		}
	}

	// Generate amd64 dispatch if we have amd64 targets
	if len(amd64Targets) > 0 {
		if err := emitArchDispatcher(funcs, amd64Targets, hasFallback, pkgName, outPath, "amd64", prefix, useCustomPrefix, targetComboMap); err != nil {
			return err
		}
	}

	// Generate arm64 dispatch if we have arm64 targets
	if len(arm64Targets) > 0 {
		if err := emitArchDispatcher(funcs, arm64Targets, hasFallback, pkgName, outPath, "arm64", prefix, useCustomPrefix, targetComboMap); err != nil {
			return err
		}
	}

	// Generate universal fallback dispatch if Fallback target is present
	// This covers architectures not handled above (e.g. 386, riscv64)
	// AND amd64/arm64 builds where SIMD is disabled or not supported by build tags
	if hasFallback {
		var constraints []string
		if len(arm64Targets) > 0 {
			constraints = append(constraints, "!arm64")
		}
		// Note: amd64 dispatch requires goexperiment.simd, so fallback handles !(amd64 && simd)
		if len(amd64Targets) > 0 {
			constraints = append(constraints, "!(amd64 && goexperiment.simd)")
		}

		buildTag := strings.Join(constraints, " && ")

		// Use "other" suffix if we have constraints, to avoid conflict with arch-specific files
		suffix := ""
		if buildTag != "" {
			suffix = "_other"
		}

		if err := emitFallbackOnlyDispatcher(funcs, pkgName, outPath, prefix, suffix, buildTag, useCustomPrefix, targetComboMap); err != nil {
			return err
		}
	}

	return nil
}

// hasVecInSignature checks if a function has hwy.Vec anywhere in its parameters or returns.
// This includes:
// - Direct Vec params: v hwy.Vec[T]
// - Function params containing Vec: fn func(hwy.Vec[T]) hwy.Vec[T]
// - Return types containing Vec
//
// Functions with Vec in their signature cannot have dispatch generated because:
//   - The concrete Vec type differs per architecture (archsimd.Float32x8 vs asm.Float32x4)
//   - Function type parameters containing Vec are especially problematic since you can't
//     assign func(archsimd.Float32x8) to func(hwy.Vec[float32])
func hasVecInSignature(pf ParsedFunc) bool {
	for _, param := range pf.Params {
		if strings.Contains(param.Type, "hwy.Vec[") || strings.Contains(param.Type, "Vec[") {
			return true
		}
	}
	for _, ret := range pf.Returns {
		if strings.Contains(ret.Type, "hwy.Vec[") || strings.Contains(ret.Type, "Vec[") {
			return true
		}
	}
	return false
}

// filterDispatchableFuncs returns only functions that should have dispatch generated.
// Functions with Vec anywhere in their signature are excluded because:
// - Vec→Vec functions have dispatch at the Transform layer
// - Function type parameters with Vec can't be unified across architectures
func filterDispatchableFuncs(funcs []ParsedFunc) []ParsedFunc {
	var result []ParsedFunc
	for _, pf := range funcs {
		if !hasVecInSignature(pf) {
			result = append(result, pf)
		}
	}
	return result
}

// emitArchDispatcher generates an architecture-specific dispatch file.
// targetComboMap restricts which combos are wired in per-target init functions.
func emitArchDispatcher(funcs []ParsedFunc, archTargets []Target, hasFallback bool, pkgName, outPath, arch, prefix string, useCustomPrefix bool, targetComboMap map[string]map[string]bool) error {
	// Filter out Vec→Vec functions - they don't need dispatch
	dispatchableFuncs := filterDispatchableFuncs(funcs)
	if len(dispatchableFuncs) == 0 {
		// No dispatchable functions, skip dispatch file generation
		return nil
	}

	var buf bytes.Buffer

	// Determine build tag based on architecture
	// amd64 requires goexperiment.simd for archsimd
	// arm64 uses our asm package which doesn't require the SIMD experiment
	var buildTag string
	if arch == "amd64" {
		buildTag = arch + " && goexperiment.simd"
	} else {
		buildTag = arch
	}

	// File header with build tag
	fmt.Fprintf(&buf, HeaderNote)
	fmt.Fprintf(&buf, "//go:build %s\n", buildTag)
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	// Imports - amd64 needs archsimd, arm64 doesn't
	// hwy always needed for NoSimdEnv() and generic dispatcher type constraint
	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"github.com/ajroetker/go-highway/hwy\"\n")
	if arch == "amd64" {
		fmt.Fprintf(&buf, "\t\"simd/archsimd\"\n")
	}
	fmt.Fprintf(&buf, ")\n\n")

	// Declare function variables
	for _, pf := range dispatchableFuncs {
		for _, dc := range getDispatchCombos(pf) {
			typeMap := dc.Combo.Types
			if len(typeMap) <= 1 {
				typeMap = nil
			}
			signature := buildFuncSignatureWithMap(pf, dc.ElemType, typeMap)
			fmt.Fprintf(&buf, "var %s func%s\n", dc.DispatchName, signature)
		}
	}
	fmt.Fprintf(&buf, "\n")

	// Generate generic dispatcher functions for generic source functions
	for _, pf := range dispatchableFuncs {
		if len(pf.TypeParams) > 0 {
			emitGenericDispatcher(&buf, pf)
		}
	}

	// Capitalize prefix for function names (e.g., "matmul" -> "Matmul")
	capPrefix := cases.Title(language.English).String(prefix)

	// Generate init() function
	initGenFn := "init" + capPrefix + "All"
	fmt.Fprintf(&buf, "func init() {\n\t%s()\n}\n\n", initGenFn)
	fmt.Fprintf(&buf, "func %s() {\n", initGenFn)
	fmt.Fprintf(&buf, "\tif hwy.NoSimdEnv() {\n")
	fmt.Fprintf(&buf, "\t\tinit%sFallback()\n", capPrefix)
	fmt.Fprintf(&buf, "\t\treturn\n")
	fmt.Fprintf(&buf, "\t}\n")

	// Add CPU detection for each target.
	// IMPORTANT: Sort targets so more capable SIMD is checked first.
	// AVX512 CPUs also have AVX2, so we must check AVX512 before AVX2.
	sortedTargets := make([]Target, len(archTargets))
	copy(sortedTargets, archTargets)
	sort.Slice(sortedTargets, func(i, j int) bool {
		return targetPriority(sortedTargets[i].Name) > targetPriority(sortedTargets[j].Name)
	})

	for _, target := range sortedTargets {
		switch target.Name {
		case "AVX512":
			fmt.Fprintf(&buf, "\tif archsimd.X86.AVX512() {\n")
			fmt.Fprintf(&buf, "\t\tinit%sAVX512()\n", capPrefix)
			fmt.Fprintf(&buf, "\t\treturn\n")
			fmt.Fprintf(&buf, "\t}\n")
		case "AVX2":
			fmt.Fprintf(&buf, "\tif archsimd.X86.AVX2() {\n")
			fmt.Fprintf(&buf, "\t\tinit%sAVX2()\n", capPrefix)
			fmt.Fprintf(&buf, "\t\treturn\n")
			fmt.Fprintf(&buf, "\t}\n")
		case "SVE_DARWIN", "SVE_LINUX":
			// SVE dispatch is handled entirely by z_c_*.gen.go init() functions
			// which override dispatch vars when SVE/SME is detected at runtime.
			// No GoSimd init function is generated for SVE targets.
			continue
		case "NEON":
			if target.Mode == TargetModeAsm {
				// NEON:asm — use fallback as the base layer.
				// The z_c_slices init() will override with C assembly implementations.
				fmt.Fprintf(&buf, "\tinit%sFallback()\n", capPrefix)
			} else {
				// NEON GoSimd — use Go SIMD NEON implementation
				fmt.Fprintf(&buf, "\tinit%sNEON()\n", capPrefix)
			}
			fmt.Fprintf(&buf, "\treturn\n")
		}
	}

	// Add fallback at end for x86 (in case no SIMD detected)
	// ARM64 always uses NEON (mandatory on ARMv8) so doesn't need fallback here
	if arch != "arm64" && hasFallback {
		fmt.Fprintf(&buf, "\tinit%sFallback()\n", capPrefix)
	}
	fmt.Fprintf(&buf, "}\n\n")

	// Generate init functions for each target
	// SVE targets are skipped — their dispatch is handled by z_c_*.gen.go init() functions.
	// ASM targets are also skipped — their dispatch is handled by z_c_slices init(),
	// with fallback as the base layer (set by the dispatcher init above).
	for _, target := range archTargets {
		if isSVETarget(target) || target.Mode == TargetModeAsm {
			continue
		}
		initFuncName := "init" + capPrefix + target.Name
		fmt.Fprintf(&buf, "func %s() {\n", initFuncName)

		for _, pf := range dispatchableFuncs {
			for _, dc := range getDispatchCombos(pf) {
				if !comboAvailable(targetComboMap, target.Name, dc.DispatchName) {
					continue
				}
				baseName := pf.Name
				if pf.Private {
					baseName = makeUnexported(baseName)
				}
				var implName string
				if hasInterfaceTypeParams(pf.TypeParams) {
					implName = baseName + "_fallback"
				} else {
					implName = baseName + target.Suffix()
				}
				suffix := dc.TypeSuffix
				if suffix != "" && suffix != "Float32" && len(pf.TypeParams) > 0 {
					implName = implName + "_" + suffix
				}
				fmt.Fprintf(&buf, "\t%s = %s\n", dc.DispatchName, implName)
			}
		}

		fmt.Fprintf(&buf, "}\n\n")
	}

	// Generate fallback init function if needed
	if hasFallback {
		fmt.Fprintf(&buf, "func init%sFallback() {\n", capPrefix)
		for _, pf := range dispatchableFuncs {
			for _, dc := range getDispatchCombos(pf) {
				if !comboAvailable(targetComboMap, "Fallback", dc.DispatchName) {
					continue
				}
				baseName := pf.Name
				if pf.Private {
					baseName = makeUnexported(baseName)
				}
				implName := baseName + "_fallback"
				suffix := dc.TypeSuffix
				if suffix != "" && suffix != "Float32" && len(pf.TypeParams) > 0 {
					implName = implName + "_" + suffix
				}
				fmt.Fprintf(&buf, "\t%s = %s\n", dc.DispatchName, implName)
			}
		}
		fmt.Fprintf(&buf, "}\n")
	}

	// Compute output filename
	filePrefix := "dispatch_"
	if useCustomPrefix {
		filePrefix = ""
	}
	filename := filepath.Join(outPath, fmt.Sprintf("%s%s_%s.gen.go", filePrefix, prefix, arch))

	// Format the code and fix imports
	formatted, err := formatAndFixImports(filename, buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: formatting failed: %v\n", err)
		formatted = buf.Bytes()
	}

	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write dispatcher: %w", err)
	}

	return nil
}

// emitFallbackOnlyDispatcher generates a dispatch file with no build tags for fallback-only builds.
func emitFallbackOnlyDispatcher(funcs []ParsedFunc, pkgName, outPath, prefix, suffix, buildTag string, useCustomPrefix bool, targetComboMap map[string]map[string]bool) error {
	// Filter out Vec→Vec functions - they don't need dispatch
	dispatchableFuncs := filterDispatchableFuncs(funcs)
	if len(dispatchableFuncs) == 0 {
		// No dispatchable functions, skip dispatch file generation
		return nil
	}

	var buf bytes.Buffer

	fmt.Fprintf(&buf, HeaderNote)
	if buildTag != "" {
		fmt.Fprintf(&buf, "//go:build %s\n", buildTag)
	}
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"github.com/ajroetker/go-highway/hwy\"\n")
	fmt.Fprintf(&buf, ")\n\n")

	// Declare function variables
	for _, pf := range dispatchableFuncs {
		for _, dc := range getDispatchCombos(pf) {
			typeMap := dc.Combo.Types
			if len(typeMap) <= 1 {
				typeMap = nil
			}
			signature := buildFuncSignatureWithMap(pf, dc.ElemType, typeMap)
			fmt.Fprintf(&buf, "var %s func%s\n", dc.DispatchName, signature)
		}
	}
	fmt.Fprintf(&buf, "\n")

	// Generate generic dispatcher functions for generic source functions
	for _, pf := range dispatchableFuncs {
		if len(pf.TypeParams) > 0 {
			emitGenericDispatcher(&buf, pf)
		}
	}

	// Capitalize prefix for function names
	capPrefix := cases.Title(language.English).String(prefix)

	// Simple init that just uses fallback
	initGenFn := "init" + capPrefix + "All"
	fmt.Fprintf(&buf, "func init() {\n\t%s()\n}\n\n", initGenFn)
	fmt.Fprintf(&buf, "func %s() {\n", initGenFn)
	fmt.Fprintf(&buf, "\t_ = hwy.NoSimdEnv // silence unused import\n")
	fmt.Fprintf(&buf, "\tinit%sFallback()\n", capPrefix)
	fmt.Fprintf(&buf, "}\n\n")

	fmt.Fprintf(&buf, "func init%sFallback() {\n", capPrefix)
	for _, pf := range dispatchableFuncs {
		for _, dc := range getDispatchCombos(pf) {
			if !comboAvailable(targetComboMap, "Fallback", dc.DispatchName) {
				continue
			}
			baseName := pf.Name
			if pf.Private {
				baseName = makeUnexported(baseName)
			}
			implName := baseName + "_fallback"
			suffix := dc.TypeSuffix
			if suffix != "" && suffix != "Float32" && len(pf.TypeParams) > 0 {
				implName = implName + "_" + suffix
			}
			fmt.Fprintf(&buf, "\t%s = %s\n", dc.DispatchName, implName)
		}
	}
	fmt.Fprintf(&buf, "}\n")

	// Compute output filename
	filePrefix := "dispatch_"
	if useCustomPrefix {
		filePrefix = ""
	}
	filename := filepath.Join(outPath, fmt.Sprintf("%s%s%s.gen.go", filePrefix, prefix, suffix))

	// Format the code and fix imports
	formatted, err := formatAndFixImports(filename, buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: formatting failed: %v\n", err)
		formatted = buf.Bytes()
	}

	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write dispatcher: %w", err)
	}

	return nil
}

// EmitTarget generates a target-specific implementation file.
// sourceImports contains the imports from the original source file that should be preserved
// if they're still used after transformation (e.g., "unsafe", "math/bits").
func EmitTarget(funcs []*ast.FuncDecl, target Target, pkgName, baseName, outPath string, contribPkgs ContribPackages, hoistedConsts []HoistedConst, sourceImports map[string]string) error {
	var buf bytes.Buffer

	// File header
	fmt.Fprintf(&buf, HeaderNote)
	if target.BuildTag != "" {
		fmt.Fprintf(&buf, "//go:build %s\n", target.BuildTag)
	}
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	// Build import list
	imports := []string{}

	if target.Name != "Fallback" {
		// Import the appropriate vector package only if core hwy ops are used
		if contribPkgs.HwyCore {
			switch target.VecPackage {
			case "archsimd":
				imports = append(imports, `"simd/archsimd"`)
			case "asm":
				imports = append(imports, `"github.com/ajroetker/go-highway/hwy/asm"`)
			}
		}
		// Import asm package for AVX targets that use half-precision promoted types
		if contribPkgs.AsmPkg && target.VecPackage == "archsimd" {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/asm"`)
		}
		// Add sync import for AVX-512 lazy initialization of hoisted constants
		if target.Name == "AVX512" && len(hoistedConsts) > 0 {
			imports = append(imports, `"sync"`)
		}
		// Add hwy package import if hwy functions are used (e.g., Pow2)
		if contribPkgs.HwyPkg {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy"`)
		}
		// Add contrib subpackage imports for SIMD targets
		if contribPkgs.Math {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/math"`)
		}
		if contribPkgs.Vec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/vec"`)
		}
		if contribPkgs.MatVec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matvec"`)
		}
		if contribPkgs.Matmul {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matmul"`)
		}
		if contribPkgs.Algo {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/algo"`)
		}
		if contribPkgs.Image {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/image"`)
		}
		if contribPkgs.Bitpack {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/bitpack"`)
		}
		if contribPkgs.Sort {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/sort"`)
		}
		// stdmath only if explicitly needed (math.Inf, math.NaN, etc. were found)
		if contribPkgs.StdMath {
			imports = append(imports, `stdmath "math"`)
		}
	} else {
		// Fallback uses the hwy package directly for core ops only if core ops are used
		if contribPkgs.HwyCore {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy"`)
		}
		// Fallback also uses contrib subpackages for their portable generic implementations
		if contribPkgs.Math {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/math"`)
		}
		if contribPkgs.Vec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/vec"`)
		}
		if contribPkgs.MatVec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matvec"`)
		}
		if contribPkgs.Matmul {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matmul"`)
		}
		if contribPkgs.Algo {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/algo"`)
		}
		if contribPkgs.Image {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/image"`)
		}
		if contribPkgs.Bitpack {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/bitpack"`)
		}
		if contribPkgs.Sort {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/sort"`)
		}
		// Include stdmath if the source file uses stdlib math functions
		if contribPkgs.StdMath {
			imports = append(imports, `stdmath "math"`)
		}
	}

	// Add source imports that are still used after transformation
	// Walk the AST to find which packages are actually referenced
	usedPkgs := collectUsedPackages(funcs)

	// Use blacklist approach: preserve all imports EXCEPT hwy-related ones that get transformed.
	// This allows users to use any stdlib or third-party package without needing to whitelist it.
	transformedImports := map[string]bool{
		"github.com/ajroetker/go-highway/hwy":              true,
		"github.com/ajroetker/go-highway/hwy/asm":          true,
		"github.com/ajroetker/go-highway/hwy/contrib/algo": true,
		"github.com/ajroetker/go-highway/hwy/contrib/math": true,
	}

	// Preserve imports that are used and not transformed by hwygen
	for localName, importPath := range sourceImports {
		if transformedImports[importPath] {
			continue // Skip hwy-related imports that get transformed
		}
		if usedPkgs[localName] {
			if localName == importPath || localName == "" || localName == filepath.Base(importPath) {
				imports = append(imports, fmt.Sprintf(`"%s"`, importPath))
			} else {
				imports = append(imports, fmt.Sprintf(`%s "%s"`, localName, importPath))
			}
		}
	}

	// Always add "unsafe" if it's used in the generated code (e.g. by Load),
	// even if it wasn't in the source file.
	if usedPkgs["unsafe"] {
		alreadyImported := false
		for _, imp := range imports {
			if strings.Contains(imp, `"unsafe"`) {
				alreadyImported = true
				break
			}
		}
		if !alreadyImported {
			imports = append(imports, `"unsafe"`)
		}
	}

	// Sort imports for consistency
	sort.Strings(imports)

	// Write imports
	fmt.Fprintf(&buf, "import (\n")
	for _, imp := range imports {
		fmt.Fprintf(&buf, "\t%s\n", imp)
	}
	fmt.Fprintf(&buf, ")\n\n")

	// Emit hoisted constants as package-level pre-broadcasted vectors
	if len(hoistedConsts) > 0 && target.Name != "Fallback" {
		emitHoistedConstants(&buf, hoistedConsts, target, baseName)
	}

	// Print each function
	fset := token.NewFileSet()
	for _, funcDecl := range funcs {
		// For AVX-512 with hoisted constants, inject lazy init call at function start
		if target.Name == "AVX512" && len(hoistedConsts) > 0 && funcDecl.Body != nil {
			injectHoistedConstInit(funcDecl, baseName)
		}
		if err := printer.Fprint(&buf, fset, funcDecl); err != nil {
			return fmt.Errorf("print function: %w", err)
		}
		fmt.Fprintf(&buf, "\n\n")
	}

	// Determine output filename
	filename := filepath.Join(outPath, baseName+target.Suffix()+".gen.go")

	// Format the code and fix imports
	formatted, err := formatAndFixImports(filename, buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: formatting failed for %s: %v\n", target.Name, err)
		formatted = buf.Bytes()
	}

	// Write to file
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write target file: %w", err)
	}

	return nil
}

// emitHoistedConstants writes package-level var declarations for hoisted vector constants.
// For AVX-512, uses lazy initialization with sync.Once to avoid executing AVX-512 instructions
// at package init time (which would crash on machines without AVX-512 support).
// The baseName parameter is used to generate unique names for _hoistOnce and _initHoistedConstants
// to avoid conflicts when multiple source files have hoisted constants.
func emitHoistedConstants(buf *bytes.Buffer, consts []HoistedConst, target Target, baseName string) {
	if target.Name == "AVX512" {
		// Generate unique prefix from baseName (e.g., "varint_base" -> "_varintBase")
		prefix := "_" + toCamelCase(baseName)
		onceName := prefix + "HoistOnce"
		initName := prefix + "InitHoistedConstants"

		// AVX-512: Use lazy initialization to avoid init-time crashes on non-AVX512 machines
		fmt.Fprintf(buf, "// Hoisted constants - lazily initialized on first use to avoid init-time crashes\n")
		fmt.Fprintf(buf, "var (\n")
		for _, c := range consts {
			// Extract the vector type from the broadcast function (e.g., "archsimd.BroadcastFloat32x16" -> "archsimd.Float32x16")
			vecType := strings.Replace(c.Broadcast, "Broadcast", "", 1)
			fmt.Fprintf(buf, "\t%s %s\n", c.VarName, vecType)
		}
		fmt.Fprintf(buf, "\t%s sync.Once\n", onceName)
		fmt.Fprintf(buf, ")\n\n")

		// Generate the lazy init function
		fmt.Fprintf(buf, "func %s() {\n", initName)
		fmt.Fprintf(buf, "\t%s.Do(func() {\n", onceName)
		for _, c := range consts {
			fmt.Fprintf(buf, "\t\t%s = %s(%s)\n", c.VarName, c.Broadcast, c.Value)
		}
		fmt.Fprintf(buf, "\t})\n")
		fmt.Fprintf(buf, "}\n\n")
	} else {
		// Other targets: Initialize at package init time (safe for widely-supported instruction sets)
		fmt.Fprintf(buf, "// Hoisted constants - pre-broadcasted at package init time\n")
		fmt.Fprintf(buf, "var (\n")
		for _, c := range consts {
			// e.g., var BaseSigmoid_one_f32 = archsimd.BroadcastFloat32x8(1.0)
			fmt.Fprintf(buf, "\t%s = %s(%s)\n", c.VarName, c.Broadcast, c.Value)
		}
		fmt.Fprintf(buf, ")\n\n")
	}
}

// injectHoistedConstInit prepends a call to the init function at the start of a function.
// This is used for AVX-512 to ensure lazy initialization of hoisted constants.
// The baseName parameter determines the unique init function name.
func injectHoistedConstInit(funcDecl *ast.FuncDecl, baseName string) {
	if funcDecl.Body == nil {
		return
	}

	// Generate the same init function name used by emitHoistedConstants
	prefix := "_" + toCamelCase(baseName)
	initName := prefix + "InitHoistedConstants"

	// Create the call expression
	initCall := &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun:  &ast.Ident{Name: initName},
			Args: nil,
		},
	}

	// Prepend to function body
	funcDecl.Body.List = append([]ast.Stmt{initCall}, funcDecl.Body.List...)
}

// toCamelCase converts a snake_case string to camelCase.
// E.g., "varint_base" -> "varintBase", "maskedvbyte_base" -> "maskedvbyteBase"
func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

// emitGenericDispatcher generates a generic function that dispatches based on type.
// For a function like BaseMatMul[T hwy.Floats], this generates:
//
//	func MatMul[T hwy.Floats](a, b, c []T, m, n, k int) {
//	    switch any(a).(type) {
//	    case []float32:
//	        MatMulFloat32(any(a).([]float32), any(b).([]float32), any(c).([]float32), m, n, k)
//	    case []float64:
//	        MatMulFloat64(any(a).([]float64), any(b).([]float64), any(c).([]float64), m, n, k)
//	    }
//	}
func emitGenericDispatcher(buf *bytes.Buffer, pf ParsedFunc) {
	hasInterfaceParams := hasInterfaceTypeParams(pf.TypeParams)
	genericName := buildGenericFuncName(pf.Name, hasInterfaceParams, pf.Private)
	combos := getTypeCombinations(&pf)

	// Check if this is a multi-type function (//hwy:gen with 2+ type params per combo)
	isMultiType := len(pf.TypeCombinations) > 0 && len(pf.TypeParams) > 1

	// Copy doc comments from the base function, then add dispatch note
	if pf.Doc != nil {
		for _, comment := range pf.Doc.List {
			// Rewrite the first line to use the dispatch function name instead of the base name
			text := comment.Text
			if after, ok := strings.CutPrefix(text, "// "+pf.Name+" "); ok {
				text = "// " + genericName + " " + after
			}
			fmt.Fprintf(buf, "%s\n", text)
		}
		fmt.Fprintf(buf, "//\n")
		fmt.Fprintf(buf, "// This function dispatches to the appropriate SIMD implementation at runtime.\n")
	} else {
		fmt.Fprintf(buf, "// %s is the generic API that dispatches to the appropriate SIMD implementation.\n", genericName)
	}
	fmt.Fprintf(buf, "func %s[", genericName)

	// Build type parameter list - include all type parameters
	for i, tp := range pf.TypeParams {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "%s %s", tp.Name, tp.Constraint)
	}
	fmt.Fprintf(buf, "](")

	// Parameters
	for i, param := range pf.Params {
		if i > 0 {
			fmt.Fprintf(buf, ", ")
		}
		fmt.Fprintf(buf, "%s %s", param.Name, param.Type)
	}
	fmt.Fprintf(buf, ")")

	// Return type if any
	if len(pf.Returns) > 0 {
		if len(pf.Returns) == 1 && pf.Returns[0].Name == "" {
			fmt.Fprintf(buf, " %s", pf.Returns[0].Type)
		} else {
			fmt.Fprintf(buf, " (")
			for i, ret := range pf.Returns {
				if i > 0 {
					fmt.Fprintf(buf, ", ")
				}
				if ret.Name != "" {
					fmt.Fprintf(buf, "%s ", ret.Name)
				}
				fmt.Fprintf(buf, "%s", ret.Type)
			}
			fmt.Fprintf(buf, ")")
		}
	}

	fmt.Fprintf(buf, " {\n")

	if isMultiType {
		// Multi-type dispatch: nested type switches.
		// Group combos by first type param value for the outer switch.
		emitMultiTypeDispatch(buf, pf, combos)
	} else {
		// Single-type dispatch: simple type switch on first generic param
		emitSingleTypeDispatch(buf, pf, combos)
	}

	// Add default return if function has return values
	if len(pf.Returns) > 0 {
		fmt.Fprintf(buf, "\tpanic(\"unreachable\")\n")
	}

	fmt.Fprintf(buf, "}\n\n")
}

// emitSingleTypeDispatch generates a simple type switch for single-type-param functions.
func emitSingleTypeDispatch(buf *bytes.Buffer, pf ParsedFunc, combos []TypeCombination) {
	// Find the first parameter with a generic type to use for type switch
	var switchParam string
	var switchParamType string
	for _, param := range pf.Params {
		if containsTypeParam(param.Type, pf.TypeParams) {
			switchParam = param.Name
			switchParamType = param.Type
			break
		}
	}

	if switchParam == "" {
		switchParam = pf.Params[0].Name
		switchParamType = pf.Params[0].Type
	}

	fmt.Fprintf(buf, "\tswitch any(%s).(type) {\n", switchParam)

	for _, combo := range combos {
		elemType := comboPrimaryType(combo, pf.TypeParams)
		dispatchName := buildDispatchFuncNameCombo(pf.Name, combo, pf.TypeParams, pf.Private)
		caseType := specializeType(switchParamType, pf.TypeParams, elemType)

		fmt.Fprintf(buf, "\tcase %s:\n", caseType)
		emitDispatchCall(buf, pf, dispatchName, elemType, nil, "\t\t")
	}

	fmt.Fprintf(buf, "\t}\n")
}

// emitMultiTypeDispatch generates nested type switches for multi-type-param functions.
// The outer switch is on the first type param, the inner switch on the second.
func emitMultiTypeDispatch(buf *bytes.Buffer, pf ParsedFunc, combos []TypeCombination) {
	if len(pf.TypeParams) < 2 {
		emitSingleTypeDispatch(buf, pf, combos)
		return
	}

	firstTP := pf.TypeParams[0]
	secondTP := pf.TypeParams[1]

	// Find switch params for outer and inner switch
	var outerSwitchParam, innerSwitchParam string
	for _, param := range pf.Params {
		if outerSwitchParam == "" && containsSpecificTypeParam(param.Type, firstTP.Name) {
			outerSwitchParam = param.Name
		}
		if innerSwitchParam == "" && containsSpecificTypeParam(param.Type, secondTP.Name) {
			innerSwitchParam = param.Name
		}
	}
	if outerSwitchParam == "" {
		outerSwitchParam = pf.Params[0].Name
	}
	if innerSwitchParam == "" {
		// Use a different param or fall back
		for _, param := range pf.Params {
			if param.Name != outerSwitchParam {
				innerSwitchParam = param.Name
				break
			}
		}
		if innerSwitchParam == "" {
			innerSwitchParam = outerSwitchParam
		}
	}

	// Group combos by first type param value
	type comboGroup struct {
		outerType string
		combos    []TypeCombination
	}
	var groups []comboGroup
	groupIdx := make(map[string]int)
	for _, combo := range combos {
		outerType := combo.Types[firstTP.Name]
		if idx, ok := groupIdx[outerType]; ok {
			groups[idx].combos = append(groups[idx].combos, combo)
		} else {
			groupIdx[outerType] = len(groups)
			groups = append(groups, comboGroup{outerType: outerType, combos: []TypeCombination{combo}})
		}
	}

	fmt.Fprintf(buf, "\tswitch any(%s).(type) {\n", outerSwitchParam)

	for _, group := range groups {
		outerCaseType := specializeType("[]"+firstTP.Name, pf.TypeParams, group.outerType)
		// Extract just the case type (e.g., "[]hwy.Float16")
		fmt.Fprintf(buf, "\tcase %s:\n", outerCaseType)

		if len(group.combos) == 1 {
			// Only one combo for this outer type — no inner switch needed
			combo := group.combos[0]
			dispatchName := buildDispatchFuncNameCombo(pf.Name, combo, pf.TypeParams, pf.Private)
			elemType := comboPrimaryType(combo, pf.TypeParams)
			emitDispatchCall(buf, pf, dispatchName, elemType, combo.Types, "\t\t")
		} else {
			// Multiple inner types — nest a switch
			fmt.Fprintf(buf, "\t\tswitch any(%s).(type) {\n", innerSwitchParam)
			for _, combo := range group.combos {
				innerType := combo.Types[secondTP.Name]
				innerCaseType := specializeType("[]"+secondTP.Name, pf.TypeParams, innerType)
				fmt.Fprintf(buf, "\t\tcase %s:\n", innerCaseType)

				dispatchName := buildDispatchFuncNameCombo(pf.Name, combo, pf.TypeParams, pf.Private)
				elemType := comboPrimaryType(combo, pf.TypeParams)
				emitDispatchCall(buf, pf, dispatchName, elemType, combo.Types, "\t\t\t")
			}
			fmt.Fprintf(buf, "\t\t}\n")
		}
	}

	fmt.Fprintf(buf, "\t}\n")
}

// emitDispatchCall emits the function call + return for one dispatch case.
func emitDispatchCall(buf *bytes.Buffer, pf ParsedFunc, dispatchName, elemType string, typeMap map[string]string, indent string) {
	needsReturnWrap := false
	for _, ret := range pf.Returns {
		if containsTypeParam(ret.Type, pf.TypeParams) {
			needsReturnWrap = true
			break
		}
	}

	if needsReturnWrap && len(pf.Returns) > 1 {
		fmt.Fprintf(buf, "%s", indent)
		for i := range pf.Returns {
			if i > 0 {
				fmt.Fprintf(buf, ", ")
			}
			fmt.Fprintf(buf, "_r%d", i)
		}
		fmt.Fprintf(buf, " := %s(", dispatchName)

		for i, param := range pf.Params {
			if i > 0 {
				fmt.Fprintf(buf, ", ")
			}
			emitDispatchArg(buf, param, pf.TypeParams, elemType, typeMap)
		}
		fmt.Fprintf(buf, ")\n")

		fmt.Fprintf(buf, "%sreturn ", indent)
		for i, ret := range pf.Returns {
			if i > 0 {
				fmt.Fprintf(buf, ", ")
			}
			if containsTypeParam(ret.Type, pf.TypeParams) {
				fmt.Fprintf(buf, "any(_r%d).(%s)", i, ret.Type)
			} else {
				fmt.Fprintf(buf, "_r%d", i)
			}
		}
		fmt.Fprintf(buf, "\n")
	} else {
		if len(pf.Returns) > 0 {
			if needsReturnWrap {
				fmt.Fprintf(buf, "%sreturn any(", indent)
			} else {
				fmt.Fprintf(buf, "%sreturn ", indent)
			}
		} else {
			fmt.Fprintf(buf, "%s", indent)
		}
		fmt.Fprintf(buf, "%s(", dispatchName)

		for i, param := range pf.Params {
			if i > 0 {
				fmt.Fprintf(buf, ", ")
			}
			emitDispatchArg(buf, param, pf.TypeParams, elemType, typeMap)
		}
		fmt.Fprintf(buf, ")")
		if needsReturnWrap {
			fmt.Fprintf(buf, ").(%s)", pf.Returns[0].Type)
		}
		fmt.Fprintf(buf, "\n")
	}
}

// emitDispatchArg emits a single argument in a dispatch call, with type assertions as needed.
func emitDispatchArg(buf *bytes.Buffer, param Param, typeParams []TypeParam, elemType string, typeMap map[string]string) {
	if containsTypeParam(param.Type, typeParams) {
		concreteParamType := specializeTypeWithMap(param.Type, typeParams, elemType, typeMap)
		fmt.Fprintf(buf, "any(%s).(%s)", param.Name, concreteParamType)
	} else if isInterfaceTypeParam(param.Type, typeParams) {
		concreteType := specializeTypeWithMap(getConstraintForParam(param.Type, typeParams), typeParams, elemType, typeMap)
		fmt.Fprintf(buf, "any(%s).(%s)", param.Name, concreteType)
	} else {
		fmt.Fprintf(buf, "%s", param.Name)
	}
}

// containsSpecificTypeParam checks if a type string contains a specific type parameter name.
func containsSpecificTypeParam(typeStr, paramName string) bool {
	// Check for patterns like []T1, T1, [T1], func(T1)
	if typeStr == paramName {
		return true
	}
	if strings.Contains(typeStr, "[]"+paramName) {
		return true
	}
	if strings.Contains(typeStr, "["+paramName+"]") {
		return true
	}
	if strings.Contains(typeStr, "("+paramName) || strings.Contains(typeStr, paramName+")") {
		return true
	}
	return false
}

// buildDispatchFuncName creates the public function name for the dispatcher.
// For generic functions (multiple type variants):
//
//	BaseSigmoid[float32] -> SigmoidFloat32
//	BaseSigmoid[float64] -> SigmoidFloat64
//
// For non-generic functions (single concrete type):
//
//	BaseDecodeStreamVByte32Into -> DecodeStreamVByte32Into
func buildDispatchFuncName(baseName, elemType string, isGeneric, private bool) string {
	// Remove "Base" or "base" prefix
	name := strings.TrimPrefix(baseName, "Base")
	name = strings.TrimPrefix(name, "base")

	if private {
		name = makeUnexported(name)
	}

	// Only add type suffix for generic functions (which have multiple type variants)
	if isGeneric {
		name = name + typeNameToSuffix(elemType)
	}

	return name
}

// buildGenericFuncName creates the generic function name (without type suffix).
// BaseSigmoid -> Sigmoid, baseSigmoid -> sigmoid
// BaseAll -> AllP (functions with interface type params get P suffix)
func buildGenericFuncName(baseName string, hasInterfaceParams, private bool) string {
	name := strings.TrimPrefix(baseName, "Base")
	name = strings.TrimPrefix(name, "base")
	if hasInterfaceParams {
		name = name + "P"
	}
	if private {
		name = makeUnexported(name)
	}
	return name
}

// buildDispatchFuncNameCombo creates the dispatch function name for a type combination.
// For single-type combos, behaves like buildDispatchFuncName.
// For multi-type combos, appends all type suffixes concatenated (e.g., "DotGeneralFloat16Float32").
func buildDispatchFuncNameCombo(baseName string, combo TypeCombination, typeParams []TypeParam, private bool) string {
	name := strings.TrimPrefix(baseName, "Base")
	name = strings.TrimPrefix(name, "base")
	if private {
		name = makeUnexported(name)
	}
	suffix := comboTypeSuffix(combo, typeParams)
	if suffix != "" {
		name = name + suffix
	}
	return name
}

// buildFuncSignatureWithMap builds a function signature string from ParsedFunc,
// using typeMap for per-param type resolution when non-nil.
func buildFuncSignatureWithMap(pf ParsedFunc, elemType string, typeMap map[string]string) string {
	var buf bytes.Buffer

	// Parameters
	buf.WriteString("(")
	for i, param := range pf.Params {
		if i > 0 {
			buf.WriteString(", ")
		}
		paramType := specializeTypeWithMap(param.Type, pf.TypeParams, elemType, typeMap)
		buf.WriteString(param.Name)
		buf.WriteString(" ")
		buf.WriteString(paramType)
	}
	buf.WriteString(")")

	// Return values
	if len(pf.Returns) > 0 {
		buf.WriteString(" ")
		if len(pf.Returns) == 1 && pf.Returns[0].Name == "" {
			// Single unnamed return
			retType := specializeTypeWithMap(pf.Returns[0].Type, pf.TypeParams, elemType, typeMap)
			buf.WriteString(retType)
		} else {
			// Multiple or named returns
			buf.WriteString("(")
			for i, ret := range pf.Returns {
				if i > 0 {
					buf.WriteString(", ")
				}
				if ret.Name != "" {
					buf.WriteString(ret.Name)
					buf.WriteString(" ")
				}
				retType := specializeTypeWithMap(ret.Type, pf.TypeParams, elemType, typeMap)
				buf.WriteString(retType)
			}
			buf.WriteString(")")
		}
	}

	return buf.String()
}

// dispatchComboInfo contains the information needed to wire one type combination
// in a dispatch init function.
type dispatchComboInfo struct {
	DispatchName string            // e.g., "DotGeneralFloat16Float32"
	ElemType     string            // primary element type, e.g., "hwy.Float16"
	TypeSuffix   string            // e.g., "Float16Float32" or "Float64"
	Combo        TypeCombination   // the full combination
}

// getDispatchCombos returns dispatch info for all type combinations of a function.
// For non-generic functions, returns a single entry with no type suffix.
// For single-type-param generic functions, returns one entry per concrete type.
// For multi-type-param functions (//hwy:gen), returns one entry per combination.
func getDispatchCombos(pf ParsedFunc) []dispatchComboInfo {
	combos := getTypeCombinations(&pf)
	isGeneric := len(pf.TypeParams) > 0

	var result []dispatchComboInfo
	for _, combo := range combos {
		elemType := comboPrimaryType(combo, pf.TypeParams)

		var dispatchName string
		if !isGeneric {
			dispatchName = buildDispatchFuncName(pf.Name, elemType, false, pf.Private)
		} else {
			dispatchName = buildDispatchFuncNameCombo(pf.Name, combo, pf.TypeParams, pf.Private)
		}

		suffix := comboTypeSuffix(combo, pf.TypeParams)

		result = append(result, dispatchComboInfo{
			DispatchName: dispatchName,
			ElemType:     elemType,
			TypeSuffix:   suffix,
			Combo:        combo,
		})
	}
	return result
}

// getBaseFilename extracts the base filename without extension.
func getBaseFilename(path string) string {
	base := filepath.Base(path)
	ext := filepath.Ext(base)
	return base[:len(base)-len(ext)]
}

// isInterfaceTypeParam checks if a parameter type is an interface type parameter
// (e.g., "P" where P is constrained by Predicate[T]).
func isInterfaceTypeParam(paramType string, typeParams []TypeParam) bool {
	for _, tp := range typeParams {
		if tp.Name == paramType {
			// Check if this is NOT an element type constraint
			if !strings.Contains(tp.Constraint, "Lanes") &&
				!strings.Contains(tp.Constraint, "Floats") &&
				!strings.Contains(tp.Constraint, "Integers") &&
				!strings.Contains(tp.Constraint, "SignedInts") &&
				!strings.Contains(tp.Constraint, "UnsignedInts") {
				return true
			}
		}
	}
	return false
}

// getConstraintForParam returns the constraint for a type parameter.
func getConstraintForParam(paramType string, typeParams []TypeParam) string {
	for _, tp := range typeParams {
		if tp.Name == paramType {
			return tp.Constraint
		}
	}
	return paramType
}

// containsTypeParam checks if a type string contains any of the element type parameters.
// This includes patterns like:
// - "T" (standalone type param)
// - "[]T" (slice of type param)
// - "*Image[T]" (pointer to generic type)
// - "func(T) T" (function with type params)
func containsTypeParam(typeStr string, typeParams []TypeParam) bool {
	for _, tp := range typeParams {
		// Check if this is an element type parameter (not an interface constraint)
		if !strings.Contains(tp.Constraint, "Lanes") &&
			!strings.Contains(tp.Constraint, "Floats") &&
			!strings.Contains(tp.Constraint, "Integers") &&
			!strings.Contains(tp.Constraint, "SignedInts") &&
			!strings.Contains(tp.Constraint, "UnsignedInts") {
			continue // Skip interface type params
		}

		// Check various patterns where the type param might appear
		paramName := tp.Name

		// Exact match (just "T")
		if typeStr == paramName {
			return true
		}

		// In brackets [T] (generic type argument)
		if strings.Contains(typeStr, "["+paramName+"]") {
			return true
		}

		// Slice type []T
		if strings.Contains(typeStr, "[]"+paramName) {
			return true
		}

		// Function parameter/return (T, or (T or ,T or T))
		if strings.Contains(typeStr, "("+paramName) ||
			strings.Contains(typeStr, ","+paramName) ||
			strings.Contains(typeStr, " "+paramName) ||
			strings.HasSuffix(typeStr, paramName) {
			return true
		}
	}
	return false
}

// collectUsedPackages walks the AST of the given functions and returns
// a set of package names that are referenced (e.g., "unsafe" from "unsafe.Slice").
func collectUsedPackages(funcs []*ast.FuncDecl) map[string]bool {
	used := make(map[string]bool)

	for _, fn := range funcs {
		ast.Inspect(fn, func(n ast.Node) bool {
			// Look for selector expressions like "unsafe.Slice" or "bits.Len32"
			if sel, ok := n.(*ast.SelectorExpr); ok {
				if ident, ok := sel.X.(*ast.Ident); ok {
					used[ident.Name] = true
				}
			}
			return true
		})
	}

	return used
}
