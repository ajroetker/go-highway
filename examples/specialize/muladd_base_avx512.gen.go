// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package specialize

import (
	"simd/archsimd"
	"unsafe"
)

func BaseMulAdd_avx512(x []float32, y []float32, out []float32) {
	size := min(len(x), min(len(y), len(out)))
	if size == 0 {
		return
	}
	lanes := 16
	var i int
	for ; i+lanes*4 <= size; i += lanes * 4 {
		vx := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&x[i])))
		vy := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&y[i])))
		vo := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&out[i])))
		vx.MulAdd(vy, vo).Store((*[16]float32)(unsafe.Pointer(&out[i])))
		vx1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&x[i+16])))
		vy1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&y[i+16])))
		vo1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&out[i+16])))
		vx1.MulAdd(vy1, vo1).Store((*[16]float32)(unsafe.Pointer(&out[i+16])))
		vx2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&x[i+32])))
		vy2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&y[i+32])))
		vo2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&out[i+32])))
		vx2.MulAdd(vy2, vo2).Store((*[16]float32)(unsafe.Pointer(&out[i+32])))
		vx3 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&x[i+48])))
		vy3 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&y[i+48])))
		vo3 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&out[i+48])))
		vx3.MulAdd(vy3, vo3).Store((*[16]float32)(unsafe.Pointer(&out[i+48])))
	}
	if i < size {
		BaseMulAdd_fallback(x[i:size], y[i:size], out[i:size])
	}
}

func BaseMulAdd_avx512_Float64(x []float64, y []float64, out []float64) {
	size := min(len(x), min(len(y), len(out)))
	if size == 0 {
		return
	}
	lanes := 8
	var i int
	for ; i+lanes*4 <= size; i += lanes * 4 {
		vx := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&x[i])))
		vy := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&y[i])))
		vo := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&out[i])))
		vx.MulAdd(vy, vo).Store((*[8]float64)(unsafe.Pointer(&out[i])))
		vx1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&x[i+8])))
		vy1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&y[i+8])))
		vo1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&out[i+8])))
		vx1.MulAdd(vy1, vo1).Store((*[8]float64)(unsafe.Pointer(&out[i+8])))
		vx2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&x[i+16])))
		vy2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&y[i+16])))
		vo2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&out[i+16])))
		vx2.MulAdd(vy2, vo2).Store((*[8]float64)(unsafe.Pointer(&out[i+16])))
		vx3 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&x[i+24])))
		vy3 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&y[i+24])))
		vo3 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&out[i+24])))
		vx3.MulAdd(vy3, vo3).Store((*[8]float64)(unsafe.Pointer(&out[i+24])))
	}
	if i < size {
		BaseMulAdd_fallback_Float64(x[i:size], y[i:size], out[i:size])
	}
}
