//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// MulAddCF16 computes MulAdd using NEON SIMD assembly.
func MulAddCF16(x, y, out []hwy.Float16) {
	if len(x) == 0 {
		return
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	var p_y unsafe.Pointer
	if len(y) > 0 {
		p_y = unsafe.Pointer(&y[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(x))
	muladd_c_f16_neon(
		p_x,
		p_y,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// MulAddCBF16 computes MulAdd using NEON SIMD assembly.
func MulAddCBF16(x, y, out []hwy.BFloat16) {
	if len(x) == 0 {
		return
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	var p_y unsafe.Pointer
	if len(y) > 0 {
		p_y = unsafe.Pointer(&y[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(x))
	muladd_c_bf16_neon(
		p_x,
		p_y,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// MulAddCF32 computes MulAdd using NEON SIMD assembly.
func MulAddCF32(x, y, out []float32) {
	if len(x) == 0 {
		return
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	var p_y unsafe.Pointer
	if len(y) > 0 {
		p_y = unsafe.Pointer(&y[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(x))
	muladd_c_f32_neon(
		p_x,
		p_y,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// MulAddCF64 computes MulAdd using NEON SIMD assembly.
func MulAddCF64(x, y, out []float64) {
	if len(x) == 0 {
		return
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	var p_y unsafe.Pointer
	if len(y) > 0 {
		p_y = unsafe.Pointer(&y[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(x))
	muladd_c_f64_neon(
		p_x,
		p_y,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

