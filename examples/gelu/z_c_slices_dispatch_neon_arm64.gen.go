//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package gelu

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/examples/gelu/asm"
)

func init() {
	initNeonCAsm()
}

func initNeonCAsm() {
	if hwy.NoSimdEnv() {
		return
	}
	GELUFloat32 = gELUAsmF32
	GELUFloat64 = gELUAsmF64
	GELUApproxFloat32 = gELUApproxAsmF32
	GELUApproxFloat64 = gELUApproxAsmF64
	if hwy.HasARMFP16() {
		GELUFloat16 = gELUAsmF16
		GELUApproxFloat16 = gELUApproxAsmF16
	}
	if hwy.HasARMBF16() {
		GELUBFloat16 = gELUAsmBF16
		GELUApproxBFloat16 = gELUApproxAsmBF16
	}
}

func gELUAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

