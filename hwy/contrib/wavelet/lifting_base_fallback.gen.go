// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package wavelet

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseLiftUpdate53_fallback_Int32(target []int32, tLen int, neighbor []int32, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	twoVec := int32(int32(2))
	off1, off2 := -1, 0
	if phase == 1 {
		off1, off2 = 0, 1
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= (neighbor[n1Idx] + neighbor[n2Idx] + 2) >> 2
	}
	_ = twoVec
	_ = 1
}

func BaseLiftUpdate53_fallback_Int64(target []int64, tLen int, neighbor []int64, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	twoVec := int64(int64(2))
	off1, off2 := -1, 0
	if phase == 1 {
		off1, off2 = 0, 1
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= (neighbor[n1Idx] + neighbor[n2Idx] + 2) >> 2
	}
	_ = twoVec
	_ = 1
}

func BaseLiftPredict53_fallback_Int32(target []int32, tLen int, neighbor []int32, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	off1, off2 := 0, 1
	if phase == 1 {
		off1, off2 = -1, 0
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] += (neighbor[n1Idx] + neighbor[n2Idx]) >> 1
	}
	_ = 1
}

func BaseLiftPredict53_fallback_Int64(target []int64, tLen int, neighbor []int64, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	off1, off2 := 0, 1
	if phase == 1 {
		off1, off2 = -1, 0
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] += (neighbor[n1Idx] + neighbor[n2Idx]) >> 1
	}
	_ = 1
}

func BaseLiftStep97_fallback_Float16(target []hwy.Float16, tLen int, neighbor []hwy.Float16, nLen int, coeff hwy.Float16, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := hwy.Set(coeff)
	lanes := hwy.MaxLanes[hwy.Float16]()
	off1, off2 := 0, 1
	if phase == 1 {
		off1, off2 = -1, 0
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] = hwy.Float32ToFloat16(target[i].Float32() - coeff.Float32()*(neighbor[n1Idx].Float32()+neighbor[n2Idx].Float32()))
	}
	_ = coeffVec
	_ = lanes
}

func BaseLiftStep97_fallback_BFloat16(target []hwy.BFloat16, tLen int, neighbor []hwy.BFloat16, nLen int, coeff hwy.BFloat16, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := hwy.Set(coeff)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	off1, off2 := 0, 1
	if phase == 1 {
		off1, off2 = -1, 0
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] = hwy.Float32ToBFloat16(target[i].Float32() - coeff.Float32()*(neighbor[n1Idx].Float32()+neighbor[n2Idx].Float32()))
	}
	_ = coeffVec
	_ = lanes
}

func BaseLiftStep97_fallback(target []float32, tLen int, neighbor []float32, nLen int, coeff float32, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := float32(coeff)
	off1, off2 := 0, 1
	if phase == 1 {
		off1, off2 = -1, 0
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= coeff * (neighbor[n1Idx] + neighbor[n2Idx])
	}
	_ = coeffVec
	_ = 1
}

func BaseLiftStep97_fallback_Float64(target []float64, tLen int, neighbor []float64, nLen int, coeff float64, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := float64(coeff)
	off1, off2 := 0, 1
	if phase == 1 {
		off1, off2 = -1, 0
	}
	for i := 0; i < tLen; i++ {
		n1Idx := i + off1
		n2Idx := i + off2
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx < 0 {
			n2Idx = 0
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= coeff * (neighbor[n1Idx] + neighbor[n2Idx])
	}
	_ = coeffVec
	_ = 1
}

func BaseScaleSlice_fallback_Float16(data []hwy.Float16, n int, scale hwy.Float16) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := hwy.Set(scale)
	lanes := hwy.MaxLanes[hwy.Float16]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.Load(data[i:])
		result := hwy.Mul(v, scaleVec)
		hwy.Store(result, data[i:])
	}
	if remaining := n - i; remaining > 0 {
		buf := make([]hwy.Float16, lanes)
		copy(buf, data[i:i+remaining])
		v := hwy.Load(buf)
		result := hwy.Mul(v, scaleVec)
		hwy.Store(result, buf)
		copy(data[i:i+remaining], buf[:remaining])
	}
}

func BaseScaleSlice_fallback_BFloat16(data []hwy.BFloat16, n int, scale hwy.BFloat16) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := hwy.Set(scale)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.Load(data[i:])
		result := hwy.Mul(v, scaleVec)
		hwy.Store(result, data[i:])
	}
	if remaining := n - i; remaining > 0 {
		buf := make([]hwy.BFloat16, lanes)
		copy(buf, data[i:i+remaining])
		v := hwy.Load(buf)
		result := hwy.Mul(v, scaleVec)
		hwy.Store(result, buf)
		copy(data[i:i+remaining], buf[:remaining])
	}
}

func BaseScaleSlice_fallback(data []float32, n int, scale float32) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := float32(scale)
	i := 0
	for ; i < n; i++ {
		v := data[i]
		result := v * scaleVec
		data[i] = result
	}
	if remaining := n - i; remaining > 0 {
		buf := make([]float32, 1)
		copy(buf, data[i:i+remaining])
		v := buf[0]
		result := v * scaleVec
		buf[0] = result
		copy(data[i:i+remaining], buf[:remaining])
	}
}

func BaseScaleSlice_fallback_Float64(data []float64, n int, scale float64) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := float64(scale)
	i := 0
	for ; i < n; i++ {
		v := data[i]
		result := v * scaleVec
		data[i] = result
	}
	if remaining := n - i; remaining > 0 {
		buf := make([]float64, 1)
		copy(buf, data[i:i+remaining])
		v := buf[0]
		result := v * scaleVec
		buf[0] = result
		copy(data[i:i+remaining], buf[:remaining])
	}
}

func BaseInterleave_fallback(dst []float32, low []float32, sn int, high []float32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Float64(dst []float64, low []float64, sn int, high []float64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Int32(dst []int32, low []int32, sn int, high []int32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Int64(dst []int64, low []int64, sn int, high []int64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Uint32(dst []uint32, low []uint32, sn int, high []uint32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Uint64(dst []uint64, low []uint64, sn int, high []uint64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseDeinterleave_fallback(src []float32, low []float32, sn int, high []float32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn; i++ {
			low[i] = src[2*i]
		}
		for i := 0; i < dn; i++ {
			high[i] = src[2*i+1]
		}
	} else {
		for i := 0; i < dn; i++ {
			high[i] = src[2*i]
		}
		for i := 0; i < sn; i++ {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Float64(src []float64, low []float64, sn int, high []float64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn; i++ {
			low[i] = src[2*i]
		}
		for i := 0; i < dn; i++ {
			high[i] = src[2*i+1]
		}
	} else {
		for i := 0; i < dn; i++ {
			high[i] = src[2*i]
		}
		for i := 0; i < sn; i++ {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Int32(src []int32, low []int32, sn int, high []int32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn; i++ {
			low[i] = src[2*i]
		}
		for i := 0; i < dn; i++ {
			high[i] = src[2*i+1]
		}
	} else {
		for i := 0; i < dn; i++ {
			high[i] = src[2*i]
		}
		for i := 0; i < sn; i++ {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Int64(src []int64, low []int64, sn int, high []int64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn; i++ {
			low[i] = src[2*i]
		}
		for i := 0; i < dn; i++ {
			high[i] = src[2*i+1]
		}
	} else {
		for i := 0; i < dn; i++ {
			high[i] = src[2*i]
		}
		for i := 0; i < sn; i++ {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Uint32(src []uint32, low []uint32, sn int, high []uint32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn; i++ {
			low[i] = src[2*i]
		}
		for i := 0; i < dn; i++ {
			high[i] = src[2*i+1]
		}
	} else {
		for i := 0; i < dn; i++ {
			high[i] = src[2*i]
		}
		for i := 0; i < sn; i++ {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Uint64(src []uint64, low []uint64, sn int, high []uint64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn; i++ {
			low[i] = src[2*i]
		}
		for i := 0; i < dn; i++ {
			high[i] = src[2*i+1]
		}
	} else {
		for i := 0; i < dn; i++ {
			high[i] = src[2*i]
		}
		for i := 0; i < sn; i++ {
			low[i] = src[2*i+1]
		}
	}
}
