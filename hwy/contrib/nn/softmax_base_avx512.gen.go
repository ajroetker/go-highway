// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package nn

import (
	stdmath "math"
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
)

func BaseSoftmax_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	vMax := asm.BroadcastFloat16x16AVX512(uint16(maxVal))
	vSum := asm.ZeroFloat16x16AVX512()
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512_Float16(shifted)
		expVal.StorePtr(unsafe.Pointer(&output[ii:][0]))
		vSum = vSum.Add(expVal)
		x1 := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii+16:][0]))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512_Float16(shifted1)
		expVal1.StorePtr(unsafe.Pointer(&output[ii+16:][0]))
		vSum = vSum.Add(expVal1)
	}
	expSum := vSum.ReduceSum()
	for ; ii < size; ii++ {
		expVal := hwy.Float32ToFloat16(float32(stdmath.Exp(float64(input[ii].Float32() - maxVal.Float32()))))
		output[ii] = hwy.Float32ToFloat16(expVal.Float32())
		expSum += expVal.Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	vInvSum := asm.BroadcastFloat16x16AVX512(uint16(invSum))
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&output[ii:][0]))
		v.Mul(vInvSum).StorePtr(unsafe.Pointer(&output[ii:][0]))
	}
	for ; ii < size; ii++ {
		output[ii] = hwy.Float32ToFloat16(output[ii].Float32() * invSum.Float32())
	}
}

func BaseSoftmax_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	vMax := asm.BroadcastBFloat16x16AVX512(uint16(maxVal))
	vSum := asm.ZeroBFloat16x16AVX512()
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512_BFloat16(shifted)
		expVal.StorePtr(unsafe.Pointer(&output[ii:][0]))
		vSum = vSum.Add(expVal)
		x1 := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii+16:][0]))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512_BFloat16(shifted1)
		expVal1.StorePtr(unsafe.Pointer(&output[ii+16:][0]))
		vSum = vSum.Add(expVal1)
	}
	expSum := vSum.ReduceSum()
	for ; ii < size; ii++ {
		expVal := hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(input[ii].Float32() - maxVal.Float32()))))
		output[ii] = hwy.Float32ToBFloat16(expVal.Float32())
		expSum += expVal.Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	vInvSum := asm.BroadcastBFloat16x16AVX512(uint16(invSum))
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&output[ii:][0]))
		v.Mul(vInvSum).StorePtr(unsafe.Pointer(&output[ii:][0]))
	}
	for ; ii < size; ii++ {
		output[ii] = hwy.Float32ToBFloat16(output[ii].Float32() * invSum.Float32())
	}
}

func BaseSoftmax_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	vMax := archsimd.BroadcastFloat32x16(maxVal)
	vSum := archsimd.BroadcastFloat32x16(0)
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512(shifted)
		expVal.Store((*[16]float32)(unsafe.Pointer(&output[ii])))
		vSum = vSum.Add(expVal)
		x1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii+16])))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512(shifted1)
		expVal1.Store((*[16]float32)(unsafe.Pointer(&output[ii+16])))
		vSum = vSum.Add(expVal1)
	}
	expSum := hwy.ReduceSum_AVX512_F32x16(vSum)
	for ; ii < size; ii++ {
		expVal := float32(stdmath.Exp(float64(input[ii] - maxVal)))
		output[ii] = expVal
		expSum += expVal
	}
	invSum := float32(1.0) / expSum
	vInvSum := archsimd.BroadcastFloat32x16(invSum)
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&output[ii])))
		v.Mul(vInvSum).Store((*[16]float32)(unsafe.Pointer(&output[ii])))
	}
	for ; ii < size; ii++ {
		output[ii] *= invSum
	}
}

func BaseSoftmax_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	vMax := archsimd.BroadcastFloat64x8(maxVal)
	vSum := archsimd.BroadcastFloat64x8(0)
	lanes := 8
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512_Float64(shifted)
		expVal.Store((*[8]float64)(unsafe.Pointer(&output[ii])))
		vSum = vSum.Add(expVal)
		x1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii+8])))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512_Float64(shifted1)
		expVal1.Store((*[8]float64)(unsafe.Pointer(&output[ii+8])))
		vSum = vSum.Add(expVal1)
	}
	expSum := hwy.ReduceSum_AVX512_F64x8(vSum)
	for ; ii < size; ii++ {
		expVal := float64(stdmath.Exp(float64(input[ii] - maxVal)))
		output[ii] = expVal
		expSum += expVal
	}
	invSum := float64(1.0) / expSum
	vInvSum := archsimd.BroadcastFloat64x8(invSum)
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&output[ii])))
		v.Mul(vInvSum).Store((*[8]float64)(unsafe.Pointer(&output[ii])))
	}
	for ; ii < size; ii++ {
		output[ii] *= invSum
	}
}

func BaseSoftmaxInPlace_avx512_Float16(x []hwy.Float16) {
	BaseSoftmax_avx512_Float16(x, x)
}

func BaseSoftmaxInPlace_avx512_BFloat16(x []hwy.BFloat16) {
	BaseSoftmax_avx512_BFloat16(x, x)
}

func BaseSoftmaxInPlace_avx512(x []float32) {
	BaseSoftmax_avx512(x, x)
}

func BaseSoftmaxInPlace_avx512_Float64(x []float64) {
	BaseSoftmax_avx512_Float64(x, x)
}

func BaseLogSoftmax_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	vMax := asm.BroadcastFloat16x16AVX512(uint16(maxVal))
	vSum := asm.ZeroFloat16x16AVX512()
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512_Float16(shifted)
		vSum = vSum.Add(expVal)
		x1 := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii+16:][0]))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512_Float16(shifted1)
		vSum = vSum.Add(expVal1)
	}
	expSum := vSum.ReduceSum()
	for ; ii < size; ii++ {
		expSum += float32(stdmath.Exp(float64(input[ii].Float32() - maxVal.Float32())))
	}
	logSumExp := hwy.Float32ToFloat16(float32(stdmath.Log(float64(expSum))))
	offset := hwy.Float32ToFloat16(maxVal.Float32() + logSumExp.Float32())
	vOffset := asm.BroadcastFloat16x16AVX512(uint16(offset))
	for ii = 0; ii+lanes <= size; ii += lanes {
		x := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		x.Sub(vOffset).StorePtr(unsafe.Pointer(&output[ii:][0]))
	}
	for ; ii < size; ii++ {
		output[ii] = hwy.Float32ToFloat16(input[ii].Float32() - offset.Float32())
	}
}

func BaseLogSoftmax_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	vMax := asm.BroadcastBFloat16x16AVX512(uint16(maxVal))
	vSum := asm.ZeroBFloat16x16AVX512()
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512_BFloat16(shifted)
		vSum = vSum.Add(expVal)
		x1 := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii+16:][0]))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512_BFloat16(shifted1)
		vSum = vSum.Add(expVal1)
	}
	expSum := vSum.ReduceSum()
	for ; ii < size; ii++ {
		expSum += float32(stdmath.Exp(float64(input[ii].Float32() - maxVal.Float32())))
	}
	logSumExp := hwy.Float32ToBFloat16(float32(stdmath.Log(float64(expSum))))
	offset := hwy.Float32ToBFloat16(maxVal.Float32() + logSumExp.Float32())
	vOffset := asm.BroadcastBFloat16x16AVX512(uint16(offset))
	for ii = 0; ii+lanes <= size; ii += lanes {
		x := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		x.Sub(vOffset).StorePtr(unsafe.Pointer(&output[ii:][0]))
	}
	for ; ii < size; ii++ {
		output[ii] = hwy.Float32ToBFloat16(input[ii].Float32() - offset.Float32())
	}
}

func BaseLogSoftmax_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	vMax := archsimd.BroadcastFloat32x16(maxVal)
	vSum := archsimd.BroadcastFloat32x16(0)
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512(shifted)
		vSum = vSum.Add(expVal)
		x1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii+16])))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512(shifted1)
		vSum = vSum.Add(expVal1)
	}
	expSum := hwy.ReduceSum_AVX512_F32x16(vSum)
	for ; ii < size; ii++ {
		expSum += float32(stdmath.Exp(float64(input[ii] - maxVal)))
	}
	logSumExp := float32(stdmath.Log(float64(expSum)))
	offset := maxVal + logSumExp
	vOffset := archsimd.BroadcastFloat32x16(offset)
	for ii = 0; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
		x.Sub(vOffset).Store((*[16]float32)(unsafe.Pointer(&output[ii])))
	}
	for ; ii < size; ii++ {
		output[ii] = input[ii] - offset
	}
}

func BaseLogSoftmax_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	vMax := archsimd.BroadcastFloat64x8(maxVal)
	vSum := archsimd.BroadcastFloat64x8(0)
	lanes := 8
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_avx512_Float64(shifted)
		vSum = vSum.Add(expVal)
		x1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii+8])))
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_avx512_Float64(shifted1)
		vSum = vSum.Add(expVal1)
	}
	expSum := hwy.ReduceSum_AVX512_F64x8(vSum)
	for ; ii < size; ii++ {
		expSum += float64(stdmath.Exp(float64(input[ii] - maxVal)))
	}
	logSumExp := float64(stdmath.Log(float64(expSum)))
	offset := maxVal + logSumExp
	vOffset := archsimd.BroadcastFloat64x8(offset)
	for ii = 0; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
		x.Sub(vOffset).Store((*[8]float64)(unsafe.Pointer(&output[ii])))
	}
	for ; ii < size; ii++ {
		output[ii] = input[ii] - offset
	}
}

func BaseLogSoftmaxInPlace_avx512_Float16(x []hwy.Float16) {
	BaseLogSoftmax_avx512_Float16(x, x)
}

func BaseLogSoftmaxInPlace_avx512_BFloat16(x []hwy.BFloat16) {
	BaseLogSoftmax_avx512_BFloat16(x, x)
}

func BaseLogSoftmaxInPlace_avx512(x []float32) {
	BaseLogSoftmax_avx512(x, x)
}

func BaseLogSoftmaxInPlace_avx512_Float64(x []float64) {
	BaseLogSoftmax_avx512_Float64(x, x)
}

func BaseSoftmaxScalar_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxScalar_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxScalar_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = float32(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxScalar_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float64
	for i := range size {
		output[i] = float64(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxWithTemperature_avx512_Float16(input []hwy.Float16, output []hwy.Float16, temperature hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	invTemp := hwy.Float32ToFloat16(float32(1.0) / temperature.Float32())
	vMax := asm.BroadcastFloat16x16AVX512(uint16(maxVal))
	vInvTemp := asm.BroadcastFloat16x16AVX512(uint16(invTemp))
	vSum := asm.ZeroFloat16x16AVX512()
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		shifted := x.Sub(vMax).Mul(vInvTemp)
		expVal := math.BaseExpVec_avx512_Float16(shifted)
		expVal.StorePtr(unsafe.Pointer(&output[ii:][0]))
		vSum = vSum.Add(expVal)
		x1 := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii+16:][0]))
		shifted1 := x1.Sub(vMax).Mul(vInvTemp)
		expVal1 := math.BaseExpVec_avx512_Float16(shifted1)
		expVal1.StorePtr(unsafe.Pointer(&output[ii+16:][0]))
		vSum = vSum.Add(expVal1)
	}
	expSum := vSum.ReduceSum()
	for ; ii < size; ii++ {
		shifted := hwy.Float32ToFloat16((input[ii].Float32() - maxVal.Float32()) * invTemp.Float32())
		expVal := hwy.Float32ToFloat16(float32(stdmath.Exp(float64(shifted.Float32()))))
		output[ii] = hwy.Float32ToFloat16(expVal.Float32())
		expSum += expVal.Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	vInvSum := asm.BroadcastFloat16x16AVX512(uint16(invSum))
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&output[ii:][0]))
		v.Mul(vInvSum).StorePtr(unsafe.Pointer(&output[ii:][0]))
	}
	for ; ii < size; ii++ {
		output[ii] = hwy.Float32ToFloat16(output[ii].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxWithTemperature_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, temperature hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	invTemp := hwy.Float32ToBFloat16(float32(1.0) / temperature.Float32())
	vMax := asm.BroadcastBFloat16x16AVX512(uint16(maxVal))
	vInvTemp := asm.BroadcastBFloat16x16AVX512(uint16(invTemp))
	vSum := asm.ZeroBFloat16x16AVX512()
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii:][0]))
		shifted := x.Sub(vMax).Mul(vInvTemp)
		expVal := math.BaseExpVec_avx512_BFloat16(shifted)
		expVal.StorePtr(unsafe.Pointer(&output[ii:][0]))
		vSum = vSum.Add(expVal)
		x1 := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&input[ii+16:][0]))
		shifted1 := x1.Sub(vMax).Mul(vInvTemp)
		expVal1 := math.BaseExpVec_avx512_BFloat16(shifted1)
		expVal1.StorePtr(unsafe.Pointer(&output[ii+16:][0]))
		vSum = vSum.Add(expVal1)
	}
	expSum := vSum.ReduceSum()
	for ; ii < size; ii++ {
		shifted := hwy.Float32ToBFloat16((input[ii].Float32() - maxVal.Float32()) * invTemp.Float32())
		expVal := hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(shifted.Float32()))))
		output[ii] = hwy.Float32ToBFloat16(expVal.Float32())
		expSum += expVal.Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	vInvSum := asm.BroadcastBFloat16x16AVX512(uint16(invSum))
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&output[ii:][0]))
		v.Mul(vInvSum).StorePtr(unsafe.Pointer(&output[ii:][0]))
	}
	for ; ii < size; ii++ {
		output[ii] = hwy.Float32ToBFloat16(output[ii].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxWithTemperature_avx512(input []float32, output []float32, temperature float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	invTemp := float32(1.0) / temperature
	vMax := archsimd.BroadcastFloat32x16(maxVal)
	vInvTemp := archsimd.BroadcastFloat32x16(invTemp)
	vSum := archsimd.BroadcastFloat32x16(0)
	lanes := 16
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
		shifted := x.Sub(vMax).Mul(vInvTemp)
		expVal := math.BaseExpVec_avx512(shifted)
		expVal.Store((*[16]float32)(unsafe.Pointer(&output[ii])))
		vSum = vSum.Add(expVal)
		x1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii+16])))
		shifted1 := x1.Sub(vMax).Mul(vInvTemp)
		expVal1 := math.BaseExpVec_avx512(shifted1)
		expVal1.Store((*[16]float32)(unsafe.Pointer(&output[ii+16])))
		vSum = vSum.Add(expVal1)
	}
	expSum := hwy.ReduceSum_AVX512_F32x16(vSum)
	for ; ii < size; ii++ {
		shifted := (input[ii] - maxVal) * invTemp
		expVal := float32(stdmath.Exp(float64(shifted)))
		output[ii] = expVal
		expSum += expVal
	}
	invSum := float32(1.0) / expSum
	vInvSum := archsimd.BroadcastFloat32x16(invSum)
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&output[ii])))
		v.Mul(vInvSum).Store((*[16]float32)(unsafe.Pointer(&output[ii])))
	}
	for ; ii < size; ii++ {
		output[ii] *= invSum
	}
}

func BaseSoftmaxWithTemperature_avx512_Float64(input []float64, output []float64, temperature float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	invTemp := float64(1.0) / temperature
	vMax := archsimd.BroadcastFloat64x8(maxVal)
	vInvTemp := archsimd.BroadcastFloat64x8(invTemp)
	vSum := archsimd.BroadcastFloat64x8(0)
	lanes := 8
	var ii int
	for ii = 0; ii+lanes*2 <= size; ii += lanes * 2 {
		x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
		shifted := x.Sub(vMax).Mul(vInvTemp)
		expVal := math.BaseExpVec_avx512_Float64(shifted)
		expVal.Store((*[8]float64)(unsafe.Pointer(&output[ii])))
		vSum = vSum.Add(expVal)
		x1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii+8])))
		shifted1 := x1.Sub(vMax).Mul(vInvTemp)
		expVal1 := math.BaseExpVec_avx512_Float64(shifted1)
		expVal1.Store((*[8]float64)(unsafe.Pointer(&output[ii+8])))
		vSum = vSum.Add(expVal1)
	}
	expSum := hwy.ReduceSum_AVX512_F64x8(vSum)
	for ; ii < size; ii++ {
		shifted := (input[ii] - maxVal) * invTemp
		expVal := float64(stdmath.Exp(float64(shifted)))
		output[ii] = expVal
		expSum += expVal
	}
	invSum := float64(1.0) / expSum
	vInvSum := archsimd.BroadcastFloat64x8(invSum)
	for ii = 0; ii+lanes <= size; ii += lanes {
		v := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&output[ii])))
		v.Mul(vInvSum).Store((*[8]float64)(unsafe.Pointer(&output[ii])))
	}
	for ; ii < size; ii++ {
		output[ii] *= invSum
	}
}
