// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package nn

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
)

func BaseSoftmax_neon_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	lanes := 8
	vMax := hwy.Set(maxVal)
	sumAcc := hwy.Zero[hwy.Float16]()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.SubF16(x, vMax)
		expVal := math.BaseExpVec_neon_Float16(shifted)
		hwy.StoreSlice(expVal, output[i:])
		sumAcc = hwy.AddF16(sumAcc, expVal)
		x1 := hwy.LoadSlice(input[i+8:])
		shifted1 := hwy.SubF16(x1, vMax)
		expVal1 := math.BaseExpVec_neon_Float16(shifted1)
		hwy.StoreSlice(expVal1, output[i+8:])
		sumAcc = hwy.AddF16(sumAcc, expVal1)
	}
	expSum := hwy.ReduceSumF16(sumAcc)
	for ; i < size; i++ {
		val := hwy.Float32ToFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		output[i] = hwy.Float32ToFloat16(val.Float32())
		expSum += val.Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	vInvSum := hwy.Set(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := hwy.LoadSlice(output[i:])
		result := hwy.MulF16(x, vInvSum)
		hwy.StoreSlice(result, output[i:])
	}
	for ; i < size; i++ {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmax_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	lanes := 8
	vMax := hwy.Set(maxVal)
	sumAcc := hwy.Zero[hwy.BFloat16]()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.SubBF16(x, vMax)
		expVal := math.BaseExpVec_neon_BFloat16(shifted)
		hwy.StoreSlice(expVal, output[i:])
		sumAcc = hwy.AddBF16(sumAcc, expVal)
		x1 := hwy.LoadSlice(input[i+8:])
		shifted1 := hwy.SubBF16(x1, vMax)
		expVal1 := math.BaseExpVec_neon_BFloat16(shifted1)
		hwy.StoreSlice(expVal1, output[i+8:])
		sumAcc = hwy.AddBF16(sumAcc, expVal1)
	}
	expSum := hwy.ReduceSumBF16(sumAcc)
	for ; i < size; i++ {
		val := hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		output[i] = hwy.Float32ToBFloat16(val.Float32())
		expSum += val.Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	vInvSum := hwy.Set(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := hwy.LoadSlice(output[i:])
		result := hwy.MulBF16(x, vInvSum)
		hwy.StoreSlice(result, output[i:])
	}
	for ; i < size; i++ {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmax_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	lanes := 4
	vMax := asm.BroadcastFloat32x4(maxVal)
	sumAcc := asm.ZeroFloat32x4()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := asm.LoadFloat32x4Slice(input[i:])
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_neon(shifted)
		expVal.StoreSlice(output[i:])
		sumAcc = sumAcc.Add(expVal)
		x1 := asm.LoadFloat32x4Slice(input[i+4:])
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_neon(shifted1)
		expVal1.StoreSlice(output[i+4:])
		sumAcc = sumAcc.Add(expVal1)
	}
	expSum := sumAcc.ReduceSum()
	for ; i < size; i++ {
		val := float32(stdmath.Exp(float64(input[i] - maxVal)))
		output[i] = val
		expSum += val
	}
	invSum := float32(1.0) / expSum
	vInvSum := asm.BroadcastFloat32x4(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := asm.LoadFloat32x4Slice(output[i:])
		result := x.Mul(vInvSum)
		result.StoreSlice(output[i:])
	}
	for ; i < size; i++ {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmax_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	lanes := 2
	vMax := asm.BroadcastFloat64x2(maxVal)
	sumAcc := asm.ZeroFloat64x2()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := asm.LoadFloat64x2Slice(input[i:])
		shifted := x.Sub(vMax)
		expVal := math.BaseExpVec_neon_Float64(shifted)
		expVal.StoreSlice(output[i:])
		sumAcc = sumAcc.Add(expVal)
		x1 := asm.LoadFloat64x2Slice(input[i+2:])
		shifted1 := x1.Sub(vMax)
		expVal1 := math.BaseExpVec_neon_Float64(shifted1)
		expVal1.StoreSlice(output[i+2:])
		sumAcc = sumAcc.Add(expVal1)
	}
	expSum := sumAcc.ReduceSum()
	for ; i < size; i++ {
		val := float64(stdmath.Exp(float64(input[i] - maxVal)))
		output[i] = val
		expSum += val
	}
	invSum := float64(1.0) / expSum
	vInvSum := asm.BroadcastFloat64x2(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := asm.LoadFloat64x2Slice(output[i:])
		result := x.Mul(vInvSum)
		result.StoreSlice(output[i:])
	}
	for ; i < size; i++ {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxInPlace_neon_Float16(x []hwy.Float16) {
	BaseSoftmax_neon_Float16(x, x)
}

func BaseSoftmaxInPlace_neon_BFloat16(x []hwy.BFloat16) {
	BaseSoftmax_neon_BFloat16(x, x)
}

func BaseSoftmaxInPlace_neon(x []float32) {
	BaseSoftmax_neon(x, x)
}

func BaseSoftmaxInPlace_neon_Float64(x []float64) {
	BaseSoftmax_neon_Float64(x, x)
}

func BaseLogSoftmax_neon_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	lanes := 8
	vMax := hwy.Set(maxVal)
	sumAcc := hwy.Zero[hwy.Float16]()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.SubF16(x, vMax)
		sumAcc = hwy.AddF16(sumAcc, math.BaseExpVec_neon_Float16(shifted))
		x1 := hwy.LoadSlice(input[i+8:])
		shifted1 := hwy.SubF16(x1, vMax)
		sumAcc = hwy.AddF16(sumAcc, math.BaseExpVec_neon_Float16(shifted1))
	}
	expSum := hwy.ReduceSumF16(sumAcc)
	for ; i < size; i++ {
		expSum += float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32())))
	}
	logSumExp := hwy.Float32ToFloat16(float32(stdmath.Log(float64(expSum))))
	vLogSumExp := hwy.Set(logSumExp)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.SubF16(x, vMax)
		result := hwy.SubF16(shifted, vLogSumExp)
		hwy.StoreSlice(result, output[i:])
	}
	for ; i < size; i++ {
		output[i] = hwy.Float32ToFloat16((input[i].Float32() - maxVal.Float32()) - logSumExp.Float32())
	}
}

func BaseLogSoftmax_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	lanes := 8
	vMax := hwy.Set(maxVal)
	sumAcc := hwy.Zero[hwy.BFloat16]()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.SubBF16(x, vMax)
		sumAcc = hwy.AddBF16(sumAcc, math.BaseExpVec_neon_BFloat16(shifted))
		x1 := hwy.LoadSlice(input[i+8:])
		shifted1 := hwy.SubBF16(x1, vMax)
		sumAcc = hwy.AddBF16(sumAcc, math.BaseExpVec_neon_BFloat16(shifted1))
	}
	expSum := hwy.ReduceSumBF16(sumAcc)
	for ; i < size; i++ {
		expSum += float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32())))
	}
	logSumExp := hwy.Float32ToBFloat16(float32(stdmath.Log(float64(expSum))))
	vLogSumExp := hwy.Set(logSumExp)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.SubBF16(x, vMax)
		result := hwy.SubBF16(shifted, vLogSumExp)
		hwy.StoreSlice(result, output[i:])
	}
	for ; i < size; i++ {
		output[i] = hwy.Float32ToBFloat16((input[i].Float32() - maxVal.Float32()) - logSumExp.Float32())
	}
}

func BaseLogSoftmax_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	lanes := 4
	vMax := asm.BroadcastFloat32x4(maxVal)
	sumAcc := asm.ZeroFloat32x4()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := asm.LoadFloat32x4Slice(input[i:])
		shifted := x.Sub(vMax)
		sumAcc = sumAcc.Add(math.BaseExpVec_neon(shifted))
		x1 := asm.LoadFloat32x4Slice(input[i+4:])
		shifted1 := x1.Sub(vMax)
		sumAcc = sumAcc.Add(math.BaseExpVec_neon(shifted1))
	}
	expSum := sumAcc.ReduceSum()
	for ; i < size; i++ {
		expSum += float32(stdmath.Exp(float64(input[i] - maxVal)))
	}
	logSumExp := float32(stdmath.Log(float64(expSum)))
	vLogSumExp := asm.BroadcastFloat32x4(logSumExp)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := asm.LoadFloat32x4Slice(input[i:])
		shifted := x.Sub(vMax)
		result := shifted.Sub(vLogSumExp)
		result.StoreSlice(output[i:])
	}
	for ; i < size; i++ {
		output[i] = (input[i] - maxVal) - logSumExp
	}
}

func BaseLogSoftmax_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	lanes := 2
	vMax := asm.BroadcastFloat64x2(maxVal)
	sumAcc := asm.ZeroFloat64x2()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := asm.LoadFloat64x2Slice(input[i:])
		shifted := x.Sub(vMax)
		sumAcc = sumAcc.Add(math.BaseExpVec_neon_Float64(shifted))
		x1 := asm.LoadFloat64x2Slice(input[i+2:])
		shifted1 := x1.Sub(vMax)
		sumAcc = sumAcc.Add(math.BaseExpVec_neon_Float64(shifted1))
	}
	expSum := sumAcc.ReduceSum()
	for ; i < size; i++ {
		expSum += float64(stdmath.Exp(float64(input[i] - maxVal)))
	}
	logSumExp := float64(stdmath.Log(float64(expSum)))
	vLogSumExp := asm.BroadcastFloat64x2(logSumExp)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := asm.LoadFloat64x2Slice(input[i:])
		shifted := x.Sub(vMax)
		result := shifted.Sub(vLogSumExp)
		result.StoreSlice(output[i:])
	}
	for ; i < size; i++ {
		output[i] = (input[i] - maxVal) - logSumExp
	}
}

func BaseLogSoftmaxInPlace_neon_Float16(x []hwy.Float16) {
	BaseLogSoftmax_neon_Float16(x, x)
}

func BaseLogSoftmaxInPlace_neon_BFloat16(x []hwy.BFloat16) {
	BaseLogSoftmax_neon_BFloat16(x, x)
}

func BaseLogSoftmaxInPlace_neon(x []float32) {
	BaseLogSoftmax_neon(x, x)
}

func BaseLogSoftmaxInPlace_neon_Float64(x []float64) {
	BaseLogSoftmax_neon_Float64(x, x)
}

func BaseSoftmaxScalar_neon_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxScalar_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxScalar_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = float32(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxScalar_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	var expSum float64
	for i := range size {
		output[i] = float64(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxWithTemperature_neon_Float16(input []hwy.Float16, output []hwy.Float16, temperature hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	lanes := 8
	invTemp := hwy.Float32ToFloat16(float32(1.0) / temperature.Float32())
	vMax := hwy.Set(maxVal)
	vInvTemp := hwy.Set(invTemp)
	sumAcc := hwy.Zero[hwy.Float16]()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.MulF16(hwy.SubF16(x, vMax), vInvTemp)
		expVal := math.BaseExpVec_neon_Float16(shifted)
		hwy.StoreSlice(expVal, output[i:])
		sumAcc = hwy.AddF16(sumAcc, expVal)
		x1 := hwy.LoadSlice(input[i+8:])
		shifted1 := hwy.MulF16(hwy.SubF16(x1, vMax), vInvTemp)
		expVal1 := math.BaseExpVec_neon_Float16(shifted1)
		hwy.StoreSlice(expVal1, output[i+8:])
		sumAcc = hwy.AddF16(sumAcc, expVal1)
	}
	expSum := hwy.ReduceSumF16(sumAcc)
	for ; i < size; i++ {
		val := hwy.Float32ToFloat16(float32(stdmath.Exp(float64((input[i].Float32() - maxVal.Float32()) * invTemp.Float32()))))
		output[i] = hwy.Float32ToFloat16(val.Float32())
		expSum += val.Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	vInvSum := hwy.Set(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := hwy.LoadSlice(output[i:])
		result := hwy.MulF16(x, vInvSum)
		hwy.StoreSlice(result, output[i:])
	}
	for ; i < size; i++ {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxWithTemperature_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, temperature hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j].Float32() > maxVal.Float32() {
			maxVal = input[j]
		}
	}
	lanes := 8
	invTemp := hwy.Float32ToBFloat16(float32(1.0) / temperature.Float32())
	vMax := hwy.Set(maxVal)
	vInvTemp := hwy.Set(invTemp)
	sumAcc := hwy.Zero[hwy.BFloat16]()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := hwy.LoadSlice(input[i:])
		shifted := hwy.MulBF16(hwy.SubBF16(x, vMax), vInvTemp)
		expVal := math.BaseExpVec_neon_BFloat16(shifted)
		hwy.StoreSlice(expVal, output[i:])
		sumAcc = hwy.AddBF16(sumAcc, expVal)
		x1 := hwy.LoadSlice(input[i+8:])
		shifted1 := hwy.MulBF16(hwy.SubBF16(x1, vMax), vInvTemp)
		expVal1 := math.BaseExpVec_neon_BFloat16(shifted1)
		hwy.StoreSlice(expVal1, output[i+8:])
		sumAcc = hwy.AddBF16(sumAcc, expVal1)
	}
	expSum := hwy.ReduceSumBF16(sumAcc)
	for ; i < size; i++ {
		val := hwy.Float32ToBFloat16(float32(stdmath.Exp(float64((input[i].Float32() - maxVal.Float32()) * invTemp.Float32()))))
		output[i] = hwy.Float32ToBFloat16(val.Float32())
		expSum += val.Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	vInvSum := hwy.Set(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := hwy.LoadSlice(output[i:])
		result := hwy.MulBF16(x, vInvSum)
		hwy.StoreSlice(result, output[i:])
	}
	for ; i < size; i++ {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxWithTemperature_neon(input []float32, output []float32, temperature float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	lanes := 4
	invTemp := float32(1.0) / temperature
	vMax := asm.BroadcastFloat32x4(maxVal)
	vInvTemp := asm.BroadcastFloat32x4(invTemp)
	sumAcc := asm.ZeroFloat32x4()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := asm.LoadFloat32x4Slice(input[i:])
		shifted := x.Sub(vMax).Mul(vInvTemp)
		expVal := math.BaseExpVec_neon(shifted)
		expVal.StoreSlice(output[i:])
		sumAcc = sumAcc.Add(expVal)
		x1 := asm.LoadFloat32x4Slice(input[i+4:])
		shifted1 := x1.Sub(vMax).Mul(vInvTemp)
		expVal1 := math.BaseExpVec_neon(shifted1)
		expVal1.StoreSlice(output[i+4:])
		sumAcc = sumAcc.Add(expVal1)
	}
	expSum := sumAcc.ReduceSum()
	for ; i < size; i++ {
		val := float32(stdmath.Exp(float64((input[i] - maxVal) * invTemp)))
		output[i] = val
		expSum += val
	}
	invSum := float32(1.0) / expSum
	vInvSum := asm.BroadcastFloat32x4(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := asm.LoadFloat32x4Slice(output[i:])
		result := x.Mul(vInvSum)
		result.StoreSlice(output[i:])
	}
	for ; i < size; i++ {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxWithTemperature_neon_Float64(input []float64, output []float64, temperature float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for j := 1; j < size; j++ {
		if input[j] > maxVal {
			maxVal = input[j]
		}
	}
	lanes := 2
	invTemp := float64(1.0) / temperature
	vMax := asm.BroadcastFloat64x2(maxVal)
	vInvTemp := asm.BroadcastFloat64x2(invTemp)
	sumAcc := asm.ZeroFloat64x2()
	i := 0
	for ; i+lanes*2 <= size; i += lanes * 2 {
		x := asm.LoadFloat64x2Slice(input[i:])
		shifted := x.Sub(vMax).Mul(vInvTemp)
		expVal := math.BaseExpVec_neon_Float64(shifted)
		expVal.StoreSlice(output[i:])
		sumAcc = sumAcc.Add(expVal)
		x1 := asm.LoadFloat64x2Slice(input[i+2:])
		shifted1 := x1.Sub(vMax).Mul(vInvTemp)
		expVal1 := math.BaseExpVec_neon_Float64(shifted1)
		expVal1.StoreSlice(output[i+2:])
		sumAcc = sumAcc.Add(expVal1)
	}
	expSum := sumAcc.ReduceSum()
	for ; i < size; i++ {
		val := float64(stdmath.Exp(float64((input[i] - maxVal) * invTemp)))
		output[i] = val
		expSum += val
	}
	invSum := float64(1.0) / expSum
	vInvSum := asm.BroadcastFloat64x2(invSum)
	i = 0
	for ; i+lanes <= size; i += lanes {
		x := asm.LoadFloat64x2Slice(output[i:])
		result := x.Mul(vInvSum)
		result.StoreSlice(output[i:])
	}
	for ; i < size; i++ {
		output[i] = output[i] * invSum
	}
}
