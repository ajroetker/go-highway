//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package nn

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/nn/asm"
)

func init() {
	initSdpaNeonCAsm()
}

func initSdpaNeonCAsm() {
	if hwy.NoSimdEnv() {
		return
	}
	SDPAFloat32 = sDPAAsmF32
	SDPAFloat64 = sDPAAsmF64
	SDPACausalFloat32 = sDPACausalAsmF32
	SDPACausalFloat64 = sDPACausalAsmF64
	if hwy.HasARMFP16() {
		SDPAFloat16 = sDPAAsmF16
		SDPACausalFloat16 = sDPACausalAsmF16
	}
	if hwy.HasARMBF16() {
		SDPABFloat16 = sDPAAsmBF16
		SDPACausalBFloat16 = sDPACausalAsmBF16
	}
}

func sDPAAsmF16(q, k, v, mask, scores, output []hwy.Float16, seqLen, kvLen, headDim int, scale hwy.Float16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPA_F16(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

func sDPAAsmBF16(q, k, v, mask, scores, output []hwy.BFloat16, seqLen, kvLen, headDim int, scale hwy.BFloat16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPA_BF16(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

func sDPAAsmF32(q, k, v, mask, scores, output []float32, seqLen, kvLen, headDim int, scale float32) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPA_F32(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

func sDPAAsmF64(q, k, v, mask, scores, output []float64, seqLen, kvLen, headDim int, scale float64) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPA_F64(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

func sDPACausalAsmF16(q, k, v, scores, output []hwy.Float16, seqLen, kvLen, headDim int, scale hwy.Float16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPACausal_F16(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

func sDPACausalAsmBF16(q, k, v, scores, output []hwy.BFloat16, seqLen, kvLen, headDim int, scale hwy.BFloat16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPACausal_BF16(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

func sDPACausalAsmF32(q, k, v, scores, output []float32, seqLen, kvLen, headDim int, scale float32) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPACausal_F32(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

func sDPACausalAsmF64(q, k, v, scores, output []float64, seqLen, kvLen, headDim int, scale float64) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	asm.SDPACausal_F64(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

