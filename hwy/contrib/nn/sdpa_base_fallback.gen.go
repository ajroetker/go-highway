// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package nn

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
)

func BaseSDPA_fallback_Float16(q []hwy.Float16, k []hwy.Float16, v []hwy.Float16, mask []hwy.Float16, scores []hwy.Float16, output []hwy.Float16, seqLen int, kvLen int, headDim int, scale hwy.Float16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.Float16]()
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			acc := hwy.Zero[hwy.Float16]()
			p := 0
			for ; p+lanes <= headDim; p += lanes {
				vQ := hwy.Load(q[qOff+p:])
				vK := hwy.Load(k[kOff+p:])
				acc = hwy.MulAdd(vQ, vK, acc)
			}
			sum := hwy.ReduceSum(acc).Float32()
			for ; p < headDim; p++ {
				sum += q[qOff+p].Float32() * k[kOff+p].Float32()
			}
			scores[sOff+j] = hwy.Float32ToFloat16(sum * scale.Float32())
		}
		if mask != nil {
			mOff := i * kvLen
			si := 0
			for ; si+lanes <= kvLen; si += lanes {
				s := hwy.Load(scores[sOff+si:])
				m := hwy.Load(mask[mOff+si:])
				hwy.Store(hwy.Add(s, m), scores[sOff+si:])
			}
			for ; si < kvLen; si++ {
				scores[sOff+si] = hwy.Float32ToFloat16(scores[sOff+si].Float32() + mask[mOff+si].Float32())
			}
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j].Float32() > maxVal.Float32() {
				maxVal = scores[sOff+j]
			}
		}
		vMax := hwy.Set(maxVal)
		sumAcc := hwy.Zero[hwy.Float16]()
		si := 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			shifted := hwy.Sub(x, vMax)
			expVal := math.BaseExpVec_fallback_Float16(shifted)
			hwy.Store(expVal, scores[sOff+si:])
			sumAcc = hwy.Add(sumAcc, expVal)
		}
		expSum := hwy.ReduceSum(sumAcc).Float32()
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(scores[sOff+si].Float32() - maxVal.Float32()))))
			expSum += scores[sOff+si].Float32()
		}
		invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
		vInvSum := hwy.Set(invSum)
		si = 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			hwy.Store(hwy.Mul(x, vInvSum), scores[sOff+si:])
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToFloat16(scores[sOff+si].Float32() * invSum.Float32())
		}
		oOff := i * headDim
		d := 0
		vZero := hwy.Zero[hwy.Float16]()
		for ; d+lanes <= headDim; d += lanes {
			hwy.Store(vZero, output[oOff+d:])
		}
		for ; d < headDim; d++ {
			output[oOff+d] = hwy.Float32ToFloat16(0)
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := hwy.Set(s)
			d = 0
			for ; d+lanes <= headDim; d += lanes {
				vV := hwy.Load(v[vOff+d:])
				vO := hwy.Load(output[oOff+d:])
				hwy.Store(hwy.MulAdd(vS, vV, vO), output[oOff+d:])
			}
			for ; d < headDim; d++ {
				output[oOff+d] = hwy.Float32ToFloat16(output[oOff+d].Float32() + s.Float32()*v[vOff+d].Float32())
			}
		}
	}
}

func BaseSDPA_fallback_BFloat16(q []hwy.BFloat16, k []hwy.BFloat16, v []hwy.BFloat16, mask []hwy.BFloat16, scores []hwy.BFloat16, output []hwy.BFloat16, seqLen int, kvLen int, headDim int, scale hwy.BFloat16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			acc := hwy.Zero[hwy.BFloat16]()
			p := 0
			for ; p+lanes <= headDim; p += lanes {
				vQ := hwy.Load(q[qOff+p:])
				vK := hwy.Load(k[kOff+p:])
				acc = hwy.MulAdd(vQ, vK, acc)
			}
			sum := hwy.ReduceSum(acc).Float32()
			for ; p < headDim; p++ {
				sum += q[qOff+p].Float32() * k[kOff+p].Float32()
			}
			scores[sOff+j] = hwy.Float32ToBFloat16(sum * scale.Float32())
		}
		if mask != nil {
			mOff := i * kvLen
			si := 0
			for ; si+lanes <= kvLen; si += lanes {
				s := hwy.Load(scores[sOff+si:])
				m := hwy.Load(mask[mOff+si:])
				hwy.Store(hwy.Add(s, m), scores[sOff+si:])
			}
			for ; si < kvLen; si++ {
				scores[sOff+si] = hwy.Float32ToBFloat16(scores[sOff+si].Float32() + mask[mOff+si].Float32())
			}
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j].Float32() > maxVal.Float32() {
				maxVal = scores[sOff+j]
			}
		}
		vMax := hwy.Set(maxVal)
		sumAcc := hwy.Zero[hwy.BFloat16]()
		si := 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			shifted := hwy.Sub(x, vMax)
			expVal := math.BaseExpVec_fallback_BFloat16(shifted)
			hwy.Store(expVal, scores[sOff+si:])
			sumAcc = hwy.Add(sumAcc, expVal)
		}
		expSum := hwy.ReduceSum(sumAcc).Float32()
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(scores[sOff+si].Float32() - maxVal.Float32()))))
			expSum += scores[sOff+si].Float32()
		}
		invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
		vInvSum := hwy.Set(invSum)
		si = 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			hwy.Store(hwy.Mul(x, vInvSum), scores[sOff+si:])
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToBFloat16(scores[sOff+si].Float32() * invSum.Float32())
		}
		oOff := i * headDim
		d := 0
		vZero := hwy.Zero[hwy.BFloat16]()
		for ; d+lanes <= headDim; d += lanes {
			hwy.Store(vZero, output[oOff+d:])
		}
		for ; d < headDim; d++ {
			output[oOff+d] = hwy.Float32ToBFloat16(0)
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := hwy.Set(s)
			d = 0
			for ; d+lanes <= headDim; d += lanes {
				vV := hwy.Load(v[vOff+d:])
				vO := hwy.Load(output[oOff+d:])
				hwy.Store(hwy.MulAdd(vS, vV, vO), output[oOff+d:])
			}
			for ; d < headDim; d++ {
				output[oOff+d] = hwy.Float32ToBFloat16(output[oOff+d].Float32() + s.Float32()*v[vOff+d].Float32())
			}
		}
	}
}

func BaseSDPA_fallback(q []float32, k []float32, v []float32, mask []float32, scores []float32, output []float32, seqLen int, kvLen int, headDim int, scale float32) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			acc := float32(0)
			p := 0
			for ; p < headDim; p++ {
				vQ := q[qOff+p]
				vK := k[kOff+p]
				acc = vQ*vK + acc
			}
			sum := acc
			for ; p < headDim; p++ {
				sum += q[qOff+p] * k[kOff+p]
			}
			scores[sOff+j] = sum * scale
		}
		if mask != nil {
			mOff := i * kvLen
			si := 0
			for ; si < kvLen; si++ {
				s := scores[sOff+si]
				m := mask[mOff+si]
				scores[sOff+si] = s + m
			}
			for ; si < kvLen; si++ {
				scores[sOff+si] += mask[mOff+si]
			}
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j] > maxVal {
				maxVal = scores[sOff+j]
			}
		}
		vMax := float32(maxVal)
		sumAcc := float32(0)
		si := 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			shifted := x - vMax
			expVal := float32(stdmath.Exp(float64(shifted)))
			scores[sOff+si] = expVal
			sumAcc = sumAcc + expVal
		}
		expSum := sumAcc
		for ; si < kvLen; si++ {
			scores[sOff+si] = float32(stdmath.Exp(float64(scores[sOff+si] - maxVal)))
			expSum += scores[sOff+si]
		}
		invSum := float32(1.0) / expSum
		vInvSum := float32(invSum)
		si = 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			scores[sOff+si] = x * vInvSum
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = scores[sOff+si] * invSum
		}
		oOff := i * headDim
		d := 0
		vZero := float32(0)
		for ; d < headDim; d++ {
			output[oOff+d] = vZero
		}
		for ; d < headDim; d++ {
			output[oOff+d] = 0
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := float32(s)
			d = 0
			for ; d < headDim; d++ {
				vV := v[vOff+d]
				vO := output[oOff+d]
				output[oOff+d] = vS*vV + vO
			}
			for ; d < headDim; d++ {
				output[oOff+d] += s * v[vOff+d]
			}
		}
	}
}

func BaseSDPA_fallback_Float64(q []float64, k []float64, v []float64, mask []float64, scores []float64, output []float64, seqLen int, kvLen int, headDim int, scale float64) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			acc := float64(0)
			p := 0
			for ; p < headDim; p++ {
				vQ := q[qOff+p]
				vK := k[kOff+p]
				acc = vQ*vK + acc
			}
			sum := acc
			for ; p < headDim; p++ {
				sum += q[qOff+p] * k[kOff+p]
			}
			scores[sOff+j] = sum * scale
		}
		if mask != nil {
			mOff := i * kvLen
			si := 0
			for ; si < kvLen; si++ {
				s := scores[sOff+si]
				m := mask[mOff+si]
				scores[sOff+si] = s + m
			}
			for ; si < kvLen; si++ {
				scores[sOff+si] += mask[mOff+si]
			}
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j] > maxVal {
				maxVal = scores[sOff+j]
			}
		}
		vMax := float64(maxVal)
		sumAcc := float64(0)
		si := 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			shifted := x - vMax
			expVal := float64(stdmath.Exp(float64(shifted)))
			scores[sOff+si] = expVal
			sumAcc = sumAcc + expVal
		}
		expSum := sumAcc
		for ; si < kvLen; si++ {
			scores[sOff+si] = float64(stdmath.Exp(float64(scores[sOff+si] - maxVal)))
			expSum += scores[sOff+si]
		}
		invSum := float64(1.0) / expSum
		vInvSum := float64(invSum)
		si = 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			scores[sOff+si] = x * vInvSum
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = scores[sOff+si] * invSum
		}
		oOff := i * headDim
		d := 0
		vZero := float64(0)
		for ; d < headDim; d++ {
			output[oOff+d] = vZero
		}
		for ; d < headDim; d++ {
			output[oOff+d] = 0
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := float64(s)
			d = 0
			for ; d < headDim; d++ {
				vV := v[vOff+d]
				vO := output[oOff+d]
				output[oOff+d] = vS*vV + vO
			}
			for ; d < headDim; d++ {
				output[oOff+d] += s * v[vOff+d]
			}
		}
	}
}

func BaseSDPACausal_fallback_Float16(q []hwy.Float16, k []hwy.Float16, v []hwy.Float16, scores []hwy.Float16, output []hwy.Float16, seqLen int, kvLen int, headDim int, scale hwy.Float16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.Float16]()
	negInf := hwy.Float32ToFloat16(float32(stdmath.Inf(-1)))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = hwy.Float32ToFloat16(negInf.Float32())
				continue
			}
			kOff := j * headDim
			acc := hwy.Zero[hwy.Float16]()
			p := 0
			for ; p+lanes <= headDim; p += lanes {
				vQ := hwy.Load(q[qOff+p:])
				vK := hwy.Load(k[kOff+p:])
				acc = hwy.MulAdd(vQ, vK, acc)
			}
			sum := hwy.ReduceSum(acc).Float32()
			for ; p < headDim; p++ {
				sum += q[qOff+p].Float32() * k[kOff+p].Float32()
			}
			scores[sOff+j] = hwy.Float32ToFloat16(sum * scale.Float32())
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j].Float32() > maxVal.Float32() {
				maxVal = scores[sOff+j]
			}
		}
		vMax := hwy.Set(maxVal)
		sumAcc := hwy.Zero[hwy.Float16]()
		si := 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			shifted := hwy.Sub(x, vMax)
			expVal := math.BaseExpVec_fallback_Float16(shifted)
			hwy.Store(expVal, scores[sOff+si:])
			sumAcc = hwy.Add(sumAcc, expVal)
		}
		expSum := hwy.ReduceSum(sumAcc).Float32()
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(scores[sOff+si].Float32() - maxVal.Float32()))))
			expSum += scores[sOff+si].Float32()
		}
		invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
		vInvSum := hwy.Set(invSum)
		si = 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			hwy.Store(hwy.Mul(x, vInvSum), scores[sOff+si:])
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToFloat16(scores[sOff+si].Float32() * invSum.Float32())
		}
		oOff := i * headDim
		d := 0
		vZero := hwy.Zero[hwy.Float16]()
		for ; d+lanes <= headDim; d += lanes {
			hwy.Store(vZero, output[oOff+d:])
		}
		for ; d < headDim; d++ {
			output[oOff+d] = hwy.Float32ToFloat16(0)
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := hwy.Set(s)
			d = 0
			for ; d+lanes <= headDim; d += lanes {
				vV := hwy.Load(v[vOff+d:])
				vO := hwy.Load(output[oOff+d:])
				hwy.Store(hwy.MulAdd(vS, vV, vO), output[oOff+d:])
			}
			for ; d < headDim; d++ {
				output[oOff+d] = hwy.Float32ToFloat16(output[oOff+d].Float32() + s.Float32()*v[vOff+d].Float32())
			}
		}
	}
}

func BaseSDPACausal_fallback_BFloat16(q []hwy.BFloat16, k []hwy.BFloat16, v []hwy.BFloat16, scores []hwy.BFloat16, output []hwy.BFloat16, seqLen int, kvLen int, headDim int, scale hwy.BFloat16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	negInf := hwy.Float32ToBFloat16(float32(stdmath.Inf(-1)))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = hwy.Float32ToBFloat16(negInf.Float32())
				continue
			}
			kOff := j * headDim
			acc := hwy.Zero[hwy.BFloat16]()
			p := 0
			for ; p+lanes <= headDim; p += lanes {
				vQ := hwy.Load(q[qOff+p:])
				vK := hwy.Load(k[kOff+p:])
				acc = hwy.MulAdd(vQ, vK, acc)
			}
			sum := hwy.ReduceSum(acc).Float32()
			for ; p < headDim; p++ {
				sum += q[qOff+p].Float32() * k[kOff+p].Float32()
			}
			scores[sOff+j] = hwy.Float32ToBFloat16(sum * scale.Float32())
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j].Float32() > maxVal.Float32() {
				maxVal = scores[sOff+j]
			}
		}
		vMax := hwy.Set(maxVal)
		sumAcc := hwy.Zero[hwy.BFloat16]()
		si := 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			shifted := hwy.Sub(x, vMax)
			expVal := math.BaseExpVec_fallback_BFloat16(shifted)
			hwy.Store(expVal, scores[sOff+si:])
			sumAcc = hwy.Add(sumAcc, expVal)
		}
		expSum := hwy.ReduceSum(sumAcc).Float32()
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(scores[sOff+si].Float32() - maxVal.Float32()))))
			expSum += scores[sOff+si].Float32()
		}
		invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
		vInvSum := hwy.Set(invSum)
		si = 0
		for ; si+lanes <= kvLen; si += lanes {
			x := hwy.Load(scores[sOff+si:])
			hwy.Store(hwy.Mul(x, vInvSum), scores[sOff+si:])
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = hwy.Float32ToBFloat16(scores[sOff+si].Float32() * invSum.Float32())
		}
		oOff := i * headDim
		d := 0
		vZero := hwy.Zero[hwy.BFloat16]()
		for ; d+lanes <= headDim; d += lanes {
			hwy.Store(vZero, output[oOff+d:])
		}
		for ; d < headDim; d++ {
			output[oOff+d] = hwy.Float32ToBFloat16(0)
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := hwy.Set(s)
			d = 0
			for ; d+lanes <= headDim; d += lanes {
				vV := hwy.Load(v[vOff+d:])
				vO := hwy.Load(output[oOff+d:])
				hwy.Store(hwy.MulAdd(vS, vV, vO), output[oOff+d:])
			}
			for ; d < headDim; d++ {
				output[oOff+d] = hwy.Float32ToBFloat16(output[oOff+d].Float32() + s.Float32()*v[vOff+d].Float32())
			}
		}
	}
}

func BaseSDPACausal_fallback(q []float32, k []float32, v []float32, scores []float32, output []float32, seqLen int, kvLen int, headDim int, scale float32) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	negInf := float32(stdmath.Inf(-1))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = negInf
				continue
			}
			kOff := j * headDim
			acc := float32(0)
			p := 0
			for ; p < headDim; p++ {
				vQ := q[qOff+p]
				vK := k[kOff+p]
				acc = vQ*vK + acc
			}
			sum := acc
			for ; p < headDim; p++ {
				sum += q[qOff+p] * k[kOff+p]
			}
			scores[sOff+j] = sum * scale
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j] > maxVal {
				maxVal = scores[sOff+j]
			}
		}
		vMax := float32(maxVal)
		sumAcc := float32(0)
		si := 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			shifted := x - vMax
			expVal := float32(stdmath.Exp(float64(shifted)))
			scores[sOff+si] = expVal
			sumAcc = sumAcc + expVal
		}
		expSum := sumAcc
		for ; si < kvLen; si++ {
			scores[sOff+si] = float32(stdmath.Exp(float64(scores[sOff+si] - maxVal)))
			expSum += scores[sOff+si]
		}
		invSum := float32(1.0) / expSum
		vInvSum := float32(invSum)
		si = 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			scores[sOff+si] = x * vInvSum
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = scores[sOff+si] * invSum
		}
		oOff := i * headDim
		d := 0
		vZero := float32(0)
		for ; d < headDim; d++ {
			output[oOff+d] = vZero
		}
		for ; d < headDim; d++ {
			output[oOff+d] = 0
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := float32(s)
			d = 0
			for ; d < headDim; d++ {
				vV := v[vOff+d]
				vO := output[oOff+d]
				output[oOff+d] = vS*vV + vO
			}
			for ; d < headDim; d++ {
				output[oOff+d] += s * v[vOff+d]
			}
		}
	}
}

func BaseSDPACausal_fallback_Float64(q []float64, k []float64, v []float64, scores []float64, output []float64, seqLen int, kvLen int, headDim int, scale float64) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	negInf := float64(stdmath.Inf(-1))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = negInf
				continue
			}
			kOff := j * headDim
			acc := float64(0)
			p := 0
			for ; p < headDim; p++ {
				vQ := q[qOff+p]
				vK := k[kOff+p]
				acc = vQ*vK + acc
			}
			sum := acc
			for ; p < headDim; p++ {
				sum += q[qOff+p] * k[kOff+p]
			}
			scores[sOff+j] = sum * scale
		}
		maxVal := scores[sOff]
		for j := 1; j < kvLen; j++ {
			if scores[sOff+j] > maxVal {
				maxVal = scores[sOff+j]
			}
		}
		vMax := float64(maxVal)
		sumAcc := float64(0)
		si := 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			shifted := x - vMax
			expVal := float64(stdmath.Exp(float64(shifted)))
			scores[sOff+si] = expVal
			sumAcc = sumAcc + expVal
		}
		expSum := sumAcc
		for ; si < kvLen; si++ {
			scores[sOff+si] = float64(stdmath.Exp(float64(scores[sOff+si] - maxVal)))
			expSum += scores[sOff+si]
		}
		invSum := float64(1.0) / expSum
		vInvSum := float64(invSum)
		si = 0
		for ; si < kvLen; si++ {
			x := scores[sOff+si]
			scores[sOff+si] = x * vInvSum
		}
		for ; si < kvLen; si++ {
			scores[sOff+si] = scores[sOff+si] * invSum
		}
		oOff := i * headDim
		d := 0
		vZero := float64(0)
		for ; d < headDim; d++ {
			output[oOff+d] = vZero
		}
		for ; d < headDim; d++ {
			output[oOff+d] = 0
		}
		for j := range kvLen {
			vOff := j * headDim
			s := scores[sOff+j]
			vS := float64(s)
			d = 0
			for ; d < headDim; d++ {
				vV := v[vOff+d]
				vO := output[oOff+d]
				output[oOff+d] = vS*vV + vO
			}
			for ; d < headDim; d++ {
				output[oOff+d] += s * v[vOff+d]
			}
		}
	}
}
