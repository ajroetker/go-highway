//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// LayerNormCF16 computes LayerNorm using NEON SIMD assembly.
func LayerNormCF16(input, output []hwy.Float16, normSize int, gamma, beta []hwy.Float16, epsilon hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	var p_gamma unsafe.Pointer
	if len(gamma) > 0 {
		p_gamma = unsafe.Pointer(&gamma[0])
	}
	var p_beta unsafe.Pointer
	if len(beta) > 0 {
		p_beta = unsafe.Pointer(&beta[0])
	}
	normSizeVal := int64(normSize)
	epsilonVal := uint16(epsilon)
	len_inputVal := int64(len(input))
	len_outputVal := int64(len(output))
	len_gammaVal := int64(len(gamma))
	len_betaVal := int64(len(beta))
	layernorm_c_f16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&normSizeVal),
		p_gamma,
		p_beta,
		unsafe.Pointer(&epsilonVal),
		unsafe.Pointer(&len_inputVal),
		unsafe.Pointer(&len_outputVal),
		unsafe.Pointer(&len_gammaVal),
		unsafe.Pointer(&len_betaVal),
	)
}

// LayerNormCBF16 computes LayerNorm using NEON SIMD assembly.
func LayerNormCBF16(input, output []hwy.BFloat16, normSize int, gamma, beta []hwy.BFloat16, epsilon hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	var p_gamma unsafe.Pointer
	if len(gamma) > 0 {
		p_gamma = unsafe.Pointer(&gamma[0])
	}
	var p_beta unsafe.Pointer
	if len(beta) > 0 {
		p_beta = unsafe.Pointer(&beta[0])
	}
	normSizeVal := int64(normSize)
	epsilonVal := uint16(epsilon)
	len_inputVal := int64(len(input))
	len_outputVal := int64(len(output))
	len_gammaVal := int64(len(gamma))
	len_betaVal := int64(len(beta))
	layernorm_c_bf16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&normSizeVal),
		p_gamma,
		p_beta,
		unsafe.Pointer(&epsilonVal),
		unsafe.Pointer(&len_inputVal),
		unsafe.Pointer(&len_outputVal),
		unsafe.Pointer(&len_gammaVal),
		unsafe.Pointer(&len_betaVal),
	)
}

// LayerNormCF32 computes LayerNorm using NEON SIMD assembly.
func LayerNormCF32(input, output []float32, normSize int, gamma, beta []float32, epsilon float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	var p_gamma unsafe.Pointer
	if len(gamma) > 0 {
		p_gamma = unsafe.Pointer(&gamma[0])
	}
	var p_beta unsafe.Pointer
	if len(beta) > 0 {
		p_beta = unsafe.Pointer(&beta[0])
	}
	normSizeVal := int64(normSize)
	epsilonVal := epsilon
	len_inputVal := int64(len(input))
	len_outputVal := int64(len(output))
	len_gammaVal := int64(len(gamma))
	len_betaVal := int64(len(beta))
	layernorm_c_f32_neon(
		p_input,
		p_output,
		unsafe.Pointer(&normSizeVal),
		p_gamma,
		p_beta,
		unsafe.Pointer(&epsilonVal),
		unsafe.Pointer(&len_inputVal),
		unsafe.Pointer(&len_outputVal),
		unsafe.Pointer(&len_gammaVal),
		unsafe.Pointer(&len_betaVal),
	)
}

// LayerNormCF64 computes LayerNorm using NEON SIMD assembly.
func LayerNormCF64(input, output []float64, normSize int, gamma, beta []float64, epsilon float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	var p_gamma unsafe.Pointer
	if len(gamma) > 0 {
		p_gamma = unsafe.Pointer(&gamma[0])
	}
	var p_beta unsafe.Pointer
	if len(beta) > 0 {
		p_beta = unsafe.Pointer(&beta[0])
	}
	normSizeVal := int64(normSize)
	epsilonVal := epsilon
	len_inputVal := int64(len(input))
	len_outputVal := int64(len(output))
	len_gammaVal := int64(len(gamma))
	len_betaVal := int64(len(beta))
	layernorm_c_f64_neon(
		p_input,
		p_output,
		unsafe.Pointer(&normSizeVal),
		p_gamma,
		p_beta,
		unsafe.Pointer(&epsilonVal),
		unsafe.Pointer(&len_inputVal),
		unsafe.Pointer(&len_outputVal),
		unsafe.Pointer(&len_gammaVal),
		unsafe.Pointer(&len_betaVal),
	)
}

