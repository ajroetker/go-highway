//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// SDPACF16 computes SDPA using NEON SIMD assembly.
func SDPACF16(q, k, v, mask, scores, output []hwy.Float16, seqLen, kvLen, headDim int, scale hwy.Float16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpa_c_f16_neon(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// SDPACBF16 computes SDPA using NEON SIMD assembly.
func SDPACBF16(q, k, v, mask, scores, output []hwy.BFloat16, seqLen, kvLen, headDim int, scale hwy.BFloat16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpa_c_bf16_neon(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// SDPACF32 computes SDPA using NEON SIMD assembly.
func SDPACF32(q, k, v, mask, scores, output []float32, seqLen, kvLen, headDim int, scale float32) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpa_c_f32_neon(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// SDPACF64 computes SDPA using NEON SIMD assembly.
func SDPACF64(q, k, v, mask, scores, output []float64, seqLen, kvLen, headDim int, scale float64) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_mask unsafe.Pointer
	if len(mask) > 0 {
		p_mask = unsafe.Pointer(&mask[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_maskVal := int64(len(mask))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpa_c_f64_neon(
		p_q,
		p_k,
		p_v,
		p_mask,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_maskVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// SDPACausalCF16 computes SDPACausal using NEON SIMD assembly.
func SDPACausalCF16(q, k, v, scores, output []hwy.Float16, seqLen, kvLen, headDim int, scale hwy.Float16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpacausal_c_f16_neon(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// SDPACausalCBF16 computes SDPACausal using NEON SIMD assembly.
func SDPACausalCBF16(q, k, v, scores, output []hwy.BFloat16, seqLen, kvLen, headDim int, scale hwy.BFloat16) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := uint16(scale)
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpacausal_c_bf16_neon(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// SDPACausalCF32 computes SDPACausal using NEON SIMD assembly.
func SDPACausalCF32(q, k, v, scores, output []float32, seqLen, kvLen, headDim int, scale float32) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpacausal_c_f32_neon(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// SDPACausalCF64 computes SDPACausal using NEON SIMD assembly.
func SDPACausalCF64(q, k, v, scores, output []float64, seqLen, kvLen, headDim int, scale float64) {
	var p_q unsafe.Pointer
	if len(q) > 0 {
		p_q = unsafe.Pointer(&q[0])
	}
	var p_k unsafe.Pointer
	if len(k) > 0 {
		p_k = unsafe.Pointer(&k[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_scores unsafe.Pointer
	if len(scores) > 0 {
		p_scores = unsafe.Pointer(&scores[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	seqLenVal := int64(seqLen)
	kvLenVal := int64(kvLen)
	headDimVal := int64(headDim)
	scaleVal := scale
	len_qVal := int64(len(q))
	len_kVal := int64(len(k))
	len_vVal := int64(len(v))
	len_scoresVal := int64(len(scores))
	len_outputVal := int64(len(output))
	sdpacausal_c_f64_neon(
		p_q,
		p_k,
		p_v,
		p_scores,
		p_output,
		unsafe.Pointer(&seqLenVal),
		unsafe.Pointer(&kvLenVal),
		unsafe.Pointer(&headDimVal),
		unsafe.Pointer(&scaleVal),
		unsafe.Pointer(&len_qVal),
		unsafe.Pointer(&len_kVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_scoresVal),
		unsafe.Pointer(&len_outputVal),
	)
}

