//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// SoftmaxCF16 computes Softmax using NEON SIMD assembly.
func SoftmaxCF16(input, output []hwy.Float16) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	softmax_c_f16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// SoftmaxCBF16 computes Softmax using NEON SIMD assembly.
func SoftmaxCBF16(input, output []hwy.BFloat16) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	softmax_c_bf16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// SoftmaxCF32 computes Softmax using NEON SIMD assembly.
func SoftmaxCF32(input, output []float32) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	softmax_c_f32_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// SoftmaxCF64 computes Softmax using NEON SIMD assembly.
func SoftmaxCF64(input, output []float64) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	softmax_c_f64_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// LogSoftmaxCF16 computes LogSoftmax using NEON SIMD assembly.
func LogSoftmaxCF16(input, output []hwy.Float16) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	logsoftmax_c_f16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// LogSoftmaxCBF16 computes LogSoftmax using NEON SIMD assembly.
func LogSoftmaxCBF16(input, output []hwy.BFloat16) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	logsoftmax_c_bf16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// LogSoftmaxCF32 computes LogSoftmax using NEON SIMD assembly.
func LogSoftmaxCF32(input, output []float32) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	logsoftmax_c_f32_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// LogSoftmaxCF64 computes LogSoftmax using NEON SIMD assembly.
func LogSoftmaxCF64(input, output []float64) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	logsoftmax_c_f64_neon(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

// SoftmaxWithTemperatureCF16 computes SoftmaxWithTemperature using NEON SIMD assembly.
func SoftmaxWithTemperatureCF16(input, output []hwy.Float16, temperature hwy.Float16) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	temperatureVal := uint16(temperature)
	lenVal := int64(len(input))
	softmaxwithtemperature_c_f16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&temperatureVal),
		unsafe.Pointer(&lenVal),
	)
}

// SoftmaxWithTemperatureCBF16 computes SoftmaxWithTemperature using NEON SIMD assembly.
func SoftmaxWithTemperatureCBF16(input, output []hwy.BFloat16, temperature hwy.BFloat16) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	temperatureVal := uint16(temperature)
	lenVal := int64(len(input))
	softmaxwithtemperature_c_bf16_neon(
		p_input,
		p_output,
		unsafe.Pointer(&temperatureVal),
		unsafe.Pointer(&lenVal),
	)
}

// SoftmaxWithTemperatureCF32 computes SoftmaxWithTemperature using NEON SIMD assembly.
func SoftmaxWithTemperatureCF32(input, output []float32, temperature float32) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	temperatureVal := temperature
	lenVal := int64(len(input))
	softmaxwithtemperature_c_f32_neon(
		p_input,
		p_output,
		unsafe.Pointer(&temperatureVal),
		unsafe.Pointer(&lenVal),
	)
}

// SoftmaxWithTemperatureCF64 computes SoftmaxWithTemperature using NEON SIMD assembly.
func SoftmaxWithTemperatureCF64(input, output []float64, temperature float64) {
	if len(input) == 0 {
		return
	}
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	temperatureVal := temperature
	lenVal := int64(len(input))
	softmaxwithtemperature_c_f64_neon(
		p_input,
		p_output,
		unsafe.Pointer(&temperatureVal),
		unsafe.Pointer(&lenVal),
	)
}

