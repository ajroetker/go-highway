//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// MatVecCF16 computes MatVec using NEON SIMD assembly.
func MatVecCF16(m []hwy.Float16, rows, cols int, v, result []hwy.Float16) {
	var p_m unsafe.Pointer
	if len(m) > 0 {
		p_m = unsafe.Pointer(&m[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_result unsafe.Pointer
	if len(result) > 0 {
		p_result = unsafe.Pointer(&result[0])
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	len_mVal := int64(len(m))
	len_vVal := int64(len(v))
	len_resultVal := int64(len(result))
	matvec_c_f16_neon(
		p_m,
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
		p_v,
		p_result,
		unsafe.Pointer(&len_mVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_resultVal),
	)
}

// MatVecCBF16 computes MatVec using NEON SIMD assembly.
func MatVecCBF16(m []hwy.BFloat16, rows, cols int, v, result []hwy.BFloat16) {
	var p_m unsafe.Pointer
	if len(m) > 0 {
		p_m = unsafe.Pointer(&m[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_result unsafe.Pointer
	if len(result) > 0 {
		p_result = unsafe.Pointer(&result[0])
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	len_mVal := int64(len(m))
	len_vVal := int64(len(v))
	len_resultVal := int64(len(result))
	matvec_c_bf16_neon(
		p_m,
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
		p_v,
		p_result,
		unsafe.Pointer(&len_mVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_resultVal),
	)
}

// MatVecCF32 computes MatVec using NEON SIMD assembly.
func MatVecCF32(m []float32, rows, cols int, v, result []float32) {
	var p_m unsafe.Pointer
	if len(m) > 0 {
		p_m = unsafe.Pointer(&m[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_result unsafe.Pointer
	if len(result) > 0 {
		p_result = unsafe.Pointer(&result[0])
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	len_mVal := int64(len(m))
	len_vVal := int64(len(v))
	len_resultVal := int64(len(result))
	matvec_c_f32_neon(
		p_m,
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
		p_v,
		p_result,
		unsafe.Pointer(&len_mVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_resultVal),
	)
}

// MatVecCF64 computes MatVec using NEON SIMD assembly.
func MatVecCF64(m []float64, rows, cols int, v, result []float64) {
	var p_m unsafe.Pointer
	if len(m) > 0 {
		p_m = unsafe.Pointer(&m[0])
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	var p_result unsafe.Pointer
	if len(result) > 0 {
		p_result = unsafe.Pointer(&result[0])
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	len_mVal := int64(len(m))
	len_vVal := int64(len(v))
	len_resultVal := int64(len(result))
	matvec_c_f64_neon(
		p_m,
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
		p_v,
		p_result,
		unsafe.Pointer(&len_mVal),
		unsafe.Pointer(&len_vVal),
		unsafe.Pointer(&len_resultVal),
	)
}

