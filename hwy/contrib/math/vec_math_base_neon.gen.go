// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package math

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

// Hoisted constants - pre-broadcasted at package init time
var (
	BaseCosVec_NEON_intOne_i32_f32   = asm.BroadcastInt32x4(1)
	BaseCosVec_NEON_intOne_i32_f64   = asm.BroadcastInt32x2(1)
	BaseCosVec_NEON_intThree_i32_f32 = asm.BroadcastInt32x4(3)
	BaseCosVec_NEON_intThree_i32_f64 = asm.BroadcastInt32x2(3)
	BaseCosVec_NEON_intTwo_i32_f32   = asm.BroadcastInt32x4(2)
	BaseCosVec_NEON_intTwo_i32_f64   = asm.BroadcastInt32x2(2)
	BaseSinVec_NEON_intOne_i32_f32   = asm.BroadcastInt32x4(1)
	BaseSinVec_NEON_intOne_i32_f64   = asm.BroadcastInt32x2(1)
	BaseSinVec_NEON_intThree_i32_f32 = asm.BroadcastInt32x4(3)
	BaseSinVec_NEON_intThree_i32_f64 = asm.BroadcastInt32x2(3)
	BaseSinVec_NEON_intTwo_i32_f32   = asm.BroadcastInt32x4(2)
	BaseSinVec_NEON_intTwo_i32_f64   = asm.BroadcastInt32x2(2)
)

func BaseExpVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	overflow := asm.BroadcastFloat16x8(uint16(expOverflow_f16))
	underflow := asm.BroadcastFloat16x8(uint16(expUnderflow_f16))
	one := asm.BroadcastFloat16x8(uint16(expOne_f16))
	zero := asm.BroadcastFloat16x8(uint16(expZero_f16))
	inf := asm.BroadcastFloat16x8(uint16(expOverflow_f16 * 2))
	invLn2 := asm.BroadcastFloat16x8(uint16(expInvLn2_f16))
	ln2Hi := asm.BroadcastFloat16x8(uint16(expLn2Hi_f16))
	ln2Lo := asm.BroadcastFloat16x8(uint16(expLn2Lo_f16))
	c1 := asm.BroadcastFloat16x8(uint16(expC1_f16))
	c2 := asm.BroadcastFloat16x8(uint16(expC2_f16))
	c3 := asm.BroadcastFloat16x8(uint16(expC3_f16))
	c4 := asm.BroadcastFloat16x8(uint16(expC4_f16))
	c5 := asm.BroadcastFloat16x8(uint16(expC5_f16))
	c6 := asm.BroadcastFloat16x8(uint16(expC6_f16))
	overflowMask := x.GreaterThan(overflow)
	underflowMask := x.LessThan(underflow)
	kFloat := hwy.RoundToEven(x.Mul(invLn2))
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := hwy.ConvertToInt32(kFloat)
	scale := hwy.Pow2[hwy.Float16](kInt)
	result := p.Mul(scale)
	result = asm.IfThenElseFloat16(overflowMask, inf, result)
	result = asm.IfThenElseFloat16(underflowMask, zero, result)
	return result
}

func BaseExpVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	overflow := asm.BroadcastBFloat16x8(uint16(expOverflow_bf16))
	underflow := asm.BroadcastBFloat16x8(uint16(expUnderflow_bf16))
	one := asm.BroadcastBFloat16x8(uint16(expOne_bf16))
	zero := asm.BroadcastBFloat16x8(uint16(expZero_bf16))
	inf := asm.BroadcastBFloat16x8(uint16(expOverflow_bf16 * 2))
	invLn2 := asm.BroadcastBFloat16x8(uint16(expInvLn2_bf16))
	ln2Hi := asm.BroadcastBFloat16x8(uint16(expLn2Hi_bf16))
	ln2Lo := asm.BroadcastBFloat16x8(uint16(expLn2Lo_bf16))
	c1 := asm.BroadcastBFloat16x8(uint16(expC1_bf16))
	c2 := asm.BroadcastBFloat16x8(uint16(expC2_bf16))
	c3 := asm.BroadcastBFloat16x8(uint16(expC3_bf16))
	c4 := asm.BroadcastBFloat16x8(uint16(expC4_bf16))
	c5 := asm.BroadcastBFloat16x8(uint16(expC5_bf16))
	c6 := asm.BroadcastBFloat16x8(uint16(expC6_bf16))
	overflowMask := x.GreaterThan(overflow)
	underflowMask := x.LessThan(underflow)
	kFloat := hwy.RoundToEven(x.Mul(invLn2))
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := hwy.ConvertToInt32(kFloat)
	scale := hwy.Pow2[hwy.BFloat16](kInt)
	result := p.Mul(scale)
	result = asm.IfThenElseBFloat16(overflowMask, inf, result)
	result = asm.IfThenElseBFloat16(underflowMask, zero, result)
	return result
}

func BaseExpVec_neon(x asm.Float32x4) asm.Float32x4 {
	overflow := asm.BroadcastFloat32x4(expOverflow_f32)
	underflow := asm.BroadcastFloat32x4(expUnderflow_f32)
	one := asm.BroadcastFloat32x4(expOne_f32)
	zero := asm.BroadcastFloat32x4(expZero_f32)
	inf := asm.BroadcastFloat32x4(expOverflow_f32 * 2)
	invLn2 := asm.BroadcastFloat32x4(expInvLn2_f32)
	ln2Hi := asm.BroadcastFloat32x4(expLn2Hi_f32)
	ln2Lo := asm.BroadcastFloat32x4(expLn2Lo_f32)
	c1 := asm.BroadcastFloat32x4(expC1_f32)
	c2 := asm.BroadcastFloat32x4(expC2_f32)
	c3 := asm.BroadcastFloat32x4(expC3_f32)
	c4 := asm.BroadcastFloat32x4(expC4_f32)
	c5 := asm.BroadcastFloat32x4(expC5_f32)
	c6 := asm.BroadcastFloat32x4(expC6_f32)
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := kInt.Pow2Float32()
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseExpVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	overflow := asm.BroadcastFloat64x2(expOverflow_f64)
	underflow := asm.BroadcastFloat64x2(expUnderflow_f64)
	one := asm.BroadcastFloat64x2(expOne_f64)
	zero := asm.BroadcastFloat64x2(expZero_f64)
	inf := asm.BroadcastFloat64x2(expOverflow_f64 * 2)
	invLn2 := asm.BroadcastFloat64x2(expInvLn2_f64)
	ln2Hi := asm.BroadcastFloat64x2(expLn2Hi_f64)
	ln2Lo := asm.BroadcastFloat64x2(expLn2Lo_f64)
	c1 := asm.BroadcastFloat64x2(expC1_f64)
	c2 := asm.BroadcastFloat64x2(expC2_f64)
	c3 := asm.BroadcastFloat64x2(expC3_f64)
	c4 := asm.BroadcastFloat64x2(expC4_f64)
	c5 := asm.BroadcastFloat64x2(expC5_f64)
	c6 := asm.BroadcastFloat64x2(expC6_f64)
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := kInt.Pow2Float64()
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseSigmoidVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	one := asm.BroadcastFloat16x8(uint16(sigmoidOne_f16))
	zero := asm.BroadcastFloat16x8(uint16(sigmoidZero_f16))
	satHi := asm.BroadcastFloat16x8(uint16(sigmoidSatHi_f16))
	satLo := asm.BroadcastFloat16x8(uint16(sigmoidSatLo_f16))
	clampedX := x.Min(satHi).Max(satLo)
	negX := clampedX.Neg()
	expNegX := BaseExpVec_neon_Float16(negX)
	result := one.Div(one.Add(expNegX))
	result = asm.IfThenElseFloat16(x.GreaterThan(satHi), one, result)
	result = asm.IfThenElseFloat16(x.LessThan(satLo), zero, result)
	return result
}

func BaseSigmoidVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	one := asm.BroadcastBFloat16x8(uint16(sigmoidOne_bf16))
	zero := asm.BroadcastBFloat16x8(uint16(sigmoidZero_bf16))
	satHi := asm.BroadcastBFloat16x8(uint16(sigmoidSatHi_bf16))
	satLo := asm.BroadcastBFloat16x8(uint16(sigmoidSatLo_bf16))
	clampedX := x.Min(satHi).Max(satLo)
	negX := clampedX.Neg()
	expNegX := BaseExpVec_neon_BFloat16(negX)
	result := one.Div(one.Add(expNegX))
	result = asm.IfThenElseBFloat16(x.GreaterThan(satHi), one, result)
	result = asm.IfThenElseBFloat16(x.LessThan(satLo), zero, result)
	return result
}

func BaseSigmoidVec_neon(x asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(sigmoidOne_f32)
	zero := asm.BroadcastFloat32x4(sigmoidZero_f32)
	satHi := asm.BroadcastFloat32x4(sigmoidSatHi_f32)
	satLo := asm.BroadcastFloat32x4(sigmoidSatLo_f32)
	clampedX := x.Min(satHi).Max(satLo)
	negX := asm.BroadcastFloat32x4(0).Sub(clampedX)
	expNegX := BaseExpVec_neon(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseSigmoidVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(sigmoidOne_f64)
	zero := asm.BroadcastFloat64x2(sigmoidZero_f64)
	satHi := asm.BroadcastFloat64x2(sigmoidSatHi_f64)
	satLo := asm.BroadcastFloat64x2(sigmoidSatLo_f64)
	clampedX := x.Min(satHi).Max(satLo)
	negX := asm.BroadcastFloat64x2(0).Sub(clampedX)
	expNegX := BaseExpVec_neon_Float64(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseTanhVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	two := hwy.Const[hwy.Float16](2.0)
	one := asm.BroadcastFloat16x8(uint16(tanhOne_f16))
	negOne := asm.BroadcastFloat16x8(uint16(tanhNegOne_f16))
	threshold := asm.BroadcastFloat16x8(uint16(tanhClamp_f16))
	negThreshold := threshold.Neg()
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_neon_Float16(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = asm.IfThenElseFloat16(x.GreaterThan(threshold), one, result)
	result = asm.IfThenElseFloat16(x.LessThan(negThreshold), negOne, result)
	return result
}

func BaseTanhVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	two := hwy.Const[hwy.BFloat16](2.0)
	one := asm.BroadcastBFloat16x8(uint16(tanhOne_bf16))
	negOne := asm.BroadcastBFloat16x8(uint16(tanhNegOne_bf16))
	threshold := asm.BroadcastBFloat16x8(uint16(tanhClamp_bf16))
	negThreshold := threshold.Neg()
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_neon_BFloat16(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = asm.IfThenElseBFloat16(x.GreaterThan(threshold), one, result)
	result = asm.IfThenElseBFloat16(x.LessThan(negThreshold), negOne, result)
	return result
}

func BaseTanhVec_neon(x asm.Float32x4) asm.Float32x4 {
	two := asm.BroadcastFloat32x4(2.0)
	one := asm.BroadcastFloat32x4(tanhOne_f32)
	negOne := asm.BroadcastFloat32x4(tanhNegOne_f32)
	threshold := asm.BroadcastFloat32x4(tanhClamp_f32)
	negThreshold := asm.BroadcastFloat32x4(0).Sub(threshold)
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_neon(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseTanhVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	two := asm.BroadcastFloat64x2(2.0)
	one := asm.BroadcastFloat64x2(tanhOne_f64)
	negOne := asm.BroadcastFloat64x2(tanhNegOne_f64)
	threshold := asm.BroadcastFloat64x2(tanhClamp_f64)
	negThreshold := asm.BroadcastFloat64x2(0).Sub(threshold)
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_neon_Float64(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseLogVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	one := asm.BroadcastFloat16x8(uint16(logOne_f16))
	two := asm.BroadcastFloat16x8(uint16(logTwo_f16))
	zero := hwy.Const[hwy.Float16](0.0)
	ln2Hi := asm.BroadcastFloat16x8(uint16(logLn2Hi_f16))
	ln2Lo := asm.BroadcastFloat16x8(uint16(logLn2Lo_f16))
	negInf := asm.BroadcastFloat16x8(uint16(logNegInf_f16))
	nan := hwy.Const[hwy.Float16](0.0)
	c1 := asm.BroadcastFloat16x8(uint16(logC1_f16))
	c2 := asm.BroadcastFloat16x8(uint16(logC2_f16))
	c3 := asm.BroadcastFloat16x8(uint16(logC3_f16))
	c4 := asm.BroadcastFloat16x8(uint16(logC4_f16))
	c5 := asm.BroadcastFloat16x8(uint16(logC5_f16))
	zeroMask := hwy.EqualF16(x, zero)
	negMask := x.LessThan(zero)
	oneMask := hwy.EqualF16(x, one)
	e := hwy.GetExponent(x)
	m := hwy.GetMantissa(x)
	mLarge := m.GreaterThan(asm.BroadcastFloat16x8(uint16(logSqrt2_f16)))
	mAdjusted := asm.IfThenElseFloat16(mLarge, m.Mul(asm.BroadcastFloat16x8(uint16(logHalf_f16))), m)
	eFloat := hwy.ConvertToF16(e)
	eAdjusted := asm.IfThenElseFloat16(mLarge, eFloat.Add(one), eFloat)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = asm.IfThenElseFloat16(zeroMask, negInf, result)
	result = asm.IfThenElseFloat16(negMask, nan, result)
	result = asm.IfThenElseFloat16(oneMask, zero, result)
	return result
}

func BaseLogVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	one := asm.BroadcastBFloat16x8(uint16(logOne_bf16))
	two := asm.BroadcastBFloat16x8(uint16(logTwo_bf16))
	zero := hwy.Const[hwy.BFloat16](0.0)
	ln2Hi := asm.BroadcastBFloat16x8(uint16(logLn2Hi_bf16))
	ln2Lo := asm.BroadcastBFloat16x8(uint16(logLn2Lo_bf16))
	negInf := asm.BroadcastBFloat16x8(uint16(logNegInf_bf16))
	nan := hwy.Const[hwy.BFloat16](0.0)
	c1 := asm.BroadcastBFloat16x8(uint16(logC1_bf16))
	c2 := asm.BroadcastBFloat16x8(uint16(logC2_bf16))
	c3 := asm.BroadcastBFloat16x8(uint16(logC3_bf16))
	c4 := asm.BroadcastBFloat16x8(uint16(logC4_bf16))
	c5 := asm.BroadcastBFloat16x8(uint16(logC5_bf16))
	zeroMask := hwy.EqualBF16(x, zero)
	negMask := x.LessThan(zero)
	oneMask := hwy.EqualBF16(x, one)
	e := hwy.GetExponent(x)
	m := hwy.GetMantissa(x)
	mLarge := m.GreaterThan(asm.BroadcastBFloat16x8(uint16(logSqrt2_bf16)))
	mAdjusted := asm.IfThenElseBFloat16(mLarge, m.Mul(asm.BroadcastBFloat16x8(uint16(logHalf_bf16))), m)
	eFloat := hwy.ConvertToBF16(e)
	eAdjusted := asm.IfThenElseBFloat16(mLarge, eFloat.Add(one), eFloat)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = asm.IfThenElseBFloat16(zeroMask, negInf, result)
	result = asm.IfThenElseBFloat16(negMask, nan, result)
	result = asm.IfThenElseBFloat16(oneMask, zero, result)
	return result
}

func BaseLogVec_neon(x asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(logOne_f32)
	two := asm.BroadcastFloat32x4(logTwo_f32)
	zero := asm.BroadcastFloat32x4(0.0)
	ln2Hi := asm.BroadcastFloat32x4(logLn2Hi_f32)
	ln2Lo := asm.BroadcastFloat32x4(logLn2Lo_f32)
	negInf := asm.BroadcastFloat32x4(logNegInf_f32)
	nan := asm.BroadcastFloat32x4(0.0)
	c1 := asm.BroadcastFloat32x4(logC1_f32)
	c2 := asm.BroadcastFloat32x4(logC2_f32)
	c3 := asm.BroadcastFloat32x4(logC3_f32)
	c4 := asm.BroadcastFloat32x4(logC4_f32)
	c5 := asm.BroadcastFloat32x4(logC5_f32)
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt32x4().ShiftAllRight(23).And(asm.BroadcastInt32x4(255)).Sub(asm.BroadcastInt32x4(127))
	m := x.AsInt32x4().And(asm.BroadcastInt32x4(8388607)).Or(asm.BroadcastInt32x4(1065353216)).AsFloat32x4()
	mLarge := m.Greater(asm.BroadcastFloat32x4(logSqrt2_f32))
	mAdjusted := m.Mul(asm.BroadcastFloat32x4(logHalf_f32)).Merge(m, mLarge)
	eFloat := e.ConvertToFloat32()
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseLogVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(logOne_f64)
	two := asm.BroadcastFloat64x2(logTwo_f64)
	zero := asm.BroadcastFloat64x2(0.0)
	ln2Hi := asm.BroadcastFloat64x2(logLn2Hi_f64)
	ln2Lo := asm.BroadcastFloat64x2(logLn2Lo_f64)
	negInf := asm.BroadcastFloat64x2(logNegInf_f64)
	nan := asm.BroadcastFloat64x2(0.0)
	c1 := asm.BroadcastFloat64x2(logC1_f64)
	c2 := asm.BroadcastFloat64x2(logC2_f64)
	c3 := asm.BroadcastFloat64x2(logC3_f64)
	c4 := asm.BroadcastFloat64x2(logC4_f64)
	c5 := asm.BroadcastFloat64x2(logC5_f64)
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt64x2().ShiftAllRight(52).And(asm.BroadcastInt64x2(2047)).Sub(asm.BroadcastInt64x2(1023))
	m := x.AsInt64x2().And(asm.BroadcastInt64x2(4503599627370495)).Or(asm.BroadcastInt64x2(4607182418800017408)).AsFloat64x2()
	mLarge := m.Greater(asm.BroadcastFloat64x2(logSqrt2_f64))
	mAdjusted := m.Mul(asm.BroadcastFloat64x2(logHalf_f64)).Merge(m, mLarge)
	eFloat := e.ConvertToFloat64()
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseSinVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	twoOverPi := asm.BroadcastFloat16x8(uint16(trig2OverPi_f16))
	piOver2Hi := asm.BroadcastFloat16x8(uint16(trigPiOver2Hi_f16))
	piOver2Lo := asm.BroadcastFloat16x8(uint16(trigPiOver2Lo_f16))
	one := asm.BroadcastFloat16x8(uint16(trigOne_f16))
	s1 := asm.BroadcastFloat16x8(uint16(trigS1_f16))
	s2 := asm.BroadcastFloat16x8(uint16(trigS2_f16))
	s3 := asm.BroadcastFloat16x8(uint16(trigS3_f16))
	s4 := asm.BroadcastFloat16x8(uint16(trigS4_f16))
	c1 := asm.BroadcastFloat16x8(uint16(trigC1_f16))
	c2 := asm.BroadcastFloat16x8(uint16(trigC2_f16))
	c3 := asm.BroadcastFloat16x8(uint16(trigC3_f16))
	c4 := asm.BroadcastFloat16x8(uint16(trigC4_f16))
	intOne := asm.BroadcastFloat16x8(uint16(1))
	intTwo := asm.BroadcastFloat16x8(uint16(2))
	intThree := asm.BroadcastFloat16x8(uint16(3))
	kFloat := hwy.RoundToEven(x.Mul(twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := hwy.And(kInt, intThree)
	useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
	sinRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		sinR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		cosR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.Float16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
	negResult := result.Neg()
	negResultData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		negResult.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
}

func BaseSinVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	twoOverPi := asm.BroadcastBFloat16x8(uint16(trig2OverPi_bf16))
	piOver2Hi := asm.BroadcastBFloat16x8(uint16(trigPiOver2Hi_bf16))
	piOver2Lo := asm.BroadcastBFloat16x8(uint16(trigPiOver2Lo_bf16))
	one := asm.BroadcastBFloat16x8(uint16(trigOne_bf16))
	s1 := asm.BroadcastBFloat16x8(uint16(trigS1_bf16))
	s2 := asm.BroadcastBFloat16x8(uint16(trigS2_bf16))
	s3 := asm.BroadcastBFloat16x8(uint16(trigS3_bf16))
	s4 := asm.BroadcastBFloat16x8(uint16(trigS4_bf16))
	c1 := asm.BroadcastBFloat16x8(uint16(trigC1_bf16))
	c2 := asm.BroadcastBFloat16x8(uint16(trigC2_bf16))
	c3 := asm.BroadcastBFloat16x8(uint16(trigC3_bf16))
	c4 := asm.BroadcastBFloat16x8(uint16(trigC4_bf16))
	intOne := asm.BroadcastBFloat16x8(uint16(1))
	intTwo := asm.BroadcastBFloat16x8(uint16(2))
	intThree := asm.BroadcastBFloat16x8(uint16(3))
	kFloat := hwy.RoundToEven(x.Mul(twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := hwy.And(kInt, intThree)
	useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
	sinRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		sinR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		cosR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.BFloat16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
	negResult := result.Neg()
	negResultData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		negResult.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadBFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
}

func BaseSinVec_neon(x asm.Float32x4) asm.Float32x4 {
	twoOverPi := asm.BroadcastFloat32x4(trig2OverPi_f32)
	piOver2Hi := asm.BroadcastFloat32x4(trigPiOver2Hi_f32)
	piOver2Lo := asm.BroadcastFloat32x4(trigPiOver2Lo_f32)
	one := asm.BroadcastFloat32x4(trigOne_f32)
	s1 := asm.BroadcastFloat32x4(trigS1_f32)
	s2 := asm.BroadcastFloat32x4(trigS2_f32)
	s3 := asm.BroadcastFloat32x4(trigS3_f32)
	s4 := asm.BroadcastFloat32x4(trigS4_f32)
	c1 := asm.BroadcastFloat32x4(trigC1_f32)
	c2 := asm.BroadcastFloat32x4(trigC2_f32)
	c3 := asm.BroadcastFloat32x4(trigC3_f32)
	c4 := asm.BroadcastFloat32x4(trigC4_f32)
	intOne := BaseSinVec_NEON_intOne_i32_f32
	intTwo := BaseSinVec_NEON_intTwo_i32_f32
	intThree := BaseSinVec_NEON_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []float32 {
		var _simd_tmp [4]float32
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float32 {
		var _simd_tmp [4]float32
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := asm.BroadcastInt32x4(1)
			_vZero := asm.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat32x4Slice(resultData)
	negResult := asm.BroadcastFloat32x4(0).Sub(result)
	negResultData := func() []float32 {
		var _simd_tmp [4]float32
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := asm.BroadcastInt32x4(1)
			_vZero := asm.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat32x4Slice(resultData)
}

func BaseSinVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	twoOverPi := asm.BroadcastFloat64x2(trig2OverPi_f64)
	piOver2Hi := asm.BroadcastFloat64x2(trigPiOver2Hi_f64)
	piOver2Lo := asm.BroadcastFloat64x2(trigPiOver2Lo_f64)
	one := asm.BroadcastFloat64x2(trigOne_f64)
	s1 := asm.BroadcastFloat64x2(trigS1_f64)
	s2 := asm.BroadcastFloat64x2(trigS2_f64)
	s3 := asm.BroadcastFloat64x2(trigS3_f64)
	s4 := asm.BroadcastFloat64x2(trigS4_f64)
	c1 := asm.BroadcastFloat64x2(trigC1_f64)
	c2 := asm.BroadcastFloat64x2(trigC2_f64)
	c3 := asm.BroadcastFloat64x2(trigC3_f64)
	c4 := asm.BroadcastFloat64x2(trigC4_f64)
	intOne := BaseSinVec_NEON_intOne_i32_f64
	intTwo := BaseSinVec_NEON_intTwo_i32_f64
	intThree := BaseSinVec_NEON_intThree_i32_f64
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []float64 {
		var _simd_tmp [2]float64
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float64 {
		var _simd_tmp [2]float64
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := asm.BroadcastInt32x2(1)
			_vZero := asm.BroadcastInt32x2(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [2]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat64x2Slice(resultData)
	negResult := asm.BroadcastFloat64x2(0).Sub(result)
	negResultData := func() []float64 {
		var _simd_tmp [2]float64
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := asm.BroadcastInt32x2(1)
			_vZero := asm.BroadcastInt32x2(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [2]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat64x2Slice(resultData)
}

func BaseCosVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	twoOverPi := asm.BroadcastFloat16x8(uint16(trig2OverPi_f16))
	piOver2Hi := asm.BroadcastFloat16x8(uint16(trigPiOver2Hi_f16))
	piOver2Lo := asm.BroadcastFloat16x8(uint16(trigPiOver2Lo_f16))
	one := asm.BroadcastFloat16x8(uint16(trigOne_f16))
	s1 := asm.BroadcastFloat16x8(uint16(trigS1_f16))
	s2 := asm.BroadcastFloat16x8(uint16(trigS2_f16))
	s3 := asm.BroadcastFloat16x8(uint16(trigS3_f16))
	s4 := asm.BroadcastFloat16x8(uint16(trigS4_f16))
	c1 := asm.BroadcastFloat16x8(uint16(trigC1_f16))
	c2 := asm.BroadcastFloat16x8(uint16(trigC2_f16))
	c3 := asm.BroadcastFloat16x8(uint16(trigC3_f16))
	c4 := asm.BroadcastFloat16x8(uint16(trigC4_f16))
	intOne := asm.BroadcastFloat16x8(uint16(1))
	intTwo := asm.BroadcastFloat16x8(uint16(2))
	intThree := asm.BroadcastFloat16x8(uint16(3))
	kFloat := hwy.RoundToEven(x.Mul(twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
	useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
	sinRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		sinR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		cosR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.Float16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
	negResult := result.Neg()
	negResultData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		negResult.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
}

func BaseCosVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	twoOverPi := asm.BroadcastBFloat16x8(uint16(trig2OverPi_bf16))
	piOver2Hi := asm.BroadcastBFloat16x8(uint16(trigPiOver2Hi_bf16))
	piOver2Lo := asm.BroadcastBFloat16x8(uint16(trigPiOver2Lo_bf16))
	one := asm.BroadcastBFloat16x8(uint16(trigOne_bf16))
	s1 := asm.BroadcastBFloat16x8(uint16(trigS1_bf16))
	s2 := asm.BroadcastBFloat16x8(uint16(trigS2_bf16))
	s3 := asm.BroadcastBFloat16x8(uint16(trigS3_bf16))
	s4 := asm.BroadcastBFloat16x8(uint16(trigS4_bf16))
	c1 := asm.BroadcastBFloat16x8(uint16(trigC1_bf16))
	c2 := asm.BroadcastBFloat16x8(uint16(trigC2_bf16))
	c3 := asm.BroadcastBFloat16x8(uint16(trigC3_bf16))
	c4 := asm.BroadcastBFloat16x8(uint16(trigC4_bf16))
	intOne := asm.BroadcastBFloat16x8(uint16(1))
	intTwo := asm.BroadcastBFloat16x8(uint16(2))
	intThree := asm.BroadcastBFloat16x8(uint16(3))
	kFloat := hwy.RoundToEven(x.Mul(twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
	useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
	sinRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		sinR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		cosR.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.BFloat16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
	negResult := result.Neg()
	negResultData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		negResult.StorePtr(unsafe.Pointer(&_simd_tmp[:][0]))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadBFloat16x8Ptr(unsafe.Pointer(&resultData[0]))
}

func BaseCosVec_neon(x asm.Float32x4) asm.Float32x4 {
	twoOverPi := asm.BroadcastFloat32x4(trig2OverPi_f32)
	piOver2Hi := asm.BroadcastFloat32x4(trigPiOver2Hi_f32)
	piOver2Lo := asm.BroadcastFloat32x4(trigPiOver2Lo_f32)
	one := asm.BroadcastFloat32x4(trigOne_f32)
	s1 := asm.BroadcastFloat32x4(trigS1_f32)
	s2 := asm.BroadcastFloat32x4(trigS2_f32)
	s3 := asm.BroadcastFloat32x4(trigS3_f32)
	s4 := asm.BroadcastFloat32x4(trigS4_f32)
	c1 := asm.BroadcastFloat32x4(trigC1_f32)
	c2 := asm.BroadcastFloat32x4(trigC2_f32)
	c3 := asm.BroadcastFloat32x4(trigC3_f32)
	c4 := asm.BroadcastFloat32x4(trigC4_f32)
	intOne := BaseCosVec_NEON_intOne_i32_f32
	intTwo := BaseCosVec_NEON_intTwo_i32_f32
	intThree := BaseCosVec_NEON_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []float32 {
		var _simd_tmp [4]float32
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float32 {
		var _simd_tmp [4]float32
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := asm.BroadcastInt32x4(1)
			_vZero := asm.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat32x4Slice(resultData)
	negResult := asm.BroadcastFloat32x4(0).Sub(result)
	negResultData := func() []float32 {
		var _simd_tmp [4]float32
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := asm.BroadcastInt32x4(1)
			_vZero := asm.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat32x4Slice(resultData)
}

func BaseCosVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	twoOverPi := asm.BroadcastFloat64x2(trig2OverPi_f64)
	piOver2Hi := asm.BroadcastFloat64x2(trigPiOver2Hi_f64)
	piOver2Lo := asm.BroadcastFloat64x2(trigPiOver2Lo_f64)
	one := asm.BroadcastFloat64x2(trigOne_f64)
	s1 := asm.BroadcastFloat64x2(trigS1_f64)
	s2 := asm.BroadcastFloat64x2(trigS2_f64)
	s3 := asm.BroadcastFloat64x2(trigS3_f64)
	s4 := asm.BroadcastFloat64x2(trigS4_f64)
	c1 := asm.BroadcastFloat64x2(trigC1_f64)
	c2 := asm.BroadcastFloat64x2(trigC2_f64)
	c3 := asm.BroadcastFloat64x2(trigC3_f64)
	c4 := asm.BroadcastFloat64x2(trigC4_f64)
	intOne := BaseCosVec_NEON_intOne_i32_f64
	intTwo := BaseCosVec_NEON_intTwo_i32_f64
	intThree := BaseCosVec_NEON_intThree_i32_f64
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []float64 {
		var _simd_tmp [2]float64
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float64 {
		var _simd_tmp [2]float64
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := asm.BroadcastInt32x2(1)
			_vZero := asm.BroadcastInt32x2(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [2]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat64x2Slice(resultData)
	negResult := asm.BroadcastFloat64x2(0).Sub(result)
	negResultData := func() []float64 {
		var _simd_tmp [2]float64
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := asm.BroadcastInt32x2(1)
			_vZero := asm.BroadcastInt32x2(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [2]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat64x2Slice(resultData)
}

func BaseErfVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	a1 := asm.BroadcastFloat16x8(uint16(erfA1_f16))
	a2 := asm.BroadcastFloat16x8(uint16(erfA2_f16))
	a3 := asm.BroadcastFloat16x8(uint16(erfA3_f16))
	a4 := asm.BroadcastFloat16x8(uint16(erfA4_f16))
	a5 := asm.BroadcastFloat16x8(uint16(erfA5_f16))
	p := asm.BroadcastFloat16x8(uint16(erfP_f16))
	one := asm.BroadcastFloat16x8(uint16(erfOne_f16))
	zero := asm.BroadcastFloat16x8(uint16(erfZero_f16))
	absX := x.Abs()
	signMask := x.LessThan(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := x2.Neg()
	expNegX2 := BaseExpVec_neon_Float16(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := erfAbs.Neg()
	result := asm.IfThenElseFloat16(signMask, negErfAbs, erfAbs)
	return result
}

func BaseErfVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	a1 := asm.BroadcastBFloat16x8(uint16(erfA1_bf16))
	a2 := asm.BroadcastBFloat16x8(uint16(erfA2_bf16))
	a3 := asm.BroadcastBFloat16x8(uint16(erfA3_bf16))
	a4 := asm.BroadcastBFloat16x8(uint16(erfA4_bf16))
	a5 := asm.BroadcastBFloat16x8(uint16(erfA5_bf16))
	p := asm.BroadcastBFloat16x8(uint16(erfP_bf16))
	one := asm.BroadcastBFloat16x8(uint16(erfOne_bf16))
	zero := asm.BroadcastBFloat16x8(uint16(erfZero_bf16))
	absX := x.Abs()
	signMask := x.LessThan(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := x2.Neg()
	expNegX2 := BaseExpVec_neon_BFloat16(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := erfAbs.Neg()
	result := asm.IfThenElseBFloat16(signMask, negErfAbs, erfAbs)
	return result
}

func BaseErfVec_neon(x asm.Float32x4) asm.Float32x4 {
	a1 := asm.BroadcastFloat32x4(erfA1_f32)
	a2 := asm.BroadcastFloat32x4(erfA2_f32)
	a3 := asm.BroadcastFloat32x4(erfA3_f32)
	a4 := asm.BroadcastFloat32x4(erfA4_f32)
	a5 := asm.BroadcastFloat32x4(erfA5_f32)
	p := asm.BroadcastFloat32x4(erfP_f32)
	one := asm.BroadcastFloat32x4(erfOne_f32)
	zero := asm.BroadcastFloat32x4(erfZero_f32)
	absX := x.Abs()
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := asm.BroadcastFloat32x4(0).Sub(x2)
	expNegX2 := BaseExpVec_neon(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := asm.BroadcastFloat32x4(0).Sub(erfAbs)
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseErfVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	a1 := asm.BroadcastFloat64x2(erfA1_f64)
	a2 := asm.BroadcastFloat64x2(erfA2_f64)
	a3 := asm.BroadcastFloat64x2(erfA3_f64)
	a4 := asm.BroadcastFloat64x2(erfA4_f64)
	a5 := asm.BroadcastFloat64x2(erfA5_f64)
	p := asm.BroadcastFloat64x2(erfP_f64)
	one := asm.BroadcastFloat64x2(erfOne_f64)
	zero := asm.BroadcastFloat64x2(erfZero_f64)
	absX := x.Abs()
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := asm.BroadcastFloat64x2(0).Sub(x2)
	expNegX2 := BaseExpVec_neon_Float64(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := asm.BroadcastFloat64x2(0).Sub(erfAbs)
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseLog2Vec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	log2E := asm.BroadcastFloat16x8(uint16(log2E_f16))
	lnX := BaseLogVec_neon_Float16(x)
	return lnX.Mul(log2E)
}

func BaseLog2Vec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	log2E := asm.BroadcastBFloat16x8(uint16(log2E_bf16))
	lnX := BaseLogVec_neon_BFloat16(x)
	return lnX.Mul(log2E)
}

func BaseLog2Vec_neon(x asm.Float32x4) asm.Float32x4 {
	log2E := asm.BroadcastFloat32x4(log2E_f32)
	lnX := BaseLogVec_neon(x)
	return lnX.Mul(log2E)
}

func BaseLog2Vec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	log2E := asm.BroadcastFloat64x2(log2E_f64)
	lnX := BaseLogVec_neon_Float64(x)
	return lnX.Mul(log2E)
}

func BaseLog10Vec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	log10E := asm.BroadcastFloat16x8(uint16(log10E_f16))
	lnX := BaseLogVec_neon_Float16(x)
	return lnX.Mul(log10E)
}

func BaseLog10Vec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	log10E := asm.BroadcastBFloat16x8(uint16(log10E_bf16))
	lnX := BaseLogVec_neon_BFloat16(x)
	return lnX.Mul(log10E)
}

func BaseLog10Vec_neon(x asm.Float32x4) asm.Float32x4 {
	log10E := asm.BroadcastFloat32x4(log10E_f32)
	lnX := BaseLogVec_neon(x)
	return lnX.Mul(log10E)
}

func BaseLog10Vec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	log10E := asm.BroadcastFloat64x2(log10E_f64)
	lnX := BaseLogVec_neon_Float64(x)
	return lnX.Mul(log10E)
}

func BaseExp2Vec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	ln2 := asm.BroadcastFloat16x8(uint16(ln2_f16))
	xLn2 := x.Mul(ln2)
	return BaseExpVec_neon_Float16(xLn2)
}

func BaseExp2Vec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	ln2 := asm.BroadcastBFloat16x8(uint16(ln2_bf16))
	xLn2 := x.Mul(ln2)
	return BaseExpVec_neon_BFloat16(xLn2)
}

func BaseExp2Vec_neon(x asm.Float32x4) asm.Float32x4 {
	ln2 := asm.BroadcastFloat32x4(ln2_f32)
	xLn2 := x.Mul(ln2)
	return BaseExpVec_neon(xLn2)
}

func BaseExp2Vec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	ln2 := asm.BroadcastFloat64x2(ln2_f64)
	xLn2 := x.Mul(ln2)
	return BaseExpVec_neon_Float64(xLn2)
}

func BaseSinhVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	one := asm.BroadcastFloat16x8(uint16(sinhOne_f16))
	c3 := asm.BroadcastFloat16x8(uint16(sinhC3_f16))
	c5 := asm.BroadcastFloat16x8(uint16(sinhC5_f16))
	c7 := asm.BroadcastFloat16x8(uint16(sinhC7_f16))
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseSinhVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	one := asm.BroadcastBFloat16x8(uint16(sinhOne_bf16))
	c3 := asm.BroadcastBFloat16x8(uint16(sinhC3_bf16))
	c5 := asm.BroadcastBFloat16x8(uint16(sinhC5_bf16))
	c7 := asm.BroadcastBFloat16x8(uint16(sinhC7_bf16))
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseSinhVec_neon(x asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(sinhOne_f32)
	c3 := asm.BroadcastFloat32x4(sinhC3_f32)
	c5 := asm.BroadcastFloat32x4(sinhC5_f32)
	c7 := asm.BroadcastFloat32x4(sinhC7_f32)
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseSinhVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(sinhOne_f64)
	c3 := asm.BroadcastFloat64x2(sinhC3_f64)
	c5 := asm.BroadcastFloat64x2(sinhC5_f64)
	c7 := asm.BroadcastFloat64x2(sinhC7_f64)
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseCoshVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	one := hwy.Const[hwy.Float16](1.0)
	c2 := hwy.Const[hwy.Float16](0.5)
	c4 := hwy.Const[hwy.Float16](0.041666666666666664)
	c6 := hwy.Const[hwy.Float16](0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseCoshVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	one := hwy.Const[hwy.BFloat16](1.0)
	c2 := hwy.Const[hwy.BFloat16](0.5)
	c4 := hwy.Const[hwy.BFloat16](0.041666666666666664)
	c6 := hwy.Const[hwy.BFloat16](0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseCoshVec_neon(x asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(1.0)
	c2 := asm.BroadcastFloat32x4(0.5)
	c4 := asm.BroadcastFloat32x4(0.041666666666666664)
	c6 := asm.BroadcastFloat32x4(0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseCoshVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(1.0)
	c2 := asm.BroadcastFloat64x2(0.5)
	c4 := asm.BroadcastFloat64x2(0.041666666666666664)
	c6 := asm.BroadcastFloat64x2(0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseAsinhVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	one := hwy.Const[hwy.Float16](1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_neon_Float16(arg)
}

func BaseAsinhVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	one := hwy.Const[hwy.BFloat16](1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_neon_BFloat16(arg)
}

func BaseAsinhVec_neon(x asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_neon(arg)
}

func BaseAsinhVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_neon_Float64(arg)
}

func BaseAcoshVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	one := hwy.Const[hwy.Float16](1.0)
	zero := hwy.Const[hwy.Float16](0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_neon_Float16(arg)
	oneMask := hwy.EqualF16(x, one)
	result = asm.IfThenElseFloat16(oneMask, zero, result)
	return result
}

func BaseAcoshVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	one := hwy.Const[hwy.BFloat16](1.0)
	zero := hwy.Const[hwy.BFloat16](0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_neon_BFloat16(arg)
	oneMask := hwy.EqualBF16(x, one)
	result = asm.IfThenElseBFloat16(oneMask, zero, result)
	return result
}

func BaseAcoshVec_neon(x asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(1.0)
	zero := asm.BroadcastFloat32x4(0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_neon(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAcoshVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(1.0)
	zero := asm.BroadcastFloat64x2(0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_neon_Float64(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAtanhVec_neon_Float16(x asm.Float16x8) asm.Float16x8 {
	one := hwy.Const[hwy.Float16](1.0)
	half := hwy.Const[hwy.Float16](0.5)
	zero := hwy.Const[hwy.Float16](0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_neon_Float16(ratio)
	result := half.Mul(logRatio)
	zeroMask := hwy.EqualF16(x, zero)
	result = asm.IfThenElseFloat16(zeroMask, zero, result)
	return result
}

func BaseAtanhVec_neon_BFloat16(x asm.BFloat16x8) asm.BFloat16x8 {
	one := hwy.Const[hwy.BFloat16](1.0)
	half := hwy.Const[hwy.BFloat16](0.5)
	zero := hwy.Const[hwy.BFloat16](0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_neon_BFloat16(ratio)
	result := half.Mul(logRatio)
	zeroMask := hwy.EqualBF16(x, zero)
	result = asm.IfThenElseBFloat16(zeroMask, zero, result)
	return result
}

func BaseAtanhVec_neon(x asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(1.0)
	half := asm.BroadcastFloat32x4(0.5)
	zero := asm.BroadcastFloat32x4(0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_neon(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BaseAtanhVec_neon_Float64(x asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(1.0)
	half := asm.BroadcastFloat64x2(0.5)
	zero := asm.BroadcastFloat64x2(0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_neon_Float64(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BasePowVec_neon_Float16(base asm.Float16x8, exp asm.Float16x8) asm.Float16x8 {
	one := hwy.Const[hwy.Float16](1.0)
	zero := hwy.Const[hwy.Float16](0.0)
	logBase := BaseLogVec_neon_Float16(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_neon_Float16(expTimesLog)
	expZeroMask := hwy.EqualF16(exp, zero)
	result = asm.IfThenElseFloat16(expZeroMask, one, result)
	baseOneMask := hwy.EqualF16(base, one)
	result = asm.IfThenElseFloat16(baseOneMask, one, result)
	baseZeroMask := hwy.EqualF16(base, zero)
	expPosMask := exp.GreaterThan(zero)
	baseZeroExpPosMask := hwy.MaskAnd(baseZeroMask, expPosMask)
	result = asm.IfThenElseFloat16(baseZeroExpPosMask, zero, result)
	return result
}

func BasePowVec_neon_BFloat16(base asm.BFloat16x8, exp asm.BFloat16x8) asm.BFloat16x8 {
	one := hwy.Const[hwy.BFloat16](1.0)
	zero := hwy.Const[hwy.BFloat16](0.0)
	logBase := BaseLogVec_neon_BFloat16(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_neon_BFloat16(expTimesLog)
	expZeroMask := hwy.EqualBF16(exp, zero)
	result = asm.IfThenElseBFloat16(expZeroMask, one, result)
	baseOneMask := hwy.EqualBF16(base, one)
	result = asm.IfThenElseBFloat16(baseOneMask, one, result)
	baseZeroMask := hwy.EqualBF16(base, zero)
	expPosMask := exp.GreaterThan(zero)
	baseZeroExpPosMask := hwy.MaskAnd(baseZeroMask, expPosMask)
	result = asm.IfThenElseBFloat16(baseZeroExpPosMask, zero, result)
	return result
}

func BasePowVec_neon(base asm.Float32x4, exp asm.Float32x4) asm.Float32x4 {
	one := asm.BroadcastFloat32x4(1.0)
	zero := asm.BroadcastFloat32x4(0.0)
	logBase := BaseLogVec_neon(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_neon(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.GreaterThan(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}

func BasePowVec_neon_Float64(base asm.Float64x2, exp asm.Float64x2) asm.Float64x2 {
	one := asm.BroadcastFloat64x2(1.0)
	zero := asm.BroadcastFloat64x2(0.0)
	logBase := BaseLogVec_neon_Float64(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_neon_Float64(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.GreaterThan(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}
