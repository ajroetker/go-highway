// Copyright 2025 The Go Highway Authors
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package varint

// Masked-VByte encoding functions. These use standard LEB128/varint format,
// identical to encoding/binary.PutUvarint. The SIMD acceleration is only
// for decoding; encoding is the same as standard varint.
//
// Decode functions are in maskedvbyte_base.go and get SIMD-accelerated
// variants generated by hwygen.

// MaskedVByteEncode32 encodes a single uint32 as standard varint.
// This is identical to encoding/binary.PutUvarint for values that fit in uint32.
// Returns number of bytes written. dst must have at least 5 bytes capacity.
func MaskedVByteEncode32(dst []byte, v uint32) int {
	i := 0
	for v >= 0x80 {
		dst[i] = byte(v) | 0x80
		v >>= 7
		i++
	}
	dst[i] = byte(v)
	return i + 1
}

// MaskedVByteEncode64 encodes a single uint64 as standard varint.
// Returns number of bytes written. dst must have at least 10 bytes capacity.
func MaskedVByteEncode64(dst []byte, v uint64) int {
	i := 0
	for v >= 0x80 {
		dst[i] = byte(v) | 0x80
		v >>= 7
		i++
	}
	dst[i] = byte(v)
	return i + 1
}

// MaskedVByteEncodeBatch32 encodes multiple uint32 values as varints.
// Returns total bytes written. dst must have sufficient capacity
// (use MaskedVByteMaxLen32 to calculate).
func MaskedVByteEncodeBatch32(dst []byte, values []uint32) int {
	pos := 0
	for _, v := range values {
		pos += MaskedVByteEncode32(dst[pos:], v)
	}
	return pos
}

// MaskedVByteEncodeBatch64 encodes multiple uint64 values as varints.
// Returns total bytes written.
func MaskedVByteEncodeBatch64(dst []byte, values []uint64) int {
	pos := 0
	for _, v := range values {
		pos += MaskedVByteEncode64(dst[pos:], v)
	}
	return pos
}

// MaskedVByteMaxLen32 returns maximum encoded bytes for n uint32 values.
// Each uint32 requires at most 5 bytes in varint encoding.
func MaskedVByteMaxLen32(n int) int {
	return n * 5
}

// MaskedVByteMaxLen64 returns maximum encoded bytes for n uint64 values.
// Each uint64 requires at most 10 bytes in varint encoding.
func MaskedVByteMaxLen64(n int) int {
	return n * 10
}

// MaskedVByteEncoder accumulates uint32 values and encodes them as varints.
// This is useful for building varint-encoded buffers incrementally.
type MaskedVByteEncoder struct {
	data []byte
}

// NewMaskedVByteEncoder creates a new encoder with default capacity.
func NewMaskedVByteEncoder() *MaskedVByteEncoder {
	return &MaskedVByteEncoder{
		data: make([]byte, 0, 256),
	}
}

// NewMaskedVByteEncoderWithCapacity creates a new encoder with specified capacity.
func NewMaskedVByteEncoderWithCapacity(cap int) *MaskedVByteEncoder {
	return &MaskedVByteEncoder{
		data: make([]byte, 0, cap),
	}
}

// Add encodes and appends a uint32 value.
func (e *MaskedVByteEncoder) Add(v uint32) {
	// Ensure capacity for worst case (5 bytes)
	if cap(e.data)-len(e.data) < 5 {
		newData := make([]byte, len(e.data), len(e.data)*2+5)
		copy(newData, e.data)
		e.data = newData
	}
	start := len(e.data)
	e.data = e.data[:start+5]
	n := MaskedVByteEncode32(e.data[start:], v)
	e.data = e.data[:start+n]
}

// Add64 encodes and appends a uint64 value.
func (e *MaskedVByteEncoder) Add64(v uint64) {
	if cap(e.data)-len(e.data) < 10 {
		newData := make([]byte, len(e.data), len(e.data)*2+10)
		copy(newData, e.data)
		e.data = newData
	}
	start := len(e.data)
	e.data = e.data[:start+10]
	n := MaskedVByteEncode64(e.data[start:], v)
	e.data = e.data[:start+n]
}

// AddBatch encodes and appends multiple uint32 values.
func (e *MaskedVByteEncoder) AddBatch(values []uint32) {
	for _, v := range values {
		e.Add(v)
	}
}

// Bytes returns the encoded data.
func (e *MaskedVByteEncoder) Bytes() []byte {
	return e.data
}

// Len returns the current encoded length.
func (e *MaskedVByteEncoder) Len() int {
	return len(e.data)
}

// Reset clears the encoder for reuse.
func (e *MaskedVByteEncoder) Reset() {
	e.data = e.data[:0]
}
