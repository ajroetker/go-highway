//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package activation

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/activation/asm"
)

func init() {
	initNeonCAsm()
}

func initNeonCAsm() {
	if hwy.NoSimdEnv() {
		return
	}
	GELUFloat32 = gELUAsmF32
	GELUFloat64 = gELUAsmF64
	GELUApproxFloat32 = gELUApproxAsmF32
	GELUApproxFloat64 = gELUApproxAsmF64
	ReLUFloat32 = reLUAsmF32
	ReLUFloat64 = reLUAsmF64
	SiLUFloat32 = siLUAsmF32
	SiLUFloat64 = siLUAsmF64
	LeakyReLUFloat32 = leakyReLUAsmF32
	LeakyReLUFloat64 = leakyReLUAsmF64
	TanhFloat32 = tanhAsmF32
	TanhFloat64 = tanhAsmF64
	HardSwishFloat32 = hardSwishAsmF32
	HardSwishFloat64 = hardSwishAsmF64
	ELUFloat32 = eLUAsmF32
	ELUFloat64 = eLUAsmF64
	if hwy.HasARMFP16() {
		GELUFloat16 = gELUAsmF16
		GELUApproxFloat16 = gELUApproxAsmF16
		ReLUFloat16 = reLUAsmF16
		SiLUFloat16 = siLUAsmF16
		LeakyReLUFloat16 = leakyReLUAsmF16
		TanhFloat16 = tanhAsmF16
		HardSwishFloat16 = hardSwishAsmF16
		ELUFloat16 = eLUAsmF16
	}
	if hwy.HasARMBF16() {
		GELUBFloat16 = gELUAsmBF16
		GELUApproxBFloat16 = gELUApproxAsmBF16
		ReLUBFloat16 = reLUAsmBF16
		SiLUBFloat16 = siLUAsmBF16
		LeakyReLUBFloat16 = leakyReLUAsmBF16
		TanhBFloat16 = tanhAsmBF16
		HardSwishBFloat16 = hardSwishAsmBF16
		ELUBFloat16 = eLUAsmBF16
	}
}

func gELUAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func leakyReLUAsmF16(input, output []hwy.Float16, alpha hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := uint16(alpha)
	lenVal := int64(len(input))
	asm.LeakyReLU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

func leakyReLUAsmBF16(input, output []hwy.BFloat16, alpha hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := uint16(alpha)
	lenVal := int64(len(input))
	asm.LeakyReLU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

func leakyReLUAsmF32(input, output []float32, alpha float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := alpha
	lenVal := int64(len(input))
	asm.LeakyReLU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

func leakyReLUAsmF64(input, output []float64, alpha float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := alpha
	lenVal := int64(len(input))
	asm.LeakyReLU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func hardSwishAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.HardSwish_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func hardSwishAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.HardSwish_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func hardSwishAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.HardSwish_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func hardSwishAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.HardSwish_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func eLUAsmF16(input, output []hwy.Float16, alpha hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := uint16(alpha)
	lenVal := int64(len(input))
	asm.ELU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

func eLUAsmBF16(input, output []hwy.BFloat16, alpha hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := uint16(alpha)
	lenVal := int64(len(input))
	asm.ELU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

func eLUAsmF32(input, output []float32, alpha float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := alpha
	lenVal := int64(len(input))
	asm.ELU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

func eLUAsmF64(input, output []float64, alpha float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	alphaVal := alpha
	lenVal := int64(len(input))
	asm.ELU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&lenVal),
	)
}

