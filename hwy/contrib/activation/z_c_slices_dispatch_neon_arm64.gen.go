//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package activation

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/activation/asm"
)

func init() {
	initNeonCAsm()
}

func initNeonCAsm() {
	if hwy.NoSimdEnv() || hwy.HasSME() {
		return
	}
	GELUFloat32 = gELUAsmF32
	GELUFloat64 = gELUAsmF64
	GELUApproxFloat32 = gELUApproxAsmF32
	GELUApproxFloat64 = gELUApproxAsmF64
	ReLUFloat32 = reLUAsmF32
	ReLUFloat64 = reLUAsmF64
	SiLUFloat32 = siLUAsmF32
	SiLUFloat64 = siLUAsmF64
	TanhFloat32 = tanhAsmF32
	TanhFloat64 = tanhAsmF64
	if hwy.HasARMFP16() {
		GELUFloat16 = gELUAsmF16
		GELUApproxFloat16 = gELUApproxAsmF16
		ReLUFloat16 = reLUAsmF16
		SiLUFloat16 = siLUAsmF16
		TanhFloat16 = tanhAsmF16
	}
	if hwy.HasARMBF16() {
		GELUBFloat16 = gELUAsmBF16
		GELUApproxBFloat16 = gELUApproxAsmBF16
		ReLUBFloat16 = reLUAsmBF16
		SiLUBFloat16 = siLUAsmBF16
		TanhBFloat16 = tanhAsmBF16
	}
}

func gELUAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func gELUApproxAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.GELUApprox_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func reLUAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.ReLU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func siLUAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.SiLU_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmF16(input, output []hwy.Float16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_F16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmBF16(input, output []hwy.BFloat16) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_BF16(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmF32(input, output []float32) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_F32(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

func tanhAsmF64(input, output []float64) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	lenVal := int64(len(input))
	asm.Tanh_F64(
		p_input,
		p_output,
		unsafe.Pointer(&lenVal),
	)
}

