// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package activation

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
)

func BaseELU_fallback_Float16(input []hwy.Float16, output []hwy.Float16, alpha hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.Float16](actZero_f16)
	vOne := hwy.Set[hwy.Float16](actOne_f16)
	vAlpha := hwy.Set(alpha)
	lanes := hwy.MaxLanes[hwy.Float16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback_Float16(x)
		expM1 := hwy.Sub(expX, vOne)
		negPart := hwy.Mul(vAlpha, expM1)
		isPositive := hwy.Greater(x, vZero)
		result := hwy.Merge(x, negPart, isPositive)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToFloat16(input[i].Float32())
		} else {
			x := float64(input[i].Float32())
			output[i] = hwy.Float32ToFloat16(float32(float64(alpha.Float32()) * (stdmath.Exp(x) - 1.0)))
		}
	}
}

func BaseELU_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.BFloat16](actZero_bf16)
	vOne := hwy.Set[hwy.BFloat16](actOne_bf16)
	vAlpha := hwy.Set(alpha)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback_BFloat16(x)
		expM1 := hwy.Sub(expX, vOne)
		negPart := hwy.Mul(vAlpha, expM1)
		isPositive := hwy.Greater(x, vZero)
		result := hwy.Merge(x, negPart, isPositive)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToBFloat16(input[i].Float32())
		} else {
			x := float64(input[i].Float32())
			output[i] = hwy.Float32ToBFloat16(float32(float64(alpha.Float32()) * (stdmath.Exp(x) - 1.0)))
		}
	}
}

func BaseELU_fallback(input []float32, output []float32, alpha float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Const[float32](actZero_f32)
	vOne := hwy.Const[float32](actOne_f32)
	vAlpha := hwy.Set(alpha)
	lanes := hwy.MaxLanes[float32]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback(x)
		expM1 := hwy.Sub(expX, vOne)
		negPart := hwy.Mul(vAlpha, expM1)
		isPositive := hwy.Greater(x, vZero)
		result := hwy.Merge(x, negPart, isPositive)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			x := float64(input[i])
			output[i] = float32(float64(alpha) * (stdmath.Exp(x) - 1.0))
		}
	}
}

func BaseELU_fallback_Float64(input []float64, output []float64, alpha float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[float64](actZero_f64)
	vOne := hwy.Set[float64](actOne_f64)
	vAlpha := hwy.Set(alpha)
	lanes := hwy.MaxLanes[float64]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback_Float64(x)
		expM1 := hwy.Sub(expX, vOne)
		negPart := hwy.Mul(vAlpha, expM1)
		isPositive := hwy.Greater(x, vZero)
		result := hwy.Merge(x, negPart, isPositive)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			x := float64(input[i])
			output[i] = float64(float64(alpha) * (stdmath.Exp(x) - 1.0))
		}
	}
}

func BaseGELU_fallback_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := hwy.Set[hwy.Float16](actHalf_f16)
	vOne := hwy.Set[hwy.Float16](actOne_f16)
	vInvSqrt2 := hwy.Set[hwy.Float16](actInvSqrt2_f16)
	lanes := vOne.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.Mul(x, vInvSqrt2)
		erfX := math.BaseErfVec_fallback_Float16(xScaled)
		onePlusErf := hwy.Add(vOne, erfX)
		halfOnePlusErf := hwy.Mul(vHalf, onePlusErf)
		result := hwy.Mul(x, halfOnePlusErf)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		output[i] = hwy.Float32ToFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
	}
}

func BaseGELU_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := hwy.Set[hwy.BFloat16](actHalf_bf16)
	vOne := hwy.Set[hwy.BFloat16](actOne_bf16)
	vInvSqrt2 := hwy.Set[hwy.BFloat16](actInvSqrt2_bf16)
	lanes := vOne.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.Mul(x, vInvSqrt2)
		erfX := math.BaseErfVec_fallback_BFloat16(xScaled)
		onePlusErf := hwy.Add(vOne, erfX)
		halfOnePlusErf := hwy.Mul(vHalf, onePlusErf)
		result := hwy.Mul(x, halfOnePlusErf)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		output[i] = hwy.Float32ToBFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
	}
}

func BaseGELU_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := float32(actHalf_f32)
	vOne := float32(actOne_f32)
	vInvSqrt2 := float32(actInvSqrt2_f32)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		xScaled := x * vInvSqrt2
		erfX := float32(stdmath.Erf(float64(xScaled)))
		onePlusErf := vOne + erfX
		halfOnePlusErf := vHalf * onePlusErf
		result := x * halfOnePlusErf
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		output[i] = float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
	}
}

func BaseGELU_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := float64(actHalf_f64)
	vOne := float64(actOne_f64)
	vInvSqrt2 := float64(actInvSqrt2_f64)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		xScaled := x * vInvSqrt2
		erfX := float64(stdmath.Erf(float64(xScaled)))
		onePlusErf := vOne + erfX
		halfOnePlusErf := vHalf * onePlusErf
		result := x * halfOnePlusErf
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		output[i] = float64(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
	}
}

func BaseGELUApprox_fallback_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := hwy.Set[hwy.Float16](actGeluApproxCoeff_f16)
	lanes := vCoeff.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.Mul(x, vCoeff)
		sigmoidX := math.BaseSigmoidVec_fallback_Float16(xScaled)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = hwy.Float32ToFloat16(float32(x * sigmoid))
	}
}

func BaseGELUApprox_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := hwy.Set[hwy.BFloat16](actGeluApproxCoeff_bf16)
	lanes := vCoeff.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.Mul(x, vCoeff)
		sigmoidX := math.BaseSigmoidVec_fallback_BFloat16(xScaled)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = hwy.Float32ToBFloat16(float32(x * sigmoid))
	}
}

func BaseGELUApprox_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := hwy.Const[float32](actGeluApproxCoeff_f32)
	lanes := vCoeff.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.Mul(x, vCoeff)
		sigmoidX := math.BaseSigmoidVec_fallback(xScaled)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = float32(x * sigmoid)
	}
}

func BaseGELUApprox_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := hwy.Set[float64](actGeluApproxCoeff_f64)
	lanes := vCoeff.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.Mul(x, vCoeff)
		sigmoidX := math.BaseSigmoidVec_fallback_Float64(xScaled)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = float64(x * sigmoid)
	}
}

func BaseHardSwish_fallback_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.Float16](actZero_f16)
	vOne := hwy.Set[hwy.Float16](actOne_f16)
	vScale := hwy.Set[hwy.Float16](actHardSwishScale_f16)
	vBias := hwy.Set[hwy.Float16](actHalf_f16)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		s := hwy.Add(hwy.Mul(x, vScale), vBias)
		s = hwy.Max(s, vZero)
		s = hwy.Min(s, vOne)
		result := hwy.Mul(x, s)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		s := x/6.0 + 0.5
		if s < 0 {
			s = 0
		} else if s > 1 {
			s = 1
		}
		output[i] = hwy.Float32ToFloat16(float32(x * s))
	}
}

func BaseHardSwish_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.BFloat16](actZero_bf16)
	vOne := hwy.Set[hwy.BFloat16](actOne_bf16)
	vScale := hwy.Set[hwy.BFloat16](actHardSwishScale_bf16)
	vBias := hwy.Set[hwy.BFloat16](actHalf_bf16)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		s := hwy.Add(hwy.Mul(x, vScale), vBias)
		s = hwy.Max(s, vZero)
		s = hwy.Min(s, vOne)
		result := hwy.Mul(x, s)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		s := x/6.0 + 0.5
		if s < 0 {
			s = 0
		} else if s > 1 {
			s = 1
		}
		output[i] = hwy.Float32ToBFloat16(float32(x * s))
	}
}

func BaseHardSwish_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := float32(actZero_f32)
	vOne := float32(actOne_f32)
	vScale := float32(actHardSwishScale_f32)
	vBias := float32(actHalf_f32)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		s := x*vScale + vBias
		s = max(s, vZero)
		s = min(s, vOne)
		result := x * s
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		s := x/6.0 + 0.5
		if s < 0 {
			s = 0
		} else if s > 1 {
			s = 1
		}
		output[i] = float32(x * s)
	}
}

func BaseHardSwish_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := float64(actZero_f64)
	vOne := float64(actOne_f64)
	vScale := float64(actHardSwishScale_f64)
	vBias := float64(actHalf_f64)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		s := x*vScale + vBias
		s = max(s, vZero)
		s = min(s, vOne)
		result := x * s
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		s := x/6.0 + 0.5
		if s < 0 {
			s = 0
		} else if s > 1 {
			s = 1
		}
		output[i] = float64(x * s)
	}
}

func BaseLeakyReLU_fallback_Float16(input []hwy.Float16, output []hwy.Float16, alpha hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := hwy.Set(alpha)
	lanes := hwy.MaxLanes[hwy.Float16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		negPart := hwy.Mul(x, vAlpha)
		result := hwy.Max(x, negPart)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToFloat16(alpha.Float32() * input[i].Float32())
		}
	}
}

func BaseLeakyReLU_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := hwy.Set(alpha)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		negPart := hwy.Mul(x, vAlpha)
		result := hwy.Max(x, negPart)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToBFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToBFloat16(alpha.Float32() * input[i].Float32())
		}
	}
}

func BaseLeakyReLU_fallback(input []float32, output []float32, alpha float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := float32(alpha)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		negPart := x * vAlpha
		result := max(x, negPart)
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = alpha * input[i]
		}
	}
}

func BaseLeakyReLU_fallback_Float64(input []float64, output []float64, alpha float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := float64(alpha)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		negPart := x * vAlpha
		result := max(x, negPart)
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = alpha * input[i]
		}
	}
}

func BaseReLU_fallback_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.Float16](actZero_f16)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		result := hwy.Max(x, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToFloat16(0)
		}
	}
}

func BaseReLU_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.BFloat16](actZero_bf16)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		result := hwy.Max(x, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToBFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToBFloat16(0)
		}
	}
}

func BaseReLU_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := float32(actZero_f32)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		result := max(x, vZero)
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = 0
		}
	}
}

func BaseReLU_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := float64(actZero_f64)
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		result := max(x, vZero)
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = 0
		}
	}
}

func BaseSiLU_fallback_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.Float16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		sigmoidX := math.BaseSigmoidVec_fallback_Float16(x)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = hwy.Float32ToFloat16(float32(x * sigmoid))
	}
}

func BaseSiLU_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		sigmoidX := math.BaseSigmoidVec_fallback_BFloat16(x)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = hwy.Float32ToBFloat16(float32(x * sigmoid))
	}
}

func BaseSiLU_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := hwy.MaxLanes[float32]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		sigmoidX := math.BaseSigmoidVec_fallback(x)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = float32(x * sigmoid)
	}
}

func BaseSiLU_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := hwy.MaxLanes[float64]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		sigmoidX := math.BaseSigmoidVec_fallback_Float64(x)
		result := hwy.Mul(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = float64(x * sigmoid)
	}
}

func BaseSoftplus_fallback_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.Float16](actZero_f16)
	vOne := hwy.Set[hwy.Float16](actOne_f16)
	vThreshold := hwy.Set[hwy.Float16](actSoftplusThreshold_f16)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback_Float16(x)
		log1pExpX := math.BaseLogVec_fallback_Float16(hwy.Add(vOne, expX))
		isLarge := hwy.Greater(x, vThreshold)
		result := hwy.Merge(x, log1pExpX, isLarge)
		result = hwy.Max(result, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		if x > 20.0 {
			output[i] = hwy.Float32ToFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToFloat16(float32(stdmath.Log(1.0 + stdmath.Exp(x))))
		}
	}
}

func BaseSoftplus_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[hwy.BFloat16](actZero_bf16)
	vOne := hwy.Set[hwy.BFloat16](actOne_bf16)
	vThreshold := hwy.Set[hwy.BFloat16](actSoftplusThreshold_bf16)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback_BFloat16(x)
		log1pExpX := math.BaseLogVec_fallback_BFloat16(hwy.Add(vOne, expX))
		isLarge := hwy.Greater(x, vThreshold)
		result := hwy.Merge(x, log1pExpX, isLarge)
		result = hwy.Max(result, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		if x > 20.0 {
			output[i] = hwy.Float32ToBFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToBFloat16(float32(stdmath.Log(1.0 + stdmath.Exp(x))))
		}
	}
}

func BaseSoftplus_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Const[float32](actZero_f32)
	vOne := hwy.Const[float32](actOne_f32)
	vThreshold := hwy.Const[float32](actSoftplusThreshold_f32)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback(x)
		log1pExpX := math.BaseLogVec_fallback(hwy.Add(vOne, expX))
		isLarge := hwy.Greater(x, vThreshold)
		result := hwy.Merge(x, log1pExpX, isLarge)
		result = hwy.Max(result, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		if x > 20.0 {
			output[i] = input[i]
		} else {
			output[i] = float32(stdmath.Log(1.0 + stdmath.Exp(x)))
		}
	}
}

func BaseSoftplus_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Set[float64](actZero_f64)
	vOne := hwy.Set[float64](actOne_f64)
	vThreshold := hwy.Set[float64](actSoftplusThreshold_f64)
	lanes := vZero.NumLanes()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_fallback_Float64(x)
		log1pExpX := math.BaseLogVec_fallback_Float64(hwy.Add(vOne, expX))
		isLarge := hwy.Greater(x, vThreshold)
		result := hwy.Merge(x, log1pExpX, isLarge)
		result = hwy.Max(result, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		if x > 20.0 {
			output[i] = input[i]
		} else {
			output[i] = float64(stdmath.Log(1.0 + stdmath.Exp(x)))
		}
	}
}

func BaseTanh_fallback_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.Float16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		result := math.BaseTanhVec_fallback_Float16(x)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		output[i] = hwy.Float32ToFloat16(float32(stdmath.Tanh(x)))
	}
}

func BaseTanh_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		result := math.BaseTanhVec_fallback_BFloat16(x)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		output[i] = hwy.Float32ToBFloat16(float32(stdmath.Tanh(x)))
	}
}

func BaseTanh_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		result := float32(stdmath.Tanh(float64(x)))
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		output[i] = float32(stdmath.Tanh(x))
	}
}

func BaseTanh_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	ii := 0
	for ; ii < size; ii++ {
		x := input[ii]
		result := float64(stdmath.Tanh(float64(x)))
		output[ii] = result
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		output[i] = float64(stdmath.Tanh(x))
	}
}
