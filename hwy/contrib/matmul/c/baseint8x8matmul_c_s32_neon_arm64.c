// Generated by hwygen -c (AST translator). DO NOT EDIT.
// BaseInt8x8MatMul for NEON int32

#ifndef GOAT_PARSER
#include <arm_neon.h>
#endif

void int8x8matmul_c_s32_neon(int *output, unsigned char *a, unsigned char *b, long *paZP, long *pbZP, long *pM, long *pK, long *pN) {
    long K = *pK;
    long M = *pM;
    long N = *pN;
    long aZP = *paZP;
    long bZP = *pbZP;
    if (M == 0 || K == 0 || N == 0) {
        return;
    }
    long lanes = 4;
    int dequantBuf[lanes];
    int accBuf[N];
    int azp = (int)(aZP);
    int bzp = (int)(bZP);
    #pragma clang loop vectorize(disable) interleave(disable)
    for (long m = 0; m < M; m++) {
        #pragma clang loop vectorize(disable) interleave(disable)
        for (long i = 0; i < N; i++) {
            accBuf[i] = 0;
        }
        #pragma clang loop vectorize(disable) interleave(disable)
        for (long k = 0; k < K; k++) {
            int aVal = (int)(a[m * K + k]) - azp;
            int32x4_t aVec = vdupq_n_s32(aVal);
            long baseIdx = k * N;
            long n = 0;
            #pragma clang loop vectorize(disable) interleave(disable)
            for (n = 0; n + lanes <= N; n += lanes) {
                #pragma clang loop vectorize(disable) interleave(disable)
                for (long lane = 0; lane < lanes; lane++) {
                    dequantBuf[lane] = (int)(b[baseIdx + n + lane]) - bzp;
                }
                int32x4_t bVec = vld1q_s32(dequantBuf);
                int32x4_t acc = vld1q_s32(accBuf + n);
                acc = vaddq_s32(vmulq_s32(aVec, bVec), acc);
                vst1q_s32(accBuf + n, acc);
            }
            #pragma clang loop vectorize(disable) interleave(disable)
            for (; n < N; n++) {
                accBuf[n] += aVal * ((int)(b[baseIdx + n]) - bzp);
            }
        }
        for (long _ci = 0; _ci < ((m + 1) * N) - (m * N); _ci++) { (output + m * N)[_ci] = accBuf[_ci]; }
    }
}
