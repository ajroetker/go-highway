// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseApplyPackedOutput_avx512_Float16(packedOutput []hwy.Float16, output []hwy.Float16, alpha hwy.Float16, beta hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	alphaVec := asm.BroadcastFloat16x16AVX512(uint16(alpha))
	betaVec := asm.BroadcastFloat16x16AVX512(uint16(beta))
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&packedOutput[packedIdx+c:][0]))
			outputVal := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&output[outputIdx+c:][0]))
			scaledOutput := outputVal.Mul(betaVec)
			newVal := packedVal.MulAdd(alphaVec, scaledOutput)
			newVal.StorePtr(unsafe.Pointer(&output[outputIdx+c:][0]))
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = hwy.Float32ToFloat16(beta.Float32()*output[outputIdx+c].Float32() + alpha.Float32()*val.Float32())
		}
	}
}

func BaseApplyPackedOutput_avx512_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16, beta hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	alphaVec := asm.BroadcastBFloat16x16AVX512(uint16(alpha))
	betaVec := asm.BroadcastBFloat16x16AVX512(uint16(beta))
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&packedOutput[packedIdx+c:][0]))
			outputVal := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&output[outputIdx+c:][0]))
			scaledOutput := outputVal.Mul(betaVec)
			newVal := packedVal.MulAdd(alphaVec, scaledOutput)
			newVal.StorePtr(unsafe.Pointer(&output[outputIdx+c:][0]))
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = hwy.Float32ToBFloat16(beta.Float32()*output[outputIdx+c].Float32() + alpha.Float32()*val.Float32())
		}
	}
}

func BaseApplyPackedOutput_avx512(packedOutput []float32, output []float32, alpha float32, beta float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	alphaVec := archsimd.BroadcastFloat32x16(alpha)
	betaVec := archsimd.BroadcastFloat32x16(beta)
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&packedOutput[packedIdx+c])))
			outputVal := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&output[outputIdx+c])))
			scaledOutput := outputVal.Mul(betaVec)
			newVal := packedVal.MulAdd(alphaVec, scaledOutput)
			newVal.Store((*[16]float32)(unsafe.Pointer(&output[outputIdx+c])))
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = beta*output[outputIdx+c] + alpha*val
		}
	}
}

func BaseApplyPackedOutput_avx512_Float64(packedOutput []float64, output []float64, alpha float64, beta float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 8
	alphaVec := archsimd.BroadcastFloat64x8(alpha)
	betaVec := archsimd.BroadcastFloat64x8(beta)
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&packedOutput[packedIdx+c])))
			outputVal := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&output[outputIdx+c])))
			scaledOutput := outputVal.Mul(betaVec)
			newVal := packedVal.MulAdd(alphaVec, scaledOutput)
			newVal.Store((*[8]float64)(unsafe.Pointer(&output[outputIdx+c])))
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = beta*output[outputIdx+c] + alpha*val
		}
	}
}

func BaseApplyPackedOutputSimple_avx512_Float16(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&packedOutput[packedIdx+c:][0]))
			v.StorePtr(unsafe.Pointer(&output[outputIdx+c:][0]))
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToFloat16(packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputSimple_avx512_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&packedOutput[packedIdx+c:][0]))
			v.StorePtr(unsafe.Pointer(&output[outputIdx+c:][0]))
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToBFloat16(packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputSimple_avx512(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&packedOutput[packedIdx+c])))
			v.Store((*[16]float32)(unsafe.Pointer(&output[outputIdx+c])))
		}
		for ; c < width; c++ {
			output[outputIdx+c] = packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputSimple_avx512_Float64(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 8
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&packedOutput[packedIdx+c])))
			v.Store((*[8]float64)(unsafe.Pointer(&output[outputIdx+c])))
		}
		for ; c < width; c++ {
			output[outputIdx+c] = packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputAccum_avx512_Float16(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&packedOutput[packedIdx+c:][0]))
			outputVal := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&output[outputIdx+c:][0]))
			newVal := outputVal.Add(packedVal)
			newVal.StorePtr(unsafe.Pointer(&output[outputIdx+c:][0]))
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToFloat16(output[outputIdx+c].Float32() + packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputAccum_avx512_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&packedOutput[packedIdx+c:][0]))
			outputVal := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&output[outputIdx+c:][0]))
			newVal := outputVal.Add(packedVal)
			newVal.StorePtr(unsafe.Pointer(&output[outputIdx+c:][0]))
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToBFloat16(output[outputIdx+c].Float32() + packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputAccum_avx512(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&packedOutput[packedIdx+c])))
			outputVal := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&output[outputIdx+c])))
			newVal := outputVal.Add(packedVal)
			newVal.Store((*[16]float32)(unsafe.Pointer(&output[outputIdx+c])))
		}
		for ; c < width; c++ {
			output[outputIdx+c] += packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputAccum_avx512_Float64(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 8
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&packedOutput[packedIdx+c])))
			outputVal := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&output[outputIdx+c])))
			newVal := outputVal.Add(packedVal)
			newVal.Store((*[8]float64)(unsafe.Pointer(&output[outputIdx+c])))
		}
		for ; c < width; c++ {
			output[outputIdx+c] += packedOutput[packedIdx+c]
		}
	}
}
