// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package matmul

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseFusedInt8MatMul_neon(input []float32, weights []int8, scales []float32, bias []float32, output []float32, M int, K int, N int, groupSize int) {
	if M == 0 || K == 0 || N == 0 {
		return
	}
	numGroups := (N + groupSize - 1) / groupSize
	lanes := 4
	tileN := 4 * lanes
	dequantBuf := make([]float32, tileN)
	accBuf := make([]float32, N)
	for m := range M {
		inputRow := input[m*K : (m+1)*K]
		outputRow := output[m*N : (m+1)*N]
		for i := range N {
			accBuf[i] = 0
		}
		for k := range K {
			inputVal := asm.BroadcastFloat32x4(inputRow[k])
			baseIdx := k * N
			scaleBase := k * numGroups
			var n int
			for n = 0; n+tileN <= N; n += tileN {
				for lane := range tileN {
					colIdx := n + lane
					weightIdx := baseIdx + colIdx
					val := float32(weights[weightIdx])
					groupIdx := colIdx / groupSize
					scale := scales[scaleBase+groupIdx]
					dequantBuf[lane] = val * scale
				}
				w0 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&dequantBuf[0])))
				w1 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&dequantBuf[lanes])))
				w2 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&dequantBuf[2*lanes])))
				w3 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&dequantBuf[3*lanes])))
				acc0 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&accBuf[n])))
				acc1 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&accBuf[n+lanes])))
				acc2 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&accBuf[n+2*lanes])))
				acc3 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&accBuf[n+3*lanes])))
				inputVal.MulAddAcc(w0, &acc0)
				inputVal.MulAddAcc(w1, &acc1)
				inputVal.MulAddAcc(w2, &acc2)
				inputVal.MulAddAcc(w3, &acc3)
				acc0.Store((*[4]float32)(unsafe.Pointer(&accBuf[n])))
				acc1.Store((*[4]float32)(unsafe.Pointer(&accBuf[n+lanes])))
				acc2.Store((*[4]float32)(unsafe.Pointer(&accBuf[n+2*lanes])))
				acc3.Store((*[4]float32)(unsafe.Pointer(&accBuf[n+3*lanes])))
			}
			for ; n+lanes <= N; n += lanes {
				for lane := range lanes {
					colIdx := n + lane
					weightIdx := baseIdx + colIdx
					val := float32(weights[weightIdx])
					groupIdx := colIdx / groupSize
					scale := scales[scaleBase+groupIdx]
					dequantBuf[lane] = val * scale
				}
				dequantWeights := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&dequantBuf[0])))
				acc := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&accBuf[n])))
				inputVal.MulAddAcc(dequantWeights, &acc)
				acc.Store((*[4]float32)(unsafe.Pointer(&accBuf[n])))
			}
			for ; n < N; n++ {
				weightIdx := baseIdx + n
				val := float32(weights[weightIdx])
				groupIdx := n / groupSize
				scale := scales[scaleBase+groupIdx]
				accBuf[n] += inputRow[k] * val * scale
			}
		}
		var n int
		for n = 0; n+lanes <= N; n += lanes {
			acc := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&accBuf[n])))
			if bias != nil {
				biasVec := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&bias[n])))
				acc = acc.Add(biasVec)
			}
			acc.Store((*[4]float32)(unsafe.Pointer(&outputRow[n])))
		}
		for ; n < N; n++ {
			val := accBuf[n]
			if bias != nil {
				val += bias[n]
			}
			outputRow[n] = val
		}
	}
}
