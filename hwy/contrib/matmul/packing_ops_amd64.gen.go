// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"

	"github.com/ajroetker/go-highway/hwy"
)

var ApplyPackedOutputFloat16 func(packedOutput []hwy.Float16, output []hwy.Float16, alpha hwy.Float16, beta hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputBFloat16 func(packedOutput []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16, beta hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputFloat32 func(packedOutput []float32, output []float32, alpha float32, beta float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputFloat64 func(packedOutput []float64, output []float64, alpha float64, beta float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleFloat16 func(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleBFloat16 func(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleFloat32 func(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleFloat64 func(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumFloat16 func(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumBFloat16 func(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumFloat32 func(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumFloat64 func(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)

// ApplyPackedOutput applies the computed packed output to the final output matrix.
//
// This function transfers results from a temporary packed output buffer to the
// actual output matrix, applying alpha and beta scaling:
//
//	output = alpha * packedOutput + beta * output
//
// Using a packed output buffer allows the micro-kernel to write contiguously
// without bounds checking, improving performance. The alpha/beta application
// is then done efficiently with SIMD in this separate pass.
//
// Parameters:
//   - packedOutput: Temporary buffer with computed results [height, packedStride]
//   - output: Final output matrix in row-major order
//   - alpha, beta: Scaling factors (output = alpha*packed + beta*output)
//   - packedStride: Row stride in packedOutput (typically params.Nc)
//   - outputRowOffset: Starting row in output matrix
//   - outputColOffset: Starting column in output matrix
//   - outputStride: Row stride in output matrix (N dimension)
//   - height: Number of rows to apply
//   - width: Number of columns to apply
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ApplyPackedOutput[T hwy.Floats](packedOutput []T, output []T, alpha T, beta T, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	switch any(packedOutput).(type) {
	case []hwy.Float16:
		ApplyPackedOutputFloat16(any(packedOutput).([]hwy.Float16), any(output).([]hwy.Float16), any(alpha).(hwy.Float16), any(beta).(hwy.Float16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []hwy.BFloat16:
		ApplyPackedOutputBFloat16(any(packedOutput).([]hwy.BFloat16), any(output).([]hwy.BFloat16), any(alpha).(hwy.BFloat16), any(beta).(hwy.BFloat16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float32:
		ApplyPackedOutputFloat32(any(packedOutput).([]float32), any(output).([]float32), any(alpha).(float32), any(beta).(float32), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float64:
		ApplyPackedOutputFloat64(any(packedOutput).([]float64), any(output).([]float64), any(alpha).(float64), any(beta).(float64), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	}
}

// ApplyPackedOutputSimple is a simplified version for alpha=1, beta=0.
//
// When no scaling is needed, this directly copies from packed to output,
// which is faster than the general case.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ApplyPackedOutputSimple[T hwy.Floats](packedOutput []T, output []T, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	switch any(packedOutput).(type) {
	case []hwy.Float16:
		ApplyPackedOutputSimpleFloat16(any(packedOutput).([]hwy.Float16), any(output).([]hwy.Float16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []hwy.BFloat16:
		ApplyPackedOutputSimpleBFloat16(any(packedOutput).([]hwy.BFloat16), any(output).([]hwy.BFloat16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float32:
		ApplyPackedOutputSimpleFloat32(any(packedOutput).([]float32), any(output).([]float32), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float64:
		ApplyPackedOutputSimpleFloat64(any(packedOutput).([]float64), any(output).([]float64), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	}
}

// ApplyPackedOutputAccum is for accumulation (alpha=1, beta=1).
//
// This is the common case when accumulating K-dimension blocks:
// output += packedOutput
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ApplyPackedOutputAccum[T hwy.Floats](packedOutput []T, output []T, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	switch any(packedOutput).(type) {
	case []hwy.Float16:
		ApplyPackedOutputAccumFloat16(any(packedOutput).([]hwy.Float16), any(output).([]hwy.Float16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []hwy.BFloat16:
		ApplyPackedOutputAccumBFloat16(any(packedOutput).([]hwy.BFloat16), any(output).([]hwy.BFloat16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float32:
		ApplyPackedOutputAccumFloat32(any(packedOutput).([]float32), any(output).([]float32), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float64:
		ApplyPackedOutputAccumFloat64(any(packedOutput).([]float64), any(output).([]float64), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	}
}

func init() {
	initPacking_opsAll()
}

func initPacking_opsAll() {
	if hwy.NoSimdEnv() {
		initPacking_opsFallback()
		return
	}
	if archsimd.X86.AVX512() {
		initPacking_opsAVX512()
		return
	}
	if archsimd.X86.AVX2() {
		initPacking_opsAVX2()
		return
	}
	initPacking_opsFallback()
}

func initPacking_opsAVX2() {
	ApplyPackedOutputFloat16 = BaseApplyPackedOutput_avx2_Float16
	ApplyPackedOutputBFloat16 = BaseApplyPackedOutput_avx2_BFloat16
	ApplyPackedOutputFloat32 = BaseApplyPackedOutput_avx2
	ApplyPackedOutputFloat64 = BaseApplyPackedOutput_avx2_Float64
	ApplyPackedOutputSimpleFloat16 = BaseApplyPackedOutputSimple_avx2_Float16
	ApplyPackedOutputSimpleBFloat16 = BaseApplyPackedOutputSimple_avx2_BFloat16
	ApplyPackedOutputSimpleFloat32 = BaseApplyPackedOutputSimple_avx2
	ApplyPackedOutputSimpleFloat64 = BaseApplyPackedOutputSimple_avx2_Float64
	ApplyPackedOutputAccumFloat16 = BaseApplyPackedOutputAccum_avx2_Float16
	ApplyPackedOutputAccumBFloat16 = BaseApplyPackedOutputAccum_avx2_BFloat16
	ApplyPackedOutputAccumFloat32 = BaseApplyPackedOutputAccum_avx2
	ApplyPackedOutputAccumFloat64 = BaseApplyPackedOutputAccum_avx2_Float64
}

func initPacking_opsAVX512() {
	ApplyPackedOutputFloat16 = BaseApplyPackedOutput_avx512_Float16
	ApplyPackedOutputBFloat16 = BaseApplyPackedOutput_avx512_BFloat16
	ApplyPackedOutputFloat32 = BaseApplyPackedOutput_avx512
	ApplyPackedOutputFloat64 = BaseApplyPackedOutput_avx512_Float64
	ApplyPackedOutputSimpleFloat16 = BaseApplyPackedOutputSimple_avx512_Float16
	ApplyPackedOutputSimpleBFloat16 = BaseApplyPackedOutputSimple_avx512_BFloat16
	ApplyPackedOutputSimpleFloat32 = BaseApplyPackedOutputSimple_avx512
	ApplyPackedOutputSimpleFloat64 = BaseApplyPackedOutputSimple_avx512_Float64
	ApplyPackedOutputAccumFloat16 = BaseApplyPackedOutputAccum_avx512_Float16
	ApplyPackedOutputAccumBFloat16 = BaseApplyPackedOutputAccum_avx512_BFloat16
	ApplyPackedOutputAccumFloat32 = BaseApplyPackedOutputAccum_avx512
	ApplyPackedOutputAccumFloat64 = BaseApplyPackedOutputAccum_avx512_Float64
}

func initPacking_opsFallback() {
	ApplyPackedOutputFloat16 = BaseApplyPackedOutput_fallback_Float16
	ApplyPackedOutputBFloat16 = BaseApplyPackedOutput_fallback_BFloat16
	ApplyPackedOutputFloat32 = BaseApplyPackedOutput_fallback
	ApplyPackedOutputFloat64 = BaseApplyPackedOutput_fallback_Float64
	ApplyPackedOutputSimpleFloat16 = BaseApplyPackedOutputSimple_fallback_Float16
	ApplyPackedOutputSimpleBFloat16 = BaseApplyPackedOutputSimple_fallback_BFloat16
	ApplyPackedOutputSimpleFloat32 = BaseApplyPackedOutputSimple_fallback
	ApplyPackedOutputSimpleFloat64 = BaseApplyPackedOutputSimple_fallback_Float64
	ApplyPackedOutputAccumFloat16 = BaseApplyPackedOutputAccum_fallback_Float16
	ApplyPackedOutputAccumBFloat16 = BaseApplyPackedOutputAccum_fallback_BFloat16
	ApplyPackedOutputAccumFloat32 = BaseApplyPackedOutputAccum_fallback
	ApplyPackedOutputAccumFloat64 = BaseApplyPackedOutputAccum_fallback_Float64
}
