//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package matmul

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/matmul/asm"
)

func init() {
	initFusedint8actmatmulNeonCAsm()
}

func initFusedint8actmatmulNeonCAsm() {
	if hwy.NoSimdEnv() || hwy.HasSME() {
		return
	}
	FusedInt8MatMulSiLU = fusedInt8MatMulSiLUAsmF32
	FusedInt8MatMulGELU = fusedInt8MatMulGELUAsmF32
	FusedInt8MatMulGELUApprox = fusedInt8MatMulGELUApproxAsmF32
	FusedInt8MatMulReLU = fusedInt8MatMulReLUAsmF32
}

func fusedInt8MatMulSiLUAsmF32(input []float32, weights []int8, scales, bias, output []float32, M, K, N, groupSize int) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_weights unsafe.Pointer
	if len(weights) > 0 {
		p_weights = unsafe.Pointer(&weights[0])
	}
	var p_scales unsafe.Pointer
	if len(scales) > 0 {
		p_scales = unsafe.Pointer(&scales[0])
	}
	var p_bias unsafe.Pointer
	if len(bias) > 0 {
		p_bias = unsafe.Pointer(&bias[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	asm.FusedInt8MatMulSiLU_F32(
		p_input,
		p_weights,
		p_scales,
		p_bias,
		p_output,
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

func fusedInt8MatMulGELUAsmF32(input []float32, weights []int8, scales, bias, output []float32, M, K, N, groupSize int) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_weights unsafe.Pointer
	if len(weights) > 0 {
		p_weights = unsafe.Pointer(&weights[0])
	}
	var p_scales unsafe.Pointer
	if len(scales) > 0 {
		p_scales = unsafe.Pointer(&scales[0])
	}
	var p_bias unsafe.Pointer
	if len(bias) > 0 {
		p_bias = unsafe.Pointer(&bias[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	asm.FusedInt8MatMulGELU_F32(
		p_input,
		p_weights,
		p_scales,
		p_bias,
		p_output,
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

func fusedInt8MatMulGELUApproxAsmF32(input []float32, weights []int8, scales, bias, output []float32, M, K, N, groupSize int) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_weights unsafe.Pointer
	if len(weights) > 0 {
		p_weights = unsafe.Pointer(&weights[0])
	}
	var p_scales unsafe.Pointer
	if len(scales) > 0 {
		p_scales = unsafe.Pointer(&scales[0])
	}
	var p_bias unsafe.Pointer
	if len(bias) > 0 {
		p_bias = unsafe.Pointer(&bias[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	asm.FusedInt8MatMulGELUApprox_F32(
		p_input,
		p_weights,
		p_scales,
		p_bias,
		p_output,
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

func fusedInt8MatMulReLUAsmF32(input []float32, weights []int8, scales, bias, output []float32, M, K, N, groupSize int) {
	var p_input unsafe.Pointer
	if len(input) > 0 {
		p_input = unsafe.Pointer(&input[0])
	}
	var p_weights unsafe.Pointer
	if len(weights) > 0 {
		p_weights = unsafe.Pointer(&weights[0])
	}
	var p_scales unsafe.Pointer
	if len(scales) > 0 {
		p_scales = unsafe.Pointer(&scales[0])
	}
	var p_bias unsafe.Pointer
	if len(bias) > 0 {
		p_bias = unsafe.Pointer(&bias[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	asm.FusedInt8MatMulReLU_F32(
		p_input,
		p_weights,
		p_scales,
		p_bias,
		p_output,
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

