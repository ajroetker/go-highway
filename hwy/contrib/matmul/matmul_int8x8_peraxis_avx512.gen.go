// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
	"unsafe"
)

func BaseInt8x8MatMulPerAxis_avx512(output []int32, a []uint8, b []uint8, aZP []uint8, bZP []uint8, M int, K int, N int) {
	if M == 0 || K == 0 || N == 0 {
		return
	}
	lanes := 16
	dequantBuf := [16]int32{}
	accBuf := make([]int32, N)
	for m := range M {
		azp := int32(aZP[m])
		for i := range N {
			accBuf[i] = 0
		}
		for k := range K {
			aVal := int32(a[m*K+k]) - azp
			aVec := archsimd.BroadcastInt32x16(aVal)
			baseIdx := k * N
			var n int
			for n = 0; n+lanes <= N; n += lanes {
				for lane := range lanes {
					dequantBuf[lane] = int32(b[baseIdx+n+lane]) - int32(bZP[n+lane])
				}
				bVec := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&dequantBuf[0])))
				acc := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&accBuf[n])))
				acc = aVec.Mul(bVec).Add(acc)
				acc.Store((*[16]int32)(unsafe.Pointer(&accBuf[n])))
			}
			for ; n < N; n++ {
				accBuf[n] += aVal * (int32(b[baseIdx+n]) - int32(bZP[n]))
			}
		}
		copy(output[m*N:(m+1)*N], accBuf)
	}
}
