// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseMatMulKLast_avx2_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	lanes := 8
	if m == 1 {
		aRow := 0
		var j int
		for j = 0; j+3 < n; j += 4 {
			bRow0 := j * k
			bRow1 := (j + 1) * k
			bRow2 := (j + 2) * k
			bRow3 := (j + 3) * k
			acc0 := asm.ZeroFloat16x8AVX2()
			acc1 := asm.ZeroFloat16x8AVX2()
			acc2 := asm.ZeroFloat16x8AVX2()
			acc3 := asm.ZeroFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0]))
				acc0 = vA.MulAdd(asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow0+p:][0])), acc0)
				acc1 = vA.MulAdd(asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow1+p:][0])), acc1)
				acc2 = vA.MulAdd(asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow2+p:][0])), acc2)
				acc3 = vA.MulAdd(asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow3+p:][0])), acc3)
			}
			s0 := acc0.ReduceSum()
			s1 := acc1.ReduceSum()
			s2 := acc2.ReduceSum()
			s3 := acc3.ReduceSum()
			for ; p < k; p++ {
				ap := a[aRow+p]
				s0 += ap.Float32() * b[bRow0+p].Float32()
				s1 += ap.Float32() * b[bRow1+p].Float32()
				s2 += ap.Float32() * b[bRow2+p].Float32()
				s3 += ap.Float32() * b[bRow3+p].Float32()
			}
			c[j] = hwy.Float32ToFloat16(s0)
			c[j+1] = hwy.Float32ToFloat16(s1)
			c[j+2] = hwy.Float32ToFloat16(s2)
			c[j+3] = hwy.Float32ToFloat16(s3)
		}
		for ; j < n; j++ {
			bRow := j * k
			acc := asm.ZeroFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				acc = asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0])).MulAdd(asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0])), acc)
			}
			sum := acc.ReduceSum()
			for ; p < k; p++ {
				sum += a[aRow+p].Float32() * b[bRow+p].Float32()
			}
			c[j] = hwy.Float32ToFloat16(sum)
		}
		return
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := range n {
			bRow := j * k
			acc0 := asm.ZeroFloat16x8AVX2()
			acc1 := asm.ZeroFloat16x8AVX2()
			acc2 := asm.ZeroFloat16x8AVX2()
			acc3 := asm.ZeroFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vB := asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0]))
				acc0 = asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow0+p:][0])).MulAdd(vB, acc0)
				acc1 = asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow1+p:][0])).MulAdd(vB, acc1)
				acc2 = asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow2+p:][0])).MulAdd(vB, acc2)
				acc3 = asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow3+p:][0])).MulAdd(vB, acc3)
			}
			s0 := acc0.ReduceSum()
			s1 := acc1.ReduceSum()
			s2 := acc2.ReduceSum()
			s3 := acc3.ReduceSum()
			for ; p < k; p++ {
				s0 += a[aRow0+p].Float32() * b[bRow+p].Float32()
				s1 += a[aRow1+p].Float32() * b[bRow+p].Float32()
				s2 += a[aRow2+p].Float32() * b[bRow+p].Float32()
				s3 += a[aRow3+p].Float32() * b[bRow+p].Float32()
			}
			c[cRow0+j] = hwy.Float32ToFloat16(s0)
			c[cRow1+j] = hwy.Float32ToFloat16(s1)
			c[cRow2+j] = hwy.Float32ToFloat16(s2)
			c[cRow3+j] = hwy.Float32ToFloat16(s3)
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := range n {
			bRow := j * k
			acc := asm.ZeroFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0]))
				vB := asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0]))
				acc = vA.MulAdd(vB, acc)
			}
			sum := acc.ReduceSum()
			for ; p < k; p++ {
				sum += a[aRow+p].Float32() * b[bRow+p].Float32()
			}
			c[cRow+j] = hwy.Float32ToFloat16(sum)
		}
	}
}

func BaseMatMulKLast_avx2_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	lanes := 8
	if m == 1 {
		aRow := 0
		var j int
		for j = 0; j+3 < n; j += 4 {
			bRow0 := j * k
			bRow1 := (j + 1) * k
			bRow2 := (j + 2) * k
			bRow3 := (j + 3) * k
			acc0 := asm.ZeroBFloat16x8AVX2()
			acc1 := asm.ZeroBFloat16x8AVX2()
			acc2 := asm.ZeroBFloat16x8AVX2()
			acc3 := asm.ZeroBFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0]))
				acc0 = vA.MulAdd(asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow0+p:][0])), acc0)
				acc1 = vA.MulAdd(asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow1+p:][0])), acc1)
				acc2 = vA.MulAdd(asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow2+p:][0])), acc2)
				acc3 = vA.MulAdd(asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow3+p:][0])), acc3)
			}
			s0 := acc0.ReduceSum()
			s1 := acc1.ReduceSum()
			s2 := acc2.ReduceSum()
			s3 := acc3.ReduceSum()
			for ; p < k; p++ {
				ap := a[aRow+p]
				s0 += ap.Float32() * b[bRow0+p].Float32()
				s1 += ap.Float32() * b[bRow1+p].Float32()
				s2 += ap.Float32() * b[bRow2+p].Float32()
				s3 += ap.Float32() * b[bRow3+p].Float32()
			}
			c[j] = hwy.Float32ToBFloat16(s0)
			c[j+1] = hwy.Float32ToBFloat16(s1)
			c[j+2] = hwy.Float32ToBFloat16(s2)
			c[j+3] = hwy.Float32ToBFloat16(s3)
		}
		for ; j < n; j++ {
			bRow := j * k
			acc := asm.ZeroBFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				acc = asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0])).MulAdd(asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0])), acc)
			}
			sum := acc.ReduceSum()
			for ; p < k; p++ {
				sum += a[aRow+p].Float32() * b[bRow+p].Float32()
			}
			c[j] = hwy.Float32ToBFloat16(sum)
		}
		return
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := range n {
			bRow := j * k
			acc0 := asm.ZeroBFloat16x8AVX2()
			acc1 := asm.ZeroBFloat16x8AVX2()
			acc2 := asm.ZeroBFloat16x8AVX2()
			acc3 := asm.ZeroBFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vB := asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0]))
				acc0 = asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow0+p:][0])).MulAdd(vB, acc0)
				acc1 = asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow1+p:][0])).MulAdd(vB, acc1)
				acc2 = asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow2+p:][0])).MulAdd(vB, acc2)
				acc3 = asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow3+p:][0])).MulAdd(vB, acc3)
			}
			s0 := acc0.ReduceSum()
			s1 := acc1.ReduceSum()
			s2 := acc2.ReduceSum()
			s3 := acc3.ReduceSum()
			for ; p < k; p++ {
				s0 += a[aRow0+p].Float32() * b[bRow+p].Float32()
				s1 += a[aRow1+p].Float32() * b[bRow+p].Float32()
				s2 += a[aRow2+p].Float32() * b[bRow+p].Float32()
				s3 += a[aRow3+p].Float32() * b[bRow+p].Float32()
			}
			c[cRow0+j] = hwy.Float32ToBFloat16(s0)
			c[cRow1+j] = hwy.Float32ToBFloat16(s1)
			c[cRow2+j] = hwy.Float32ToBFloat16(s2)
			c[cRow3+j] = hwy.Float32ToBFloat16(s3)
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := range n {
			bRow := j * k
			acc := asm.ZeroBFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0]))
				vB := asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0]))
				acc = vA.MulAdd(vB, acc)
			}
			sum := acc.ReduceSum()
			for ; p < k; p++ {
				sum += a[aRow+p].Float32() * b[bRow+p].Float32()
			}
			c[cRow+j] = hwy.Float32ToBFloat16(sum)
		}
	}
}

func BaseMatMulKLast_avx2(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	lanes := 8
	if m == 1 {
		aRow := 0
		var j int
		for j = 0; j+3 < n; j += 4 {
			bRow0 := j * k
			bRow1 := (j + 1) * k
			bRow2 := (j + 2) * k
			bRow3 := (j + 3) * k
			acc0 := archsimd.BroadcastFloat32x8(0)
			acc1 := archsimd.BroadcastFloat32x8(0)
			acc2 := archsimd.BroadcastFloat32x8(0)
			acc3 := archsimd.BroadcastFloat32x8(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow+p])))
				acc0 = vA.MulAdd(archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow0+p]))), acc0)
				acc1 = vA.MulAdd(archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow1+p]))), acc1)
				acc2 = vA.MulAdd(archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow2+p]))), acc2)
				acc3 = vA.MulAdd(archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow3+p]))), acc3)
			}
			s0 := hwy.ReduceSum_AVX2_F32x8(acc0)
			s1 := hwy.ReduceSum_AVX2_F32x8(acc1)
			s2 := hwy.ReduceSum_AVX2_F32x8(acc2)
			s3 := hwy.ReduceSum_AVX2_F32x8(acc3)
			for ; p < k; p++ {
				ap := a[aRow+p]
				s0 += ap * b[bRow0+p]
				s1 += ap * b[bRow1+p]
				s2 += ap * b[bRow2+p]
				s3 += ap * b[bRow3+p]
			}
			c[j] = s0
			c[j+1] = s1
			c[j+2] = s2
			c[j+3] = s3
		}
		for ; j < n; j++ {
			bRow := j * k
			acc := archsimd.BroadcastFloat32x8(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				acc = archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow+p]))).MulAdd(archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow+p]))), acc)
			}
			sum := hwy.ReduceSum_AVX2_F32x8(acc)
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[j] = sum
		}
		return
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := range n {
			bRow := j * k
			acc0 := archsimd.BroadcastFloat32x8(0)
			acc1 := archsimd.BroadcastFloat32x8(0)
			acc2 := archsimd.BroadcastFloat32x8(0)
			acc3 := archsimd.BroadcastFloat32x8(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vB := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow+p])))
				acc0 = archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow0+p]))).MulAdd(vB, acc0)
				acc1 = archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow1+p]))).MulAdd(vB, acc1)
				acc2 = archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow2+p]))).MulAdd(vB, acc2)
				acc3 = archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow3+p]))).MulAdd(vB, acc3)
			}
			s0 := hwy.ReduceSum_AVX2_F32x8(acc0)
			s1 := hwy.ReduceSum_AVX2_F32x8(acc1)
			s2 := hwy.ReduceSum_AVX2_F32x8(acc2)
			s3 := hwy.ReduceSum_AVX2_F32x8(acc3)
			for ; p < k; p++ {
				s0 += a[aRow0+p] * b[bRow+p]
				s1 += a[aRow1+p] * b[bRow+p]
				s2 += a[aRow2+p] * b[bRow+p]
				s3 += a[aRow3+p] * b[bRow+p]
			}
			c[cRow0+j] = s0
			c[cRow1+j] = s1
			c[cRow2+j] = s2
			c[cRow3+j] = s3
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := range n {
			bRow := j * k
			acc := archsimd.BroadcastFloat32x8(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow+p])))
				vB := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow+p])))
				acc = vA.MulAdd(vB, acc)
			}
			sum := hwy.ReduceSum_AVX2_F32x8(acc)
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[cRow+j] = sum
		}
	}
}

func BaseMatMulKLast_avx2_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	lanes := 4
	if m == 1 {
		aRow := 0
		var j int
		for j = 0; j+3 < n; j += 4 {
			bRow0 := j * k
			bRow1 := (j + 1) * k
			bRow2 := (j + 2) * k
			bRow3 := (j + 3) * k
			acc0 := archsimd.BroadcastFloat64x4(0)
			acc1 := archsimd.BroadcastFloat64x4(0)
			acc2 := archsimd.BroadcastFloat64x4(0)
			acc3 := archsimd.BroadcastFloat64x4(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow+p])))
				acc0 = vA.MulAdd(archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow0+p]))), acc0)
				acc1 = vA.MulAdd(archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow1+p]))), acc1)
				acc2 = vA.MulAdd(archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow2+p]))), acc2)
				acc3 = vA.MulAdd(archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow3+p]))), acc3)
			}
			s0 := hwy.ReduceSum_AVX2_F64x4(acc0)
			s1 := hwy.ReduceSum_AVX2_F64x4(acc1)
			s2 := hwy.ReduceSum_AVX2_F64x4(acc2)
			s3 := hwy.ReduceSum_AVX2_F64x4(acc3)
			for ; p < k; p++ {
				ap := a[aRow+p]
				s0 += ap * b[bRow0+p]
				s1 += ap * b[bRow1+p]
				s2 += ap * b[bRow2+p]
				s3 += ap * b[bRow3+p]
			}
			c[j] = s0
			c[j+1] = s1
			c[j+2] = s2
			c[j+3] = s3
		}
		for ; j < n; j++ {
			bRow := j * k
			acc := archsimd.BroadcastFloat64x4(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				acc = archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow+p]))).MulAdd(archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow+p]))), acc)
			}
			sum := hwy.ReduceSum_AVX2_F64x4(acc)
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[j] = sum
		}
		return
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := range n {
			bRow := j * k
			acc0 := archsimd.BroadcastFloat64x4(0)
			acc1 := archsimd.BroadcastFloat64x4(0)
			acc2 := archsimd.BroadcastFloat64x4(0)
			acc3 := archsimd.BroadcastFloat64x4(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vB := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow+p])))
				acc0 = archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow0+p]))).MulAdd(vB, acc0)
				acc1 = archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow1+p]))).MulAdd(vB, acc1)
				acc2 = archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow2+p]))).MulAdd(vB, acc2)
				acc3 = archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow3+p]))).MulAdd(vB, acc3)
			}
			s0 := hwy.ReduceSum_AVX2_F64x4(acc0)
			s1 := hwy.ReduceSum_AVX2_F64x4(acc1)
			s2 := hwy.ReduceSum_AVX2_F64x4(acc2)
			s3 := hwy.ReduceSum_AVX2_F64x4(acc3)
			for ; p < k; p++ {
				s0 += a[aRow0+p] * b[bRow+p]
				s1 += a[aRow1+p] * b[bRow+p]
				s2 += a[aRow2+p] * b[bRow+p]
				s3 += a[aRow3+p] * b[bRow+p]
			}
			c[cRow0+j] = s0
			c[cRow1+j] = s1
			c[cRow2+j] = s2
			c[cRow3+j] = s3
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := range n {
			bRow := j * k
			acc := archsimd.BroadcastFloat64x4(0)
			var p int
			for p = 0; p+lanes <= k; p += lanes {
				vA := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow+p])))
				vB := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow+p])))
				acc = vA.MulAdd(vB, acc)
			}
			sum := hwy.ReduceSum_AVX2_F64x4(acc)
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[cRow+j] = sum
		}
	}
}

func BaseMatMulKLastBlocked_avx2_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	lanes := 8
	for i := range c[:m*n] {
		c[i] = hwy.Float32ToFloat16(0)
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := asm.ZeroFloat16x8AVX2()
						var p int
						for p = kk; p+lanes <= kEnd; p += lanes {
							vA := asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0]))
							vB := asm.LoadFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0]))
							acc = vA.MulAdd(vB, acc)
						}
						sum := acc.ReduceSum()
						for ; p < kEnd; p++ {
							sum += a[aRow+p].Float32() * b[bRow+p].Float32()
						}
						c[cRow+j] = hwy.Float32ToFloat16(c[cRow+j].Float32() + sum)
					}
				}
			}
		}
	}
}

func BaseMatMulKLastBlocked_avx2_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	lanes := 8
	for i := range c[:m*n] {
		c[i] = hwy.Float32ToBFloat16(0)
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := asm.ZeroBFloat16x8AVX2()
						var p int
						for p = kk; p+lanes <= kEnd; p += lanes {
							vA := asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&a[aRow+p:][0]))
							vB := asm.LoadBFloat16x8AVX2Ptr(unsafe.Pointer(&b[bRow+p:][0]))
							acc = vA.MulAdd(vB, acc)
						}
						sum := acc.ReduceSum()
						for ; p < kEnd; p++ {
							sum += a[aRow+p].Float32() * b[bRow+p].Float32()
						}
						c[cRow+j] = hwy.Float32ToBFloat16(c[cRow+j].Float32() + sum)
					}
				}
			}
		}
	}
}

func BaseMatMulKLastBlocked_avx2(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	lanes := 8
	for i := range c[:m*n] {
		c[i] = 0
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := archsimd.BroadcastFloat32x8(0)
						var p int
						for p = kk; p+lanes <= kEnd; p += lanes {
							vA := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&a[aRow+p])))
							vB := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&b[bRow+p])))
							acc = vA.MulAdd(vB, acc)
						}
						sum := hwy.ReduceSum_AVX2_F32x8(acc)
						for ; p < kEnd; p++ {
							sum += a[aRow+p] * b[bRow+p]
						}
						c[cRow+j] += sum
					}
				}
			}
		}
	}
}

func BaseMatMulKLastBlocked_avx2_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	lanes := 4
	for i := range c[:m*n] {
		c[i] = 0
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := archsimd.BroadcastFloat64x4(0)
						var p int
						for p = kk; p+lanes <= kEnd; p += lanes {
							vA := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&a[aRow+p])))
							vB := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&b[bRow+p])))
							acc = vA.MulAdd(vB, acc)
						}
						sum := hwy.ReduceSum_AVX2_F64x4(acc)
						for ; p < kEnd; p++ {
							sum += a[aRow+p] * b[bRow+p]
						}
						c[cRow+j] += sum
					}
				}
			}
		}
	}
}
