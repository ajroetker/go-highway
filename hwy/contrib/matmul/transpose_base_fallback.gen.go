// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseTranspose2D_fallback_Float16(src []hwy.Float16, m int, k int, dst []hwy.Float16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	for i := 0; i <= m-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]hwy.Float16, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]hwy.Float16, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*m+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockM_2 := (m / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}

func BaseTranspose2D_fallback_BFloat16(src []hwy.BFloat16, m int, k int, dst []hwy.BFloat16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	for i := 0; i <= m-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]hwy.BFloat16, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]hwy.BFloat16, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*m+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockM_2 := (m / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}

func BaseTranspose2D_fallback(src []float32, m int, k int, dst []float32) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	for i := 0; i <= m-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]float32, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]float32, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*m+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockM_2 := (m / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}

func BaseTranspose2D_fallback_Float64(src []float64, m int, k int, dst []float64) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	for i := 0; i <= m-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]float64, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]float64, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*m+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockM_2 := (m / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}
