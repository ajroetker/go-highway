//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// PackRHSVecCF16 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCF16(b, packed []hwy.Float16, k, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	kVal := int64(k)
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_f16_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackRHSVecCBF16 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCBF16(b, packed []hwy.BFloat16, k, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	kVal := int64(k)
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_bf16_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackRHSVecCF32 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCF32(b, packed []float32, k, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	kVal := int64(k)
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_f32_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackRHSVecCF64 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCF64(b, packed []float64, k, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	kVal := int64(k)
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_f64_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

