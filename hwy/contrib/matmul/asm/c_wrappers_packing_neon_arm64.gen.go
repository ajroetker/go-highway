//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// PackLHSVecCF16 computes PackLHSVec using NEON SIMD assembly.
func PackLHSVecCF16(a, packed []hwy.Float16, m, k, rowStart, colStart, panelRows, panelK, mr int) int {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	mVal := int64(m)
	kVal := int64(k)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelRowsVal := int64(panelRows)
	panelKVal := int64(panelK)
	mrVal := int64(mr)
	len_aVal := int64(len(a))
	len_packedVal := int64(len(packed))
	var out_result int64
	packlhsvec_c_f16_neon(
		p_a,
		p_packed,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelRowsVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&mrVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackLHSVecCBF16 computes PackLHSVec using NEON SIMD assembly.
func PackLHSVecCBF16(a, packed []hwy.BFloat16, m, k, rowStart, colStart, panelRows, panelK, mr int) int {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	mVal := int64(m)
	kVal := int64(k)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelRowsVal := int64(panelRows)
	panelKVal := int64(panelK)
	mrVal := int64(mr)
	len_aVal := int64(len(a))
	len_packedVal := int64(len(packed))
	var out_result int64
	packlhsvec_c_bf16_neon(
		p_a,
		p_packed,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelRowsVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&mrVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackLHSVecCF32 computes PackLHSVec using NEON SIMD assembly.
func PackLHSVecCF32(a, packed []float32, m, k, rowStart, colStart, panelRows, panelK, mr int) int {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	mVal := int64(m)
	kVal := int64(k)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelRowsVal := int64(panelRows)
	panelKVal := int64(panelK)
	mrVal := int64(mr)
	len_aVal := int64(len(a))
	len_packedVal := int64(len(packed))
	var out_result int64
	packlhsvec_c_f32_neon(
		p_a,
		p_packed,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelRowsVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&mrVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackLHSVecCF64 computes PackLHSVec using NEON SIMD assembly.
func PackLHSVecCF64(a, packed []float64, m, k, rowStart, colStart, panelRows, panelK, mr int) int {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	mVal := int64(m)
	kVal := int64(k)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelRowsVal := int64(panelRows)
	panelKVal := int64(panelK)
	mrVal := int64(mr)
	len_aVal := int64(len(a))
	len_packedVal := int64(len(packed))
	var out_result int64
	packlhsvec_c_f64_neon(
		p_a,
		p_packed,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelRowsVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&mrVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackRHSVecCF16 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCF16(b, packed []hwy.Float16, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_f16_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackRHSVecCBF16 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCBF16(b, packed []hwy.BFloat16, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_bf16_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackRHSVecCF32 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCF32(b, packed []float32, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_f32_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// PackRHSVecCF64 computes PackRHSVec using NEON SIMD assembly.
func PackRHSVecCF64(b, packed []float64, n, rowStart, colStart, panelK, panelCols, nr int) int {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	var out_result int64
	packrhsvec_c_f64_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

