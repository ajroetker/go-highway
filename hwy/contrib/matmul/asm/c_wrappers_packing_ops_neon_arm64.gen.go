//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// PackRHSFastCF16 computes PackRHSFast using NEON SIMD assembly.
func PackRHSFastCF16(b, packed []hwy.Float16, n, rowStart, colStart, panelK, panelCols, nr int) {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	packrhsfast_c_f16_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
	)
}

// PackRHSFastCF32 computes PackRHSFast using NEON SIMD assembly.
func PackRHSFastCF32(b, packed []float32, n, rowStart, colStart, panelK, panelCols, nr int) {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	packrhsfast_c_f32_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
	)
}

// PackRHSFastCF64 computes PackRHSFast using NEON SIMD assembly.
func PackRHSFastCF64(b, packed []float64, n, rowStart, colStart, panelK, panelCols, nr int) {
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_packed unsafe.Pointer
	if len(packed) > 0 {
		p_packed = unsafe.Pointer(&packed[0])
	}
	nVal := int64(n)
	rowStartVal := int64(rowStart)
	colStartVal := int64(colStart)
	panelKVal := int64(panelK)
	panelColsVal := int64(panelCols)
	nrVal := int64(nr)
	len_bVal := int64(len(b))
	len_packedVal := int64(len(packed))
	packrhsfast_c_f64_neon(
		p_b,
		p_packed,
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&rowStartVal),
		unsafe.Pointer(&colStartVal),
		unsafe.Pointer(&panelKVal),
		unsafe.Pointer(&panelColsVal),
		unsafe.Pointer(&nrVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_packedVal),
	)
}

// ApplyPackedOutputCF16 computes ApplyPackedOutput using NEON SIMD assembly.
func ApplyPackedOutputCF16(packedOutput, output []hwy.Float16, alpha, beta hwy.Float16, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	alphaVal := uint16(alpha)
	betaVal := uint16(beta)
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutput_c_f16_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&betaVal),
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputCF32 computes ApplyPackedOutput using NEON SIMD assembly.
func ApplyPackedOutputCF32(packedOutput, output []float32, alpha, beta float32, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	alphaVal := alpha
	betaVal := beta
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutput_c_f32_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&betaVal),
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputCF64 computes ApplyPackedOutput using NEON SIMD assembly.
func ApplyPackedOutputCF64(packedOutput, output []float64, alpha, beta float64, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	alphaVal := alpha
	betaVal := beta
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutput_c_f64_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&alphaVal),
		unsafe.Pointer(&betaVal),
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputSimpleCF16 computes ApplyPackedOutputSimple using NEON SIMD assembly.
func ApplyPackedOutputSimpleCF16(packedOutput, output []hwy.Float16, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutputsimple_c_f16_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputSimpleCF32 computes ApplyPackedOutputSimple using NEON SIMD assembly.
func ApplyPackedOutputSimpleCF32(packedOutput, output []float32, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutputsimple_c_f32_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputSimpleCF64 computes ApplyPackedOutputSimple using NEON SIMD assembly.
func ApplyPackedOutputSimpleCF64(packedOutput, output []float64, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutputsimple_c_f64_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputAccumCF16 computes ApplyPackedOutputAccum using NEON SIMD assembly.
func ApplyPackedOutputAccumCF16(packedOutput, output []hwy.Float16, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutputaccum_c_f16_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputAccumCF32 computes ApplyPackedOutputAccum using NEON SIMD assembly.
func ApplyPackedOutputAccumCF32(packedOutput, output []float32, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutputaccum_c_f32_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

// ApplyPackedOutputAccumCF64 computes ApplyPackedOutputAccum using NEON SIMD assembly.
func ApplyPackedOutputAccumCF64(packedOutput, output []float64, packedStride, outputRowOffset, outputColOffset, outputStride, height, width int) {
	var p_packedOutput unsafe.Pointer
	if len(packedOutput) > 0 {
		p_packedOutput = unsafe.Pointer(&packedOutput[0])
	}
	var p_output unsafe.Pointer
	if len(output) > 0 {
		p_output = unsafe.Pointer(&output[0])
	}
	packedStrideVal := int64(packedStride)
	outputRowOffsetVal := int64(outputRowOffset)
	outputColOffsetVal := int64(outputColOffset)
	outputStrideVal := int64(outputStride)
	heightVal := int64(height)
	widthVal := int64(width)
	len_packedOutputVal := int64(len(packedOutput))
	len_outputVal := int64(len(output))
	applypackedoutputaccum_c_f64_neon(
		p_packedOutput,
		p_output,
		unsafe.Pointer(&packedStrideVal),
		unsafe.Pointer(&outputRowOffsetVal),
		unsafe.Pointer(&outputColOffsetVal),
		unsafe.Pointer(&outputStrideVal),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&widthVal),
		unsafe.Pointer(&len_packedOutputVal),
		unsafe.Pointer(&len_outputVal),
	)
}

