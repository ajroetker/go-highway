//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// BlockedMatMulCF16 computes BlockedMatMul using NEON SIMD assembly.
func BlockedMatMulCF16(a, b, c []hwy.Float16, m, n, k int) {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_c unsafe.Pointer
	if len(c) > 0 {
		p_c = unsafe.Pointer(&c[0])
	}
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	len_aVal := int64(len(a))
	len_bVal := int64(len(b))
	len_cVal := int64(len(c))
	blockedmatmul_c_f16_neon(
		p_a,
		p_b,
		p_c,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_cVal),
	)
}

// BlockedMatMulCBF16 computes BlockedMatMul using NEON SIMD assembly.
func BlockedMatMulCBF16(a, b, c []hwy.BFloat16, m, n, k int) {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_c unsafe.Pointer
	if len(c) > 0 {
		p_c = unsafe.Pointer(&c[0])
	}
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	len_aVal := int64(len(a))
	len_bVal := int64(len(b))
	len_cVal := int64(len(c))
	blockedmatmul_c_bf16_neon(
		p_a,
		p_b,
		p_c,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_cVal),
	)
}

// BlockedMatMulCF32 computes BlockedMatMul using NEON SIMD assembly.
func BlockedMatMulCF32(a, b, c []float32, m, n, k int) {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_c unsafe.Pointer
	if len(c) > 0 {
		p_c = unsafe.Pointer(&c[0])
	}
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	len_aVal := int64(len(a))
	len_bVal := int64(len(b))
	len_cVal := int64(len(c))
	blockedmatmul_c_f32_neon(
		p_a,
		p_b,
		p_c,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_cVal),
	)
}

// BlockedMatMulCF64 computes BlockedMatMul using NEON SIMD assembly.
func BlockedMatMulCF64(a, b, c []float64, m, n, k int) {
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	var p_c unsafe.Pointer
	if len(c) > 0 {
		p_c = unsafe.Pointer(&c[0])
	}
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	len_aVal := int64(len(a))
	len_bVal := int64(len(b))
	len_cVal := int64(len(c))
	blockedmatmul_c_f64_neon(
		p_a,
		p_b,
		p_c,
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
		unsafe.Pointer(&len_aVal),
		unsafe.Pointer(&len_bVal),
		unsafe.Pointer(&len_cVal),
	)
}

