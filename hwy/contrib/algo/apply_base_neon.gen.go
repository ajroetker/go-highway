// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package algo

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseApply_neon_Float16(in []hwy.Float16, out []hwy.Float16, fn func(asm.Float16x8) asm.Float16x8) {
	n := min(len(in), len(out))
	lanes := 8
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		x := asm.LoadFloat16x8Ptr(unsafe.Pointer(&in[i:][0]))
		fn(x).StorePtr(unsafe.Pointer(&out[i:][0]))
		x1 := asm.LoadFloat16x8Ptr(unsafe.Pointer(&in[i+8:][0]))
		fn(x1).StorePtr(unsafe.Pointer(&out[i+8:][0]))
	}
	for ; i+lanes <= n; i += lanes {
		x := asm.LoadFloat16x8Ptr(unsafe.Pointer(&in[i:][0]))
		fn(x).StorePtr(unsafe.Pointer(&out[i:][0]))
	}
	if remaining := n - i; remaining > 0 {
		buf := [8]hwy.Float16{}
		copy(buf[:], in[i:i+remaining])
		x := asm.LoadFloat16x8Ptr(unsafe.Pointer(&buf[0]))
		fn(x).StorePtr(unsafe.Pointer(&buf[0]))
		copy(out[i:i+remaining], buf[:remaining])
	}
}

func BaseApply_neon_BFloat16(in []hwy.BFloat16, out []hwy.BFloat16, fn func(asm.BFloat16x8) asm.BFloat16x8) {
	n := min(len(in), len(out))
	lanes := 8
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		x := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&in[i:][0]))
		fn(x).StorePtr(unsafe.Pointer(&out[i:][0]))
		x1 := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&in[i+8:][0]))
		fn(x1).StorePtr(unsafe.Pointer(&out[i+8:][0]))
	}
	for ; i+lanes <= n; i += lanes {
		x := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&in[i:][0]))
		fn(x).StorePtr(unsafe.Pointer(&out[i:][0]))
	}
	if remaining := n - i; remaining > 0 {
		buf := [8]hwy.BFloat16{}
		copy(buf[:], in[i:i+remaining])
		x := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&buf[0]))
		fn(x).StorePtr(unsafe.Pointer(&buf[0]))
		copy(out[i:i+remaining], buf[:remaining])
	}
}

func BaseApply_neon(in []float32, out []float32, fn func(asm.Float32x4) asm.Float32x4) {
	n := min(len(in), len(out))
	lanes := 4
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		x := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[4]float32)(unsafe.Pointer(&out[i])))
		x1 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&in[i+4])))
		fn(x1).Store((*[4]float32)(unsafe.Pointer(&out[i+4])))
	}
	for ; i+lanes <= n; i += lanes {
		x := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[4]float32)(unsafe.Pointer(&out[i])))
	}
	if remaining := n - i; remaining > 0 {
		buf := [4]float32{}
		copy(buf[:], in[i:i+remaining])
		x := asm.LoadFloat32x4Slice(buf[:])
		fn(x).StoreSlice(buf[:])
		copy(out[i:i+remaining], buf[:remaining])
	}
}

func BaseApply_neon_Float64(in []float64, out []float64, fn func(asm.Float64x2) asm.Float64x2) {
	n := min(len(in), len(out))
	lanes := 2
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		x := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[2]float64)(unsafe.Pointer(&out[i])))
		x1 := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&in[i+2])))
		fn(x1).Store((*[2]float64)(unsafe.Pointer(&out[i+2])))
	}
	for ; i+lanes <= n; i += lanes {
		x := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[2]float64)(unsafe.Pointer(&out[i])))
	}
	if remaining := n - i; remaining > 0 {
		buf := [2]float64{}
		copy(buf[:], in[i:i+remaining])
		x := asm.LoadFloat64x2Slice(buf[:])
		fn(x).StoreSlice(buf[:])
		copy(out[i:i+remaining], buf[:remaining])
	}
}
