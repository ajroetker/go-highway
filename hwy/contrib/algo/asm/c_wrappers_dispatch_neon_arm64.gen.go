//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// ExpTransformCF16 computes ExpTransform using NEON SIMD assembly.
func ExpTransformCF16(in, out []hwy.Float16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	exptransform_c_f16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// ExpTransformCBF16 computes ExpTransform using NEON SIMD assembly.
func ExpTransformCBF16(in, out []hwy.BFloat16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	exptransform_c_bf16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// ExpTransformCF32 computes ExpTransform using NEON SIMD assembly.
func ExpTransformCF32(in, out []float32) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	exptransform_c_f32_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// ExpTransformCF64 computes ExpTransform using NEON SIMD assembly.
func ExpTransformCF64(in, out []float64) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	exptransform_c_f64_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// LogTransformCF16 computes LogTransform using NEON SIMD assembly.
func LogTransformCF16(in, out []hwy.Float16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	logtransform_c_f16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// LogTransformCBF16 computes LogTransform using NEON SIMD assembly.
func LogTransformCBF16(in, out []hwy.BFloat16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	logtransform_c_bf16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// LogTransformCF32 computes LogTransform using NEON SIMD assembly.
func LogTransformCF32(in, out []float32) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	logtransform_c_f32_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// LogTransformCF64 computes LogTransform using NEON SIMD assembly.
func LogTransformCF64(in, out []float64) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	logtransform_c_f64_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SinTransformCF16 computes SinTransform using NEON SIMD assembly.
func SinTransformCF16(in, out []hwy.Float16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sintransform_c_f16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SinTransformCBF16 computes SinTransform using NEON SIMD assembly.
func SinTransformCBF16(in, out []hwy.BFloat16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sintransform_c_bf16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SinTransformCF32 computes SinTransform using NEON SIMD assembly.
func SinTransformCF32(in, out []float32) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sintransform_c_f32_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SinTransformCF64 computes SinTransform using NEON SIMD assembly.
func SinTransformCF64(in, out []float64) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sintransform_c_f64_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// CosTransformCF16 computes CosTransform using NEON SIMD assembly.
func CosTransformCF16(in, out []hwy.Float16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	costransform_c_f16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// CosTransformCBF16 computes CosTransform using NEON SIMD assembly.
func CosTransformCBF16(in, out []hwy.BFloat16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	costransform_c_bf16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// CosTransformCF32 computes CosTransform using NEON SIMD assembly.
func CosTransformCF32(in, out []float32) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	costransform_c_f32_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// CosTransformCF64 computes CosTransform using NEON SIMD assembly.
func CosTransformCF64(in, out []float64) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	costransform_c_f64_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// TanhTransformCF16 computes TanhTransform using NEON SIMD assembly.
func TanhTransformCF16(in, out []hwy.Float16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	tanhtransform_c_f16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// TanhTransformCBF16 computes TanhTransform using NEON SIMD assembly.
func TanhTransformCBF16(in, out []hwy.BFloat16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	tanhtransform_c_bf16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// TanhTransformCF32 computes TanhTransform using NEON SIMD assembly.
func TanhTransformCF32(in, out []float32) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	tanhtransform_c_f32_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// TanhTransformCF64 computes TanhTransform using NEON SIMD assembly.
func TanhTransformCF64(in, out []float64) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	tanhtransform_c_f64_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SigmoidTransformCF16 computes SigmoidTransform using NEON SIMD assembly.
func SigmoidTransformCF16(in, out []hwy.Float16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sigmoidtransform_c_f16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SigmoidTransformCBF16 computes SigmoidTransform using NEON SIMD assembly.
func SigmoidTransformCBF16(in, out []hwy.BFloat16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sigmoidtransform_c_bf16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SigmoidTransformCF32 computes SigmoidTransform using NEON SIMD assembly.
func SigmoidTransformCF32(in, out []float32) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sigmoidtransform_c_f32_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// SigmoidTransformCF64 computes SigmoidTransform using NEON SIMD assembly.
func SigmoidTransformCF64(in, out []float64) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	sigmoidtransform_c_f64_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// ErfTransformCF16 computes ErfTransform using NEON SIMD assembly.
func ErfTransformCF16(in, out []hwy.Float16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	erftransform_c_f16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// ErfTransformCBF16 computes ErfTransform using NEON SIMD assembly.
func ErfTransformCBF16(in, out []hwy.BFloat16) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	erftransform_c_bf16_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// ErfTransformCF32 computes ErfTransform using NEON SIMD assembly.
func ErfTransformCF32(in, out []float32) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	erftransform_c_f32_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

// ErfTransformCF64 computes ErfTransform using NEON SIMD assembly.
func ErfTransformCF64(in, out []float64) {
	if len(in) == 0 {
		return
	}
	var p_in unsafe.Pointer
	if len(in) > 0 {
		p_in = unsafe.Pointer(&in[0])
	}
	var p_out unsafe.Pointer
	if len(out) > 0 {
		p_out = unsafe.Pointer(&out[0])
	}
	lenVal := int64(len(in))
	erftransform_c_f64_neon(
		p_in,
		p_out,
		unsafe.Pointer(&lenVal),
	)
}

