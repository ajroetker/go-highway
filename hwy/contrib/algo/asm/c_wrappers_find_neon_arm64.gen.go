//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import "unsafe"

// Public wrapper functions
// AllCF32 computes BaseAll for entire arrays using NEON SIMD.
func AllCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	all_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AllCF64 computes BaseAll for entire arrays using NEON SIMD.
func AllCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	all_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AllCS32 computes BaseAll for entire arrays using NEON SIMD.
func AllCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	all_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AllCS64 computes BaseAll for entire arrays using NEON SIMD.
func AllCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	all_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AllCU32 computes BaseAll for entire arrays using NEON SIMD.
func AllCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	all_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AllCU64 computes BaseAll for entire arrays using NEON SIMD.
func AllCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	all_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AnyCF32 computes BaseAny for entire arrays using NEON SIMD.
func AnyCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	any_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AnyCF64 computes BaseAny for entire arrays using NEON SIMD.
func AnyCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	any_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AnyCS32 computes BaseAny for entire arrays using NEON SIMD.
func AnyCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	any_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AnyCS64 computes BaseAny for entire arrays using NEON SIMD.
func AnyCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	any_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AnyCU32 computes BaseAny for entire arrays using NEON SIMD.
func AnyCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	any_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AnyCU64 computes BaseAny for entire arrays using NEON SIMD.
func AnyCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	any_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// FindIfCF32 computes BaseFindIf for entire arrays using NEON SIMD.
func FindIfCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	findif_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// FindIfCF64 computes BaseFindIf for entire arrays using NEON SIMD.
func FindIfCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	findif_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// FindIfCS32 computes BaseFindIf for entire arrays using NEON SIMD.
func FindIfCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	findif_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// FindIfCS64 computes BaseFindIf for entire arrays using NEON SIMD.
func FindIfCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	findif_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// FindIfCU32 computes BaseFindIf for entire arrays using NEON SIMD.
func FindIfCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	findif_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// FindIfCU64 computes BaseFindIf for entire arrays using NEON SIMD.
func FindIfCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	findif_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// CountIfCF32 computes BaseCountIf for entire arrays using NEON SIMD.
func CountIfCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	countif_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// CountIfCF64 computes BaseCountIf for entire arrays using NEON SIMD.
func CountIfCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	countif_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// CountIfCS32 computes BaseCountIf for entire arrays using NEON SIMD.
func CountIfCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	countif_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// CountIfCS64 computes BaseCountIf for entire arrays using NEON SIMD.
func CountIfCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	countif_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// CountIfCU32 computes BaseCountIf for entire arrays using NEON SIMD.
func CountIfCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	countif_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// CountIfCU64 computes BaseCountIf for entire arrays using NEON SIMD.
func CountIfCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	countif_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// FindCF32 computes Find using NEON SIMD assembly.
func FindCF32(slice []float32, value float32) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	find_c_f32_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// FindCF64 computes Find using NEON SIMD assembly.
func FindCF64(slice []float64, value float64) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	find_c_f64_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// FindCS32 computes Find using NEON SIMD assembly.
func FindCS32(slice []int32, value int32) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	find_c_s32_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// FindCS64 computes Find using NEON SIMD assembly.
func FindCS64(slice []int64, value int64) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	find_c_s64_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// FindCU32 computes Find using NEON SIMD assembly.
func FindCU32(slice []uint32, value uint32) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	find_c_u32_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// FindCU64 computes Find using NEON SIMD assembly.
func FindCU64(slice []uint64, value uint64) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	find_c_u64_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// CountCF32 computes Count using NEON SIMD assembly.
func CountCF32(slice []float32, value float32) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	count_c_f32_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// CountCF64 computes Count using NEON SIMD assembly.
func CountCF64(slice []float64, value float64) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	count_c_f64_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// CountCS32 computes Count using NEON SIMD assembly.
func CountCS32(slice []int32, value int32) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	count_c_s32_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// CountCS64 computes Count using NEON SIMD assembly.
func CountCS64(slice []int64, value int64) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	count_c_s64_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// CountCU32 computes Count using NEON SIMD assembly.
func CountCU32(slice []uint32, value uint32) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	count_c_u32_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// CountCU64 computes Count using NEON SIMD assembly.
func CountCU64(slice []uint64, value uint64) int {
	if len(slice) == 0 {
		return 0
	}
	var p_slice unsafe.Pointer
	if len(slice) > 0 {
		p_slice = unsafe.Pointer(&slice[0])
	}
	valueVal := value
	lenVal := int64(len(slice))
	var out_result int64
	count_c_u64_neon(
		p_slice,
		unsafe.Pointer(&valueVal),
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

