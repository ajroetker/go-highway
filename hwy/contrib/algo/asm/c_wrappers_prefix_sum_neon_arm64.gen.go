//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import "unsafe"

// Public wrapper functions
// PrefixSumVecCF32 computes BasePrefixSumVec for entire arrays using NEON SIMD.
func PrefixSumVecCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsumvec_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumVecCF64 computes BasePrefixSumVec for entire arrays using NEON SIMD.
func PrefixSumVecCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsumvec_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumVecCS32 computes BasePrefixSumVec for entire arrays using NEON SIMD.
func PrefixSumVecCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsumvec_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumVecCS64 computes BasePrefixSumVec for entire arrays using NEON SIMD.
func PrefixSumVecCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsumvec_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumVecCU32 computes BasePrefixSumVec for entire arrays using NEON SIMD.
func PrefixSumVecCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsumvec_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumVecCU64 computes BasePrefixSumVec for entire arrays using NEON SIMD.
func PrefixSumVecCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsumvec_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumCF32 computes BasePrefixSum for entire arrays using NEON SIMD.
func PrefixSumCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsum_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumCF64 computes BasePrefixSum for entire arrays using NEON SIMD.
func PrefixSumCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsum_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumCS32 computes BasePrefixSum for entire arrays using NEON SIMD.
func PrefixSumCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsum_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumCS64 computes BasePrefixSum for entire arrays using NEON SIMD.
func PrefixSumCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsum_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumCU32 computes BasePrefixSum for entire arrays using NEON SIMD.
func PrefixSumCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsum_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// PrefixSumCU64 computes BasePrefixSum for entire arrays using NEON SIMD.
func PrefixSumCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	prefixsum_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeltaDecodeCS32 computes BaseDeltaDecode for entire arrays using NEON SIMD.
func DeltaDecodeCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deltadecode_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeltaDecodeCS64 computes BaseDeltaDecode for entire arrays using NEON SIMD.
func DeltaDecodeCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deltadecode_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeltaDecodeCU32 computes BaseDeltaDecode for entire arrays using NEON SIMD.
func DeltaDecodeCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deltadecode_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeltaDecodeCU64 computes BaseDeltaDecode for entire arrays using NEON SIMD.
func DeltaDecodeCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deltadecode_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

