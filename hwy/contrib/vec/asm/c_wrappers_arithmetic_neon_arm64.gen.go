//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import "unsafe"

// Public wrapper functions
// AddCF16 computes BaseAdd for entire arrays using NEON SIMD.
func AddCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	add_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddCBF16 computes BaseAdd for entire arrays using NEON SIMD.
func AddCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	add_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddCF32 computes BaseAdd for entire arrays using NEON SIMD.
func AddCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	add_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddCF64 computes BaseAdd for entire arrays using NEON SIMD.
func AddCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	add_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddToCF16 computes BaseAddTo for entire arrays using NEON SIMD.
func AddToCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addto_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddToCBF16 computes BaseAddTo for entire arrays using NEON SIMD.
func AddToCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addto_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddToCF32 computes BaseAddTo for entire arrays using NEON SIMD.
func AddToCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addto_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddToCF64 computes BaseAddTo for entire arrays using NEON SIMD.
func AddToCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addto_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubCF16 computes BaseSub for entire arrays using NEON SIMD.
func SubCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sub_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubCBF16 computes BaseSub for entire arrays using NEON SIMD.
func SubCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sub_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubCF32 computes BaseSub for entire arrays using NEON SIMD.
func SubCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sub_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubCF64 computes BaseSub for entire arrays using NEON SIMD.
func SubCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sub_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubToCF16 computes BaseSubTo for entire arrays using NEON SIMD.
func SubToCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	subto_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubToCBF16 computes BaseSubTo for entire arrays using NEON SIMD.
func SubToCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	subto_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubToCF32 computes BaseSubTo for entire arrays using NEON SIMD.
func SubToCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	subto_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SubToCF64 computes BaseSubTo for entire arrays using NEON SIMD.
func SubToCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	subto_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulCF16 computes BaseMul for entire arrays using NEON SIMD.
func MulCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mul_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulCBF16 computes BaseMul for entire arrays using NEON SIMD.
func MulCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mul_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulCF32 computes BaseMul for entire arrays using NEON SIMD.
func MulCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mul_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulCF64 computes BaseMul for entire arrays using NEON SIMD.
func MulCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mul_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulToCF16 computes BaseMulTo for entire arrays using NEON SIMD.
func MulToCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	multo_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulToCBF16 computes BaseMulTo for entire arrays using NEON SIMD.
func MulToCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	multo_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulToCF32 computes BaseMulTo for entire arrays using NEON SIMD.
func MulToCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	multo_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulToCF64 computes BaseMulTo for entire arrays using NEON SIMD.
func MulToCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	multo_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivCF16 computes BaseDiv for entire arrays using NEON SIMD.
func DivCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	div_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivCBF16 computes BaseDiv for entire arrays using NEON SIMD.
func DivCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	div_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivCF32 computes BaseDiv for entire arrays using NEON SIMD.
func DivCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	div_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivCF64 computes BaseDiv for entire arrays using NEON SIMD.
func DivCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	div_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivToCF16 computes BaseDivTo for entire arrays using NEON SIMD.
func DivToCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	divto_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivToCBF16 computes BaseDivTo for entire arrays using NEON SIMD.
func DivToCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	divto_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivToCF32 computes BaseDivTo for entire arrays using NEON SIMD.
func DivToCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	divto_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DivToCF64 computes BaseDivTo for entire arrays using NEON SIMD.
func DivToCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	divto_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleCF16 computes BaseScale for entire arrays using NEON SIMD.
func ScaleCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scale_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleCBF16 computes BaseScale for entire arrays using NEON SIMD.
func ScaleCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scale_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleCF32 computes BaseScale for entire arrays using NEON SIMD.
func ScaleCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scale_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleCF64 computes BaseScale for entire arrays using NEON SIMD.
func ScaleCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scale_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleToCF16 computes BaseScaleTo for entire arrays using NEON SIMD.
func ScaleToCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scaleto_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleToCBF16 computes BaseScaleTo for entire arrays using NEON SIMD.
func ScaleToCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scaleto_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleToCF32 computes BaseScaleTo for entire arrays using NEON SIMD.
func ScaleToCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scaleto_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// ScaleToCF64 computes BaseScaleTo for entire arrays using NEON SIMD.
func ScaleToCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	scaleto_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddConstCF16 computes BaseAddConst for entire arrays using NEON SIMD.
func AddConstCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addconst_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddConstCBF16 computes BaseAddConst for entire arrays using NEON SIMD.
func AddConstCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addconst_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddConstCF32 computes BaseAddConst for entire arrays using NEON SIMD.
func AddConstCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addconst_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// AddConstCF64 computes BaseAddConst for entire arrays using NEON SIMD.
func AddConstCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	addconst_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulConstAddToCF16 computes BaseMulConstAddTo for entire arrays using NEON SIMD.
func MulConstAddToCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mulconstaddto_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulConstAddToCBF16 computes BaseMulConstAddTo for entire arrays using NEON SIMD.
func MulConstAddToCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mulconstaddto_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulConstAddToCF32 computes BaseMulConstAddTo for entire arrays using NEON SIMD.
func MulConstAddToCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mulconstaddto_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MulConstAddToCF64 computes BaseMulConstAddTo for entire arrays using NEON SIMD.
func MulConstAddToCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	mulconstaddto_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

