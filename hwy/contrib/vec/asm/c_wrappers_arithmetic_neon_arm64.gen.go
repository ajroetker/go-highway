//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// AddCF16 computes Add using NEON SIMD assembly.
func AddCF16(dst, s []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	add_c_f16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// AddCBF16 computes Add using NEON SIMD assembly.
func AddCBF16(dst, s []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	add_c_bf16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// AddCF32 computes Add using NEON SIMD assembly.
func AddCF32(dst, s []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	add_c_f32_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// AddCF64 computes Add using NEON SIMD assembly.
func AddCF64(dst, s []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	add_c_f64_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// AddConstCF16 computes AddConst using NEON SIMD assembly.
func AddConstCF16(c hwy.Float16, dst []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := uint16(c)
	lenVal := int64(len(dst))
	addconst_c_f16_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// AddConstCBF16 computes AddConst using NEON SIMD assembly.
func AddConstCBF16(c hwy.BFloat16, dst []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := uint16(c)
	lenVal := int64(len(dst))
	addconst_c_bf16_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// AddConstCF32 computes AddConst using NEON SIMD assembly.
func AddConstCF32(c float32, dst []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := c
	lenVal := int64(len(dst))
	addconst_c_f32_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// AddConstCF64 computes AddConst using NEON SIMD assembly.
func AddConstCF64(c float64, dst []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := c
	lenVal := int64(len(dst))
	addconst_c_f64_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// AddToCF16 computes AddTo using NEON SIMD assembly.
func AddToCF16(dst, a, b []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	addto_c_f16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// AddToCBF16 computes AddTo using NEON SIMD assembly.
func AddToCBF16(dst, a, b []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	addto_c_bf16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// AddToCF32 computes AddTo using NEON SIMD assembly.
func AddToCF32(dst, a, b []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	addto_c_f32_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// AddToCF64 computes AddTo using NEON SIMD assembly.
func AddToCF64(dst, a, b []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	addto_c_f64_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// DivCF16 computes Div using NEON SIMD assembly.
func DivCF16(dst, s []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	div_c_f16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// DivCBF16 computes Div using NEON SIMD assembly.
func DivCBF16(dst, s []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	div_c_bf16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// DivCF32 computes Div using NEON SIMD assembly.
func DivCF32(dst, s []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	div_c_f32_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// DivCF64 computes Div using NEON SIMD assembly.
func DivCF64(dst, s []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	div_c_f64_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// DivToCF16 computes DivTo using NEON SIMD assembly.
func DivToCF16(dst, a, b []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	divto_c_f16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// DivToCBF16 computes DivTo using NEON SIMD assembly.
func DivToCBF16(dst, a, b []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	divto_c_bf16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// DivToCF32 computes DivTo using NEON SIMD assembly.
func DivToCF32(dst, a, b []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	divto_c_f32_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// DivToCF64 computes DivTo using NEON SIMD assembly.
func DivToCF64(dst, a, b []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	divto_c_f64_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// MulCF16 computes Mul using NEON SIMD assembly.
func MulCF16(dst, s []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	mul_c_f16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// MulCBF16 computes Mul using NEON SIMD assembly.
func MulCBF16(dst, s []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	mul_c_bf16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// MulCF32 computes Mul using NEON SIMD assembly.
func MulCF32(dst, s []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	mul_c_f32_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// MulCF64 computes Mul using NEON SIMD assembly.
func MulCF64(dst, s []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	mul_c_f64_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// MulConstAddToCF16 computes MulConstAddTo using NEON SIMD assembly.
func MulConstAddToCF16(dst []hwy.Float16, a hwy.Float16, x []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	aVal := uint16(a)
	lenVal := int64(len(dst))
	mulconstaddto_c_f16_neon(
		p_dst,
		unsafe.Pointer(&aVal),
		p_x,
		unsafe.Pointer(&lenVal),
	)
}

// MulConstAddToCBF16 computes MulConstAddTo using NEON SIMD assembly.
func MulConstAddToCBF16(dst []hwy.BFloat16, a hwy.BFloat16, x []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	aVal := uint16(a)
	lenVal := int64(len(dst))
	mulconstaddto_c_bf16_neon(
		p_dst,
		unsafe.Pointer(&aVal),
		p_x,
		unsafe.Pointer(&lenVal),
	)
}

// MulConstAddToCF32 computes MulConstAddTo using NEON SIMD assembly.
func MulConstAddToCF32(dst []float32, a float32, x []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	aVal := a
	lenVal := int64(len(dst))
	mulconstaddto_c_f32_neon(
		p_dst,
		unsafe.Pointer(&aVal),
		p_x,
		unsafe.Pointer(&lenVal),
	)
}

// MulConstAddToCF64 computes MulConstAddTo using NEON SIMD assembly.
func MulConstAddToCF64(dst []float64, a float64, x []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_x unsafe.Pointer
	if len(x) > 0 {
		p_x = unsafe.Pointer(&x[0])
	}
	aVal := a
	lenVal := int64(len(dst))
	mulconstaddto_c_f64_neon(
		p_dst,
		unsafe.Pointer(&aVal),
		p_x,
		unsafe.Pointer(&lenVal),
	)
}

// MulToCF16 computes MulTo using NEON SIMD assembly.
func MulToCF16(dst, a, b []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	multo_c_f16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// MulToCBF16 computes MulTo using NEON SIMD assembly.
func MulToCBF16(dst, a, b []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	multo_c_bf16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// MulToCF32 computes MulTo using NEON SIMD assembly.
func MulToCF32(dst, a, b []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	multo_c_f32_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// MulToCF64 computes MulTo using NEON SIMD assembly.
func MulToCF64(dst, a, b []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	multo_c_f64_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleCF16 computes Scale using NEON SIMD assembly.
func ScaleCF16(c hwy.Float16, dst []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := uint16(c)
	lenVal := int64(len(dst))
	scale_c_f16_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleCBF16 computes Scale using NEON SIMD assembly.
func ScaleCBF16(c hwy.BFloat16, dst []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := uint16(c)
	lenVal := int64(len(dst))
	scale_c_bf16_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleCF32 computes Scale using NEON SIMD assembly.
func ScaleCF32(c float32, dst []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := c
	lenVal := int64(len(dst))
	scale_c_f32_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleCF64 computes Scale using NEON SIMD assembly.
func ScaleCF64(c float64, dst []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	cVal := c
	lenVal := int64(len(dst))
	scale_c_f64_neon(
		unsafe.Pointer(&cVal),
		p_dst,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleToCF16 computes ScaleTo using NEON SIMD assembly.
func ScaleToCF16(dst []hwy.Float16, c hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	cVal := uint16(c)
	lenVal := int64(len(dst))
	scaleto_c_f16_neon(
		p_dst,
		unsafe.Pointer(&cVal),
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleToCBF16 computes ScaleTo using NEON SIMD assembly.
func ScaleToCBF16(dst []hwy.BFloat16, c hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	cVal := uint16(c)
	lenVal := int64(len(dst))
	scaleto_c_bf16_neon(
		p_dst,
		unsafe.Pointer(&cVal),
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleToCF32 computes ScaleTo using NEON SIMD assembly.
func ScaleToCF32(dst []float32, c float32, s []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	cVal := c
	lenVal := int64(len(dst))
	scaleto_c_f32_neon(
		p_dst,
		unsafe.Pointer(&cVal),
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// ScaleToCF64 computes ScaleTo using NEON SIMD assembly.
func ScaleToCF64(dst []float64, c float64, s []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	cVal := c
	lenVal := int64(len(dst))
	scaleto_c_f64_neon(
		p_dst,
		unsafe.Pointer(&cVal),
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// SubCF16 computes Sub using NEON SIMD assembly.
func SubCF16(dst, s []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	sub_c_f16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// SubCBF16 computes Sub using NEON SIMD assembly.
func SubCBF16(dst, s []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	sub_c_bf16_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// SubCF32 computes Sub using NEON SIMD assembly.
func SubCF32(dst, s []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	sub_c_f32_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// SubCF64 computes Sub using NEON SIMD assembly.
func SubCF64(dst, s []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_s unsafe.Pointer
	if len(s) > 0 {
		p_s = unsafe.Pointer(&s[0])
	}
	lenVal := int64(len(dst))
	sub_c_f64_neon(
		p_dst,
		p_s,
		unsafe.Pointer(&lenVal),
	)
}

// SubToCF16 computes SubTo using NEON SIMD assembly.
func SubToCF16(dst, a, b []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	subto_c_f16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// SubToCBF16 computes SubTo using NEON SIMD assembly.
func SubToCBF16(dst, a, b []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	subto_c_bf16_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// SubToCF32 computes SubTo using NEON SIMD assembly.
func SubToCF32(dst, a, b []float32) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	subto_c_f32_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

// SubToCF64 computes SubTo using NEON SIMD assembly.
func SubToCF64(dst, a, b []float64) {
	if len(dst) == 0 {
		return
	}
	var p_dst unsafe.Pointer
	if len(dst) > 0 {
		p_dst = unsafe.Pointer(&dst[0])
	}
	var p_a unsafe.Pointer
	if len(a) > 0 {
		p_a = unsafe.Pointer(&a[0])
	}
	var p_b unsafe.Pointer
	if len(b) > 0 {
		p_b = unsafe.Pointer(&b[0])
	}
	lenVal := int64(len(dst))
	subto_c_f64_neon(
		p_dst,
		p_a,
		p_b,
		unsafe.Pointer(&lenVal),
	)
}

