//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// ArgmaxCF16 computes Argmax using NEON SIMD assembly.
func ArgmaxCF16(v []hwy.Float16) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmax_c_f16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// ArgmaxCBF16 computes Argmax using NEON SIMD assembly.
func ArgmaxCBF16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmax_c_bf16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// ArgmaxCF32 computes Argmax using NEON SIMD assembly.
func ArgmaxCF32(v []float32) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmax_c_f32_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// ArgmaxCF64 computes Argmax using NEON SIMD assembly.
func ArgmaxCF64(v []float64) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmax_c_f64_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// ArgminCF16 computes Argmin using NEON SIMD assembly.
func ArgminCF16(v []hwy.Float16) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmin_c_f16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// ArgminCBF16 computes Argmin using NEON SIMD assembly.
func ArgminCBF16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmin_c_bf16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// ArgminCF32 computes Argmin using NEON SIMD assembly.
func ArgminCF32(v []float32) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmin_c_f32_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

// ArgminCF64 computes Argmin using NEON SIMD assembly.
func ArgminCF64(v []float64) int {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	argmin_c_f64_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

