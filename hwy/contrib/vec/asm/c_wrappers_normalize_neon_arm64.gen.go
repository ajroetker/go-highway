//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import "unsafe"

// Public wrapper functions
// NormalizeCF16 computes BaseNormalize for entire arrays using NEON SIMD.
func NormalizeCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalize_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// NormalizeCBF16 computes BaseNormalize for entire arrays using NEON SIMD.
func NormalizeCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalize_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// NormalizeCF32 computes BaseNormalize for entire arrays using NEON SIMD.
func NormalizeCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalize_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// NormalizeCF64 computes BaseNormalize for entire arrays using NEON SIMD.
func NormalizeCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalize_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// NormalizeToCF16 computes BaseNormalizeTo for entire arrays using NEON SIMD.
func NormalizeToCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalizeto_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// NormalizeToCBF16 computes BaseNormalizeTo for entire arrays using NEON SIMD.
func NormalizeToCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalizeto_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// NormalizeToCF32 computes BaseNormalizeTo for entire arrays using NEON SIMD.
func NormalizeToCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalizeto_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// NormalizeToCF64 computes BaseNormalizeTo for entire arrays using NEON SIMD.
func NormalizeToCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	normalizeto_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

