//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import "unsafe"

// Public wrapper functions
// EncodeFloat32sCU8 computes BaseEncodeFloat32s for entire arrays using NEON SIMD.
func EncodeFloat32sCU8(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	encodefloat32s_c_u8_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DecodeFloat32sCF32 computes BaseDecodeFloat32s for entire arrays using NEON SIMD.
func DecodeFloat32sCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	decodefloat32s_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// EncodeFloat64sCU8 computes BaseEncodeFloat64s for entire arrays using NEON SIMD.
func EncodeFloat64sCU8(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	encodefloat64s_c_u8_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DecodeFloat64sCF64 computes BaseDecodeFloat64s for entire arrays using NEON SIMD.
func DecodeFloat64sCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	decodefloat64s_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

