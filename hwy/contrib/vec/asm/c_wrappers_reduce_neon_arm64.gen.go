//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// SumCF16 computes BaseSum for entire arrays using NEON SIMD.
func SumCF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sum_c_f16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SumCBF16 computes BaseSum for entire arrays using NEON SIMD.
func SumCBF16(input []uint16) []uint16 {
	result := make([]uint16, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sum_c_bf16_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SumCF32 computes BaseSum for entire arrays using NEON SIMD.
func SumCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sum_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// SumCF64 computes BaseSum for entire arrays using NEON SIMD.
func SumCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	sum_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// MinCF16 computes Min using NEON SIMD assembly.
func MinCF16(v []hwy.Float16) hwy.Float16 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	min_c_f16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return hwy.Float16(out_result)
}

// MinCBF16 computes Min using NEON SIMD assembly.
func MinCBF16(v []hwy.BFloat16) hwy.BFloat16 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	min_c_bf16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return hwy.BFloat16(out_result)
}

// MinCF32 computes Min using NEON SIMD assembly.
func MinCF32(v []float32) float32 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	min_c_f32_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float32(out_result)
}

// MinCF64 computes Min using NEON SIMD assembly.
func MinCF64(v []float64) float64 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	min_c_f64_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float64(out_result)
}

// MaxCF32 computes Max using NEON SIMD assembly.
func MaxCF32(v []float32) float32 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	max_c_f32_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float32(out_result)
}

// MaxCF64 computes Max using NEON SIMD assembly.
func MaxCF64(v []float64) float64 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	max_c_f64_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float64(out_result)
}

// MaxCS32 computes Max using NEON SIMD assembly.
func MaxCS32(v []int32) int32 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	max_c_s32_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int32(out_result)
}

// MaxCS64 computes Max using NEON SIMD assembly.
func MaxCS64(v []int64) int64 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	max_c_s64_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int64(out_result)
}

// MaxCU32 computes Max using NEON SIMD assembly.
func MaxCU32(v []uint32) uint32 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	max_c_u32_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return uint32(out_result)
}

// MaxCU64 computes Max using NEON SIMD assembly.
func MaxCU64(v []uint64) uint64 {
	if len(v) == 0 {
		return 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	max_c_u64_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return uint64(out_result)
}

// MinMaxCF16 computes MinMax using NEON SIMD assembly.
func MinMaxCF16(v []hwy.Float16) (hwy.Float16, hwy.Float16) {
	if len(v) == 0 {
		return 0, 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal int64
	var out_maxVal int64
	minmax_c_f16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return hwy.Float16(out_minVal), hwy.Float16(out_maxVal)
}

// MinMaxCBF16 computes MinMax using NEON SIMD assembly.
func MinMaxCBF16(v []hwy.BFloat16) (hwy.BFloat16, hwy.BFloat16) {
	if len(v) == 0 {
		return 0, 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal int64
	var out_maxVal int64
	minmax_c_bf16_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return hwy.BFloat16(out_minVal), hwy.BFloat16(out_maxVal)
}

// MinMaxCF32 computes MinMax using NEON SIMD assembly.
func MinMaxCF32(v []float32) (float32, float32) {
	if len(v) == 0 {
		return 0, 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal int64
	var out_maxVal int64
	minmax_c_f32_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return float32(out_minVal), float32(out_maxVal)
}

// MinMaxCF64 computes MinMax using NEON SIMD assembly.
func MinMaxCF64(v []float64) (float64, float64) {
	if len(v) == 0 {
		return 0, 0
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal int64
	var out_maxVal int64
	minmax_c_f64_neon(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return float64(out_minVal), float64(out_maxVal)
}

