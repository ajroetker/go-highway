//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package vec

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/vec/asm"
)

func init() {
	initReduceNeonCAsm()
}

func initReduceNeonCAsm() {
	if hwy.NoSimdEnv() {
		return
	}
	SumFloat32 = sumAsmF32
	SumFloat64 = sumAsmF64
	MinFloat32 = minAsmF32
	MinFloat64 = minAsmF64
	MaxFloat32 = maxAsmF32
	MaxFloat64 = maxAsmF64
	MaxInt32 = maxAsmS32
	MaxInt64 = maxAsmS64
	MaxUint32 = maxAsmU32
	MaxUint64 = maxAsmU64
	MinMaxFloat32 = minMaxAsmF32
	MinMaxFloat64 = minMaxAsmF64
	if hwy.HasARMFP16() {
		SumFloat16 = sumAsmF16
		MinFloat16 = minAsmF16
		MinMaxFloat16 = minMaxAsmF16
	}
	if hwy.HasARMBF16() {
		SumBFloat16 = sumAsmBF16
		MinBFloat16 = minAsmBF16
		MinMaxBFloat16 = minMaxAsmBF16
	}
}

func sumAsmF16(v []hwy.Float16) hwy.Float16 {
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Sum_F16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return hwy.Float16(out_result)
}

func sumAsmBF16(v []hwy.BFloat16) hwy.BFloat16 {
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Sum_BF16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return hwy.BFloat16(out_result)
}

func sumAsmF32(v []float32) float32 {
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result float32
	asm.Sum_F32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float32(out_result)
}

func sumAsmF64(v []float64) float64 {
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result float64
	asm.Sum_F64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float64(out_result)
}

func minAsmF16(v []hwy.Float16) hwy.Float16 {
	if len(v) == 0 {
		panic("vec: Min called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Min_F16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return hwy.Float16(out_result)
}

func minAsmBF16(v []hwy.BFloat16) hwy.BFloat16 {
	if len(v) == 0 {
		panic("vec: Min called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Min_BF16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return hwy.BFloat16(out_result)
}

func minAsmF32(v []float32) float32 {
	if len(v) == 0 {
		panic("vec: Min called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result float32
	asm.Min_F32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float32(out_result)
}

func minAsmF64(v []float64) float64 {
	if len(v) == 0 {
		panic("vec: Min called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result float64
	asm.Min_F64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float64(out_result)
}

func maxAsmF32(v []float32) float32 {
	if len(v) == 0 {
		panic("vec: Max called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result float32
	asm.Max_F32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float32(out_result)
}

func maxAsmF64(v []float64) float64 {
	if len(v) == 0 {
		panic("vec: Max called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result float64
	asm.Max_F64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return float64(out_result)
}

func maxAsmS32(v []int32) int32 {
	if len(v) == 0 {
		panic("vec: Max called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Max_S32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int32(out_result)
}

func maxAsmS64(v []int64) int64 {
	if len(v) == 0 {
		panic("vec: Max called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Max_S64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int64(out_result)
}

func maxAsmU32(v []uint32) uint32 {
	if len(v) == 0 {
		panic("vec: Max called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Max_U32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return uint32(out_result)
}

func maxAsmU64(v []uint64) uint64 {
	if len(v) == 0 {
		panic("vec: Max called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Max_U64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return uint64(out_result)
}

func minMaxAsmF16(v []hwy.Float16) (hwy.Float16, hwy.Float16) {
	if len(v) == 0 {
		panic("vec: MinMax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal int64
	var out_maxVal int64
	asm.MinMax_F16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return hwy.Float16(out_minVal), hwy.Float16(out_maxVal)
}

func minMaxAsmBF16(v []hwy.BFloat16) (hwy.BFloat16, hwy.BFloat16) {
	if len(v) == 0 {
		panic("vec: MinMax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal int64
	var out_maxVal int64
	asm.MinMax_BF16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return hwy.BFloat16(out_minVal), hwy.BFloat16(out_maxVal)
}

func minMaxAsmF32(v []float32) (float32, float32) {
	if len(v) == 0 {
		panic("vec: MinMax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal float32
	var out_maxVal float32
	asm.MinMax_F32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return float32(out_minVal), float32(out_maxVal)
}

func minMaxAsmF64(v []float64) (float64, float64) {
	if len(v) == 0 {
		panic("vec: MinMax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_minVal float64
	var out_maxVal float64
	asm.MinMax_F64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_minVal),
		unsafe.Pointer(&out_maxVal),
	)
	return float64(out_minVal), float64(out_maxVal)
}

