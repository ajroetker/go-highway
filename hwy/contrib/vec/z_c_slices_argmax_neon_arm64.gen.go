//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package vec

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/vec/asm"
)

func init() {
	initArgmaxNeonCAsm()
}

func initArgmaxNeonCAsm() {
	if hwy.NoSimdEnv() {
		return
	}
	ArgmaxFloat32 = argmaxAsmF32
	ArgmaxFloat64 = argmaxAsmF64
	ArgminFloat32 = argminAsmF32
	ArgminFloat64 = argminAsmF64
	if hwy.HasARMFP16() {
		ArgmaxFloat16 = argmaxAsmF16
		ArgminFloat16 = argminAsmF16
	}
	if hwy.HasARMBF16() {
		ArgmaxBFloat16 = argmaxAsmBF16
		ArgminBFloat16 = argminAsmBF16
	}
}

func argmaxAsmF16(v []hwy.Float16) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmax_F16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

func argmaxAsmBF16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmax_BF16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

func argmaxAsmF32(v []float32) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmax_F32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

func argmaxAsmF64(v []float64) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmax_F64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

func argminAsmF16(v []hwy.Float16) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmin_F16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

func argminAsmBF16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmin_BF16(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

func argminAsmF32(v []float32) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmin_F32(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

func argminAsmF64(v []float64) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	var p_v unsafe.Pointer
	if len(v) > 0 {
		p_v = unsafe.Pointer(&v[0])
	}
	lenVal := int64(len(v))
	var out_result int64
	asm.Argmin_F64(
		p_v,
		unsafe.Pointer(&lenVal),
		unsafe.Pointer(&out_result),
	)
	return int(out_result)
}

