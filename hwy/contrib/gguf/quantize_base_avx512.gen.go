// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package gguf

import (
	stdmath "math"
	"simd/archsimd"
	"sync"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Hoisted constants - lazily initialized on first use to avoid init-time crashes
var (
	BaseQuantizeQ8_0_AVX512_maxVec_f32 archsimd.Float32x16
	BaseQuantizeQ8_0_AVX512_minVec_f32 archsimd.Float32x16
	_quantizeBaseHoistOnce             sync.Once
)

func _quantizeBaseInitHoistedConstants() {
	_quantizeBaseHoistOnce.Do(func() {
		BaseQuantizeQ8_0_AVX512_maxVec_f32 = archsimd.BroadcastFloat32x16(127.0)
		BaseQuantizeQ8_0_AVX512_minVec_f32 = archsimd.BroadcastFloat32x16(-128.0)
	})
}

func BaseQuantizeQ8_0_avx512(input []float32, output []uint8) {
	_quantizeBaseInitHoistedConstants()
	if len(input) == 0 {
		return
	}
	nblocks := len(input) / QK
	lanes := 16
	buf := [16]float32{}
	minVec := BaseQuantizeQ8_0_AVX512_minVec_f32
	maxVec := BaseQuantizeQ8_0_AVX512_maxVec_f32
	for b := range nblocks {
		inOff := b * QK
		outOff := b * BlockSizeQ8_0
		block := output[outOff : outOff+BlockSizeQ8_0]
		amax := float32(0)
		i := 0
		for ; i+lanes <= QK; i += lanes {
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[inOff+i])))
			absV := v.Max(archsimd.BroadcastFloat32x16(0).Sub(v))
			absV.Store((*[16]float32)(unsafe.Pointer(&buf[0])))
			for j := range lanes {
				if buf[j] > amax {
					amax = buf[j]
				}
			}
		}
		for ; i < QK; i++ {
			av := input[inOff+i]
			if av < 0 {
				av = -av
			}
			if av > amax {
				amax = av
			}
		}
		d := amax / 127.0
		var id float32
		if d > 0 {
			id = 127.0 / amax
		}
		f32bits := stdmath.Float32bits(d)
		f32sign := (f32bits >> 31) & 1
		f32exp := int((f32bits>>23)&0xFF) - 127
		f32mant := f32bits & 0x7FFFFF
		var fp16bits uint16
		if d == 0 {
			fp16bits = uint16(f32sign << 15)
		} else if f32exp > 15 {
			fp16bits = uint16((f32sign << 15) | (0x1F << 10))
		} else if f32exp < -14 {
			fp16bits = uint16(f32sign << 15)
		} else {
			fp16bits = uint16((f32sign << 15) | uint32(f32exp+15)<<10 | (f32mant >> 13))
		}
		block[0] = uint8(fp16bits)
		block[1] = uint8(fp16bits >> 8)
		qs := block[2:]
		i = 0
		idVec := archsimd.BroadcastFloat32x16(id)
		for ; i+lanes <= QK; i += lanes {
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[inOff+i])))
			scaled := v.Mul(idVec)
			clamped := hwy.Round_AVX512_F32x16(scaled).Max(minVec).Min(maxVec)
			clamped.Store((*[16]float32)(unsafe.Pointer(&buf[0])))
			for j := range lanes {
				qs[i+j] = uint8(int8(buf[j]))
			}
		}
		for ; i < QK; i++ {
			val := input[inOff+i] * id
			var q int32
			if val >= 0 {
				q = int32(val + 0.5)
			} else {
				q = int32(val - 0.5)
			}
			if q > 127 {
				q = 127
			} else if q < -128 {
				q = -128
			}
			qs[i] = uint8(int8(q))
		}
	}
}
