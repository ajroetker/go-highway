// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package gguf

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
)

func BaseQuantizeQ8_0_fallback(input []float32, output []uint8) {
	if len(input) == 0 {
		return
	}
	nblocks := len(input) / QK
	lanes := hwy.NumLanes[float32]()
	buf := make([]float32, lanes)
	minVec := hwy.Set[float32](-128.0)
	maxVec := hwy.Set[float32](127.0)
	for b := range nblocks {
		inOff := b * QK
		outOff := b * BlockSizeQ8_0
		block := output[outOff : outOff+BlockSizeQ8_0]
		amax := float32(0)
		i := 0
		for ; i+lanes <= QK; i += lanes {
			v := hwy.Load(input[inOff+i:])
			absV := hwy.Abs(v)
			hwy.Store(absV, buf)
			for j := range lanes {
				if buf[j] > amax {
					amax = buf[j]
				}
			}
		}
		for ; i < QK; i++ {
			av := input[inOff+i]
			if av < 0 {
				av = -av
			}
			if av > amax {
				amax = av
			}
		}
		d := amax / 127.0
		var id float32
		if d > 0 {
			id = 127.0 / amax
		}
		f32bits := stdmath.Float32bits(d)
		f32sign := (f32bits >> 31) & 1
		f32exp := int((f32bits>>23)&0xFF) - 127
		f32mant := f32bits & 0x7FFFFF
		var fp16bits uint16
		if d == 0 {
			fp16bits = uint16(f32sign << 15)
		} else if f32exp > 15 {
			fp16bits = uint16((f32sign << 15) | (0x1F << 10))
		} else if f32exp < -14 {
			fp16bits = uint16(f32sign << 15)
		} else {
			fp16bits = uint16((f32sign << 15) | uint32(f32exp+15)<<10 | (f32mant >> 13))
		}
		block[0] = uint8(fp16bits)
		block[1] = uint8(fp16bits >> 8)
		qs := block[2:]
		i = 0
		idVec := hwy.Set(id)
		for ; i+lanes <= QK; i += lanes {
			v := hwy.Load(input[inOff+i:])
			scaled := hwy.Mul(v, idVec)
			clamped := hwy.Clamp(hwy.Round(scaled), minVec, maxVec)
			hwy.Store(clamped, buf)
			for j := range lanes {
				qs[i+j] = uint8(int8(buf[j]))
			}
		}
		for ; i < QK; i++ {
			val := input[inOff+i] * id
			var q int32
			if val >= 0 {
				q = int32(val + 0.5)
			} else {
				q = int32(val - 0.5)
			}
			if q > 127 {
				q = 127
			} else if q < -128 {
				q = -128
			}
			qs[i] = uint8(int8(q))
		}
	}
}
