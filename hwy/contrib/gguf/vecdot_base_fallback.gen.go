// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package gguf

import (
	stdmath "math"
)

func BaseVecDotQ4_0Q8_0_fallback(wdata []uint8, adata []uint8, nblocks int) float32 {
	var sumf float32
	wbuf := make([]float32, 1)
	abuf := make([]float32, 1)
	for b := range nblocks {
		wb := wdata[b*BlockSizeQ4_0 : (b+1)*BlockSizeQ4_0]
		ab := adata[b*BlockSizeQ8_0 : (b+1)*BlockSizeQ8_0]
		raw := uint32(wb[0]) | uint32(wb[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var dw float32
		if exp == 0 {
			dw = stdmath.Float32frombits(sign << 31)
		} else {
			dw = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		raw = uint32(ab[0]) | uint32(ab[1])<<8
		sign = raw >> 15
		exp = (raw >> 10) & 0x1F
		mant = raw & 0x3FF
		var da float32
		if exp == 0 {
			da = stdmath.Float32frombits(sign << 31)
		} else {
			da = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		wqs := wb[2:]
		aqs := ab[2:]
		accVec := float32(0)
		i := 0
		for ; i < 16; i++ {
			for j := range 1 {
				wbuf[j] = float32(int(wqs[i+j]&0x0F) - 8)
				abuf[j] = float32(int8(aqs[i+j]))
			}
			wVec := wbuf[0]
			aVec := abuf[0]
			accVec = wVec*aVec + accVec
		}
		var tailSum float32
		for ; i < 16; i++ {
			tailSum += float32(int(wqs[i]&0x0F)-8) * float32(int8(aqs[i]))
		}
		i = 0
		for ; i < 16; i++ {
			for j := range 1 {
				wbuf[j] = float32(int((wqs[i+j]>>4)&0x0F) - 8)
				abuf[j] = float32(int8(aqs[16+i+j]))
			}
			wVec := wbuf[0]
			aVec := abuf[0]
			accVec = wVec*aVec + accVec
		}
		for ; i < 16; i++ {
			tailSum += float32(int((wqs[i]>>4)&0x0F)-8) * float32(int8(aqs[16+i]))
		}
		wbuf[0] = accVec
		blockSum := tailSum
		for j := range 1 {
			blockSum += wbuf[j]
		}
		sumf += dw * da * blockSum
	}
	return sumf
}

func BaseVecDotQ8_0Q8_0_fallback(wdata []uint8, adata []uint8, nblocks int) float32 {
	var sumf float32
	wbuf := make([]float32, 1)
	abuf := make([]float32, 1)
	for b := range nblocks {
		wb := wdata[b*BlockSizeQ8_0 : (b+1)*BlockSizeQ8_0]
		ab := adata[b*BlockSizeQ8_0 : (b+1)*BlockSizeQ8_0]
		raw := uint32(wb[0]) | uint32(wb[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var dw float32
		if exp == 0 {
			dw = stdmath.Float32frombits(sign << 31)
		} else {
			dw = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		raw = uint32(ab[0]) | uint32(ab[1])<<8
		sign = raw >> 15
		exp = (raw >> 10) & 0x1F
		mant = raw & 0x3FF
		var da float32
		if exp == 0 {
			da = stdmath.Float32frombits(sign << 31)
		} else {
			da = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		wqs := wb[2:]
		aqs := ab[2:]
		accVec := float32(0)
		i := 0
		for ; i < QK; i++ {
			for j := range 1 {
				wbuf[j] = float32(int8(wqs[i+j]))
				abuf[j] = float32(int8(aqs[i+j]))
			}
			wVec := wbuf[0]
			aVec := abuf[0]
			accVec = wVec*aVec + accVec
		}
		wbuf[0] = accVec
		var blockSum float32
		for j := range 1 {
			blockSum += wbuf[j]
		}
		for ; i < QK; i++ {
			blockSum += float32(int8(wqs[i])) * float32(int8(aqs[i]))
		}
		sumf += dw * da * blockSum
	}
	return sumf
}
