// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package gguf

import (
	stdmath "math"
	"simd/archsimd"
	"unsafe"
)

func BaseDequantizeIQ4NL_avx2(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeIQ4NL
	var lut [16]float32
	lut[0] = -127
	lut[1] = -104
	lut[2] = -83
	lut[3] = -65
	lut[4] = -49
	lut[5] = -35
	lut[6] = -22
	lut[7] = -10
	lut[8] = 1
	lut[9] = 13
	lut[10] = 25
	lut[11] = 38
	lut[12] = 53
	lut[13] = 69
	lut[14] = 89
	lut[15] = 113
	lanes := 8
	buf := [8]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeIQ4NL : (b+1)*BlockSizeIQ4NL]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scaleVec := archsimd.BroadcastFloat32x8(d)
		qs := blockData[2:]
		outOff := b * QK
		i := 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				lo := qs[i+j] & 0x0F
				buf[j] = lut[lo]
			}
			v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[8]float32)(unsafe.Pointer(&output[outOff+i])))
		}
		for ; i < 16; i++ {
			lo := qs[i] & 0x0F
			output[outOff+i] = d * lut[lo]
		}
		i = 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				hi := (qs[i+j] >> 4) & 0x0F
				buf[j] = lut[hi]
			}
			v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[8]float32)(unsafe.Pointer(&output[outOff+16+i])))
		}
		for ; i < 16; i++ {
			hi := (qs[i] >> 4) & 0x0F
			output[outOff+16+i] = d * lut[hi]
		}
	}
}

func BaseDequantizeQ4_0_avx2(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ4_0
	lanes := 8
	buf := [8]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ4_0 : (b+1)*BlockSizeQ4_0]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scaleVec := archsimd.BroadcastFloat32x8(d)
		qs := blockData[2:]
		outOff := b * QK
		i := 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				lo := int(qs[i+j] & 0x0F)
				buf[j] = float32(lo - 8)
			}
			v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[8]float32)(unsafe.Pointer(&output[outOff+i])))
		}
		for ; i < 16; i++ {
			lo := int(qs[i] & 0x0F)
			output[outOff+i] = d * float32(lo-8)
		}
		i = 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				hi := int((qs[i+j] >> 4) & 0x0F)
				buf[j] = float32(hi - 8)
			}
			v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[8]float32)(unsafe.Pointer(&output[outOff+16+i])))
		}
		for ; i < 16; i++ {
			hi := int((qs[i] >> 4) & 0x0F)
			output[outOff+16+i] = d * float32(hi-8)
		}
	}
}

func BaseDequantizeQ8_0_avx2(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ8_0
	lanes := 8
	buf := [8]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ8_0 : (b+1)*BlockSizeQ8_0]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scaleVec := archsimd.BroadcastFloat32x8(d)
		qs := blockData[2:]
		outOff := b * QK
		i := 0
		for ; i+lanes <= QK; i += lanes {
			for j := range lanes {
				buf[j] = float32(int8(qs[i+j]))
			}
			v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[8]float32)(unsafe.Pointer(&output[outOff+i])))
		}
		for ; i < QK; i++ {
			output[outOff+i] = d * float32(int8(qs[i]))
		}
	}
}
