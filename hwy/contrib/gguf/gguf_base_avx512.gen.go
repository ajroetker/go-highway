// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package gguf

import (
	stdmath "math"
	"simd/archsimd"
	"unsafe"
)

func BaseDequantizeIQ4NL_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeIQ4NL
	var lut [16]float32
	lut[0] = -127
	lut[1] = -104
	lut[2] = -83
	lut[3] = -65
	lut[4] = -49
	lut[5] = -35
	lut[6] = -22
	lut[7] = -10
	lut[8] = 1
	lut[9] = 13
	lut[10] = 25
	lut[11] = 38
	lut[12] = 53
	lut[13] = 69
	lut[14] = 89
	lut[15] = 113
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeIQ4NL : (b+1)*BlockSizeIQ4NL]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scaleVec := archsimd.BroadcastFloat32x16(d)
		qs := blockData[2:]
		outOff := b * QK
		i := 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				lo := qs[i+j] & 0x0F
				buf[j] = lut[lo]
			}
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[16]float32)(unsafe.Pointer(&output[outOff+i])))
		}
		for ; i < 16; i++ {
			lo := qs[i] & 0x0F
			output[outOff+i] = d * lut[lo]
		}
		i = 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				hi := (qs[i+j] >> 4) & 0x0F
				buf[j] = lut[hi]
			}
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[16]float32)(unsafe.Pointer(&output[outOff+16+i])))
		}
		for ; i < 16; i++ {
			hi := (qs[i] >> 4) & 0x0F
			output[outOff+16+i] = d * lut[hi]
		}
	}
}

func BaseDequantizeQ2K_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ2K
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ2K : (b+1)*BlockSizeQ2K]
		scalesRaw := blockData[0:16]
		raw := uint32(blockData[16]) | uint32(blockData[17])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		raw = uint32(blockData[18]) | uint32(blockData[19])<<8
		sign = raw >> 15
		exp = (raw >> 10) & 0x1F
		mant = raw & 0x3FF
		var dmin float32
		if exp == 0 {
			dmin = stdmath.Float32frombits(sign << 31)
		} else {
			dmin = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		qs := blockData[20:84]
		outOff := b * QK_K
		for is := 0; is < 16; is++ {
			sc := float32(scalesRaw[is] & 0x0F)
			m := float32(scalesRaw[is] >> 4)
			dsc := d * sc
			dmm := dmin * m
			dscVec := archsimd.BroadcastFloat32x16(dsc)
			dmmVec := archsimd.BroadcastFloat32x16(dmm)
			baseOut := outOff + is*16
			chunk := is / 8
			group := (is % 8) / 2
			lBase := (is % 2) * 16
			qBase := chunk * 32
			shift := uint(group * 2)
			i := 0
			for ; i+lanes <= 16; i += lanes {
				for k := range lanes {
					buf[k] = float32((qs[qBase+lBase+i+k] >> shift) & 3)
				}
				v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
				scaled := v.Mul(dscVec)
				result := scaled.Sub(dmmVec)
				result.Store((*[16]float32)(unsafe.Pointer(&output[baseOut+i])))
			}
			for ; i < 16; i++ {
				output[baseOut+i] = dsc*float32((qs[qBase+lBase+i]>>shift)&3) - dmm
			}
		}
	}
}

func BaseDequantizeQ3K_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ3K
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ3K : (b+1)*BlockSizeQ3K]
		hmask := blockData[0:32]
		qs := blockData[32:96]
		scaleData := blockData[96:108]
		raw := uint32(blockData[108]) | uint32(blockData[109])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		outOff := b * QK_K
		var rawScales [16]int
		for i := 0; i < 4; i++ {
			rawScales[i] = int(scaleData[i]&0x0F) | (int(scaleData[8+i]&0x03) << 4)
			rawScales[i+4] = int(scaleData[4+i]&0x0F) | (int((scaleData[8+i]>>2)&0x03) << 4)
			rawScales[i+8] = int((scaleData[i]>>4)&0x0F) | (int((scaleData[8+i]>>4)&0x03) << 4)
			rawScales[i+12] = int((scaleData[4+i]>>4)&0x0F) | (int((scaleData[8+i]>>6)&0x03) << 4)
		}
		for j := 0; j < 16; j++ {
			scaleVal := d * float32(rawScales[j]-32)
			scaleVec := archsimd.BroadcastFloat32x16(scaleVal)
			baseOut := outOff + j*16
			chunk := j / 8
			group := (j % 8) / 2
			lBase := (j % 2) * 16
			qBase := chunk * 32
			shift := uint(group * 2)
			hmBit := uint(chunk*4 + group)
			i := 0
			for ; i+lanes <= 16; i += lanes {
				for k := range lanes {
					l := lBase + i + k
					low2 := int((qs[qBase+l] >> shift) & 3)
					high1 := int((hmask[l] >> hmBit) & 1)
					buf[k] = float32(low2 + high1*4 - 4)
				}
				v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
				result := v.Mul(scaleVec)
				result.Store((*[16]float32)(unsafe.Pointer(&output[baseOut+i])))
			}
			for ; i < 16; i++ {
				l := lBase + i
				low2 := int((qs[qBase+l] >> shift) & 3)
				high1 := int((hmask[l] >> hmBit) & 1)
				output[baseOut+i] = scaleVal * float32(low2+high1*4-4)
			}
		}
	}
}

func BaseDequantizeQ4K_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ4K
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ4K : (b+1)*BlockSizeQ4K]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		raw = uint32(blockData[2]) | uint32(blockData[3])<<8
		sign = raw >> 15
		exp = (raw >> 10) & 0x1F
		mant = raw & 0x3FF
		var dmin float32
		if exp == 0 {
			dmin = stdmath.Float32frombits(sign << 31)
		} else {
			dmin = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scales := blockData[4:16]
		qs := blockData[16:144]
		var scs [8]float32
		var mns [8]float32
		for j := 0; j < 4; j++ {
			scs[j] = float32(scales[j] & 63)
			mns[j] = float32(scales[j+4] & 63)
		}
		for j := 4; j < 8; j++ {
			scs[j] = float32((scales[j+4] & 0xF) | ((scales[j-4] >> 6) << 4))
			mns[j] = float32((scales[j+4] >> 4) | ((scales[j] >> 6) << 4))
		}
		outOff := b * QK_K
		qOff := 0
		outIdx := outOff
		for chunk := 0; chunk < 4; chunk++ {
			is := chunk * 2
			dsc0 := d * scs[is]
			dmm0 := dmin * mns[is]
			dsc1 := d * scs[is+1]
			dmm1 := dmin * mns[is+1]
			dscVec0 := archsimd.BroadcastFloat32x16(dsc0)
			dmmVec0 := archsimd.BroadcastFloat32x16(dmm0)
			dscVec1 := archsimd.BroadcastFloat32x16(dsc1)
			dmmVec1 := archsimd.BroadcastFloat32x16(dmm1)
			i := 0
			for ; i+lanes <= 32; i += lanes {
				for k := range lanes {
					buf[k] = float32(qs[qOff+i+k] & 0xF)
				}
				v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
				scaled := v.Mul(dscVec0)
				result := scaled.Sub(dmmVec0)
				result.Store((*[16]float32)(unsafe.Pointer(&output[outIdx+i])))
			}
			for ; i < 32; i++ {
				output[outIdx+i] = dsc0*float32(qs[qOff+i]&0xF) - dmm0
			}
			i = 0
			for ; i+lanes <= 32; i += lanes {
				for k := range lanes {
					buf[k] = float32(qs[qOff+i+k] >> 4)
				}
				v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
				scaled := v.Mul(dscVec1)
				result := scaled.Sub(dmmVec1)
				result.Store((*[16]float32)(unsafe.Pointer(&output[outIdx+32+i])))
			}
			for ; i < 32; i++ {
				output[outIdx+32+i] = dsc1*float32(qs[qOff+i]>>4) - dmm1
			}
			qOff += 32
			outIdx += 64
		}
	}
}

func BaseDequantizeQ4_0_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ4_0
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ4_0 : (b+1)*BlockSizeQ4_0]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scaleVec := archsimd.BroadcastFloat32x16(d)
		qs := blockData[2:]
		outOff := b * QK
		i := 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				lo := int(qs[i+j] & 0x0F)
				buf[j] = float32(lo - 8)
			}
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[16]float32)(unsafe.Pointer(&output[outOff+i])))
		}
		for ; i < 16; i++ {
			lo := int(qs[i] & 0x0F)
			output[outOff+i] = d * float32(lo-8)
		}
		i = 0
		for ; i+lanes <= 16; i += lanes {
			for j := range lanes {
				hi := int((qs[i+j] >> 4) & 0x0F)
				buf[j] = float32(hi - 8)
			}
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[16]float32)(unsafe.Pointer(&output[outOff+16+i])))
		}
		for ; i < 16; i++ {
			hi := int((qs[i] >> 4) & 0x0F)
			output[outOff+16+i] = d * float32(hi-8)
		}
	}
}

func BaseDequantizeQ5K_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ5K
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ5K : (b+1)*BlockSizeQ5K]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		raw = uint32(blockData[2]) | uint32(blockData[3])<<8
		sign = raw >> 15
		exp = (raw >> 10) & 0x1F
		mant = raw & 0x3FF
		var dmin float32
		if exp == 0 {
			dmin = stdmath.Float32frombits(sign << 31)
		} else {
			dmin = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scales := blockData[4:16]
		ql := blockData[16:144]
		qh := blockData[144:176]
		var scs [8]float32
		var mns [8]float32
		for j := 0; j < 4; j++ {
			scs[j] = float32(scales[j] & 63)
			mns[j] = float32(scales[j+4] & 63)
		}
		for j := 4; j < 8; j++ {
			scs[j] = float32((scales[j+4] & 0xF) | ((scales[j-4] >> 6) << 4))
			mns[j] = float32((scales[j+4] >> 4) | ((scales[j] >> 6) << 4))
		}
		outOff := b * QK_K
		qlOff := 0
		outIdx := outOff
		for chunk := 0; chunk < 4; chunk++ {
			is := chunk * 2
			dsc0 := d * scs[is]
			dmm0 := dmin * mns[is]
			dsc1 := d * scs[is+1]
			dmm1 := dmin * mns[is+1]
			dscVec0 := archsimd.BroadcastFloat32x16(dsc0)
			dmmVec0 := archsimd.BroadcastFloat32x16(dmm0)
			dscVec1 := archsimd.BroadcastFloat32x16(dsc1)
			dmmVec1 := archsimd.BroadcastFloat32x16(dmm1)
			hbShift0 := uint(chunk * 2)
			hbShift1 := uint(chunk*2 + 1)
			i := 0
			for ; i+lanes <= 32; i += lanes {
				for k := range lanes {
					l := i + k
					q := int(ql[qlOff+l]&0xF) + int((qh[l]>>hbShift0)&1)*16
					buf[k] = float32(q)
				}
				v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
				scaled := v.Mul(dscVec0)
				result := scaled.Sub(dmmVec0)
				result.Store((*[16]float32)(unsafe.Pointer(&output[outIdx+i])))
			}
			for ; i < 32; i++ {
				q := int(ql[qlOff+i]&0xF) + int((qh[i]>>hbShift0)&1)*16
				output[outIdx+i] = dsc0*float32(q) - dmm0
			}
			i = 0
			for ; i+lanes <= 32; i += lanes {
				for k := range lanes {
					l := i + k
					q := int(ql[qlOff+l]>>4) + int((qh[l]>>hbShift1)&1)*16
					buf[k] = float32(q)
				}
				v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
				scaled := v.Mul(dscVec1)
				result := scaled.Sub(dmmVec1)
				result.Store((*[16]float32)(unsafe.Pointer(&output[outIdx+32+i])))
			}
			for ; i < 32; i++ {
				q := int(ql[qlOff+i]>>4) + int((qh[i]>>hbShift1)&1)*16
				output[outIdx+32+i] = dsc1*float32(q) - dmm1
			}
			qlOff += 32
			outIdx += 64
		}
	}
}

func BaseDequantizeQ6K_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ6K
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ6K : (b+1)*BlockSizeQ6K]
		ql := blockData[0:128]
		qh := blockData[128:192]
		sc := blockData[192:208]
		raw := uint32(blockData[208]) | uint32(blockData[209])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		outOff := b * QK_K
		for j := 0; j < 16; j++ {
			scaleVal := d * float32(int8(sc[j]))
			scaleVec := archsimd.BroadcastFloat32x16(scaleVal)
			baseOut := outOff + j*16
			half := j / 8
			group := (j % 8) / 2
			lBase := (j % 2) * 16
			qlOff := half*64 + (group&1)*32
			qhOff := half * 32
			qhShift := uint(group * 2)
			nibbleShift := uint((group / 2) * 4)
			i := 0
			for ; i+lanes <= 16; i += lanes {
				for k := range lanes {
					l := lBase + i + k
					low4 := int((ql[qlOff+l] >> nibbleShift) & 0xF)
					high2 := int((qh[qhOff+l] >> qhShift) & 3)
					buf[k] = float32((low4 | (high2 << 4)) - 32)
				}
				v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
				result := v.Mul(scaleVec)
				result.Store((*[16]float32)(unsafe.Pointer(&output[baseOut+i])))
			}
			for ; i < 16; i++ {
				l := lBase + i
				low4 := int((ql[qlOff+l] >> nibbleShift) & 0xF)
				high2 := int((qh[qhOff+l] >> qhShift) & 3)
				output[baseOut+i] = scaleVal * float32((low4|(high2<<4))-32)
			}
		}
	}
}

func BaseDequantizeQ8_0_avx512(data []uint8, output []float32) {
	if len(data) == 0 {
		return
	}
	nblocks := len(data) / BlockSizeQ8_0
	lanes := 16
	buf := [16]float32{}
	for b := range nblocks {
		blockData := data[b*BlockSizeQ8_0 : (b+1)*BlockSizeQ8_0]
		raw := uint32(blockData[0]) | uint32(blockData[1])<<8
		sign := raw >> 15
		exp := (raw >> 10) & 0x1F
		mant := raw & 0x3FF
		var d float32
		if exp == 0 {
			d = stdmath.Float32frombits(sign << 31)
		} else {
			d = stdmath.Float32frombits((sign << 31) | ((exp + 112) << 23) | (mant << 13))
		}
		scaleVec := archsimd.BroadcastFloat32x16(d)
		qs := blockData[2:]
		outOff := b * QK
		i := 0
		for ; i+lanes <= QK; i += lanes {
			for j := range lanes {
				buf[j] = float32(int8(qs[i+j]))
			}
			v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
			result := v.Mul(scaleVec)
			result.Store((*[16]float32)(unsafe.Pointer(&output[outOff+i])))
		}
		for ; i < QK; i++ {
			output[outOff+i] = d * float32(int8(qs[i]))
		}
	}
}
