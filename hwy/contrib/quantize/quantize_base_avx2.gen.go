// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package quantize

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Hoisted constants - pre-broadcasted at package init time
var (
	BaseQuantizeFloat32_AVX2_max255Vec_f32 = archsimd.BroadcastFloat32x8(255.0)
)

func BaseDequantizeUint8_avx2(input []uint8, output []float32, min float32, scale float32) {
	if len(input) == 0 {
		return
	}
	n := len(input)
	if len(output) < n {
		n = len(output)
	}
	lanes := 8
	minVec := archsimd.BroadcastFloat32x8(min)
	scaleVec := archsimd.BroadcastFloat32x8(scale)
	buf := [8]float32{}
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		for j := range lanes {
			buf[j] = float32(input[i+j])
		}
		v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&buf[0])))
		result := v.MulAdd(scaleVec, minVec)
		result.Store((*[8]float32)(unsafe.Pointer(&output[i])))
		for j := range lanes {
			buf[j] = float32(input[i+j+8])
		}
		v1 := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&buf[0])))
		result1 := v1.MulAdd(scaleVec, minVec)
		result1.Store((*[8]float32)(unsafe.Pointer(&output[i+8])))
	}
	for ; i < n; i++ {
		output[i] = min + float32(input[i])*scale
	}
}

func BaseQuantizeFloat32_avx2(input []float32, output []uint8, min float32, scale float32) {
	if len(input) == 0 {
		return
	}
	n := len(input)
	if len(output) < n {
		n = len(output)
	}
	lanes := 8
	minVec := archsimd.BroadcastFloat32x8(min)
	invScaleVec := archsimd.BroadcastFloat32x8(1.0 / scale)
	zeroVec := archsimd.BroadcastFloat32x8(0)
	max255Vec := BaseQuantizeFloat32_AVX2_max255Vec_f32
	buf := [8]float32{}
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&input[i])))
		diff := v.Sub(minVec).Mul(invScaleVec)
		rounded := hwy.Round_AVX2_F32x8(diff).Max(zeroVec).Min(max255Vec)
		rounded.Store((*[8]float32)(unsafe.Pointer(&buf[0])))
		for j := range lanes {
			output[i+j] = uint8(buf[j])
		}
		v1 := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&input[i+8])))
		diff1 := v1.Sub(minVec).Mul(invScaleVec)
		rounded1 := hwy.Round_AVX2_F32x8(diff1).Max(zeroVec).Min(max255Vec)
		rounded1.Store((*[8]float32)(unsafe.Pointer(&buf[0])))
		for j := range lanes {
			output[i+j+8] = uint8(buf[j])
		}
	}
	for ; i < n; i++ {
		val := (input[i] - min) / scale
		rounded := float32(int32(val + 0.5))
		if rounded < 0 {
			rounded = 0
		}
		if rounded > 255 {
			rounded = 255
		}
		output[i] = uint8(rounded)
	}
}
