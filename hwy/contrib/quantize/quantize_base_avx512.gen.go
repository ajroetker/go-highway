// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package quantize

import (
	"simd/archsimd"
	"sync"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Hoisted constants - lazily initialized on first use to avoid init-time crashes
var (
	BaseQuantizeFloat32_AVX512_max255Vec_f32 archsimd.Float32x16
	_quantizeBaseHoistOnce                   sync.Once
)

func _quantizeBaseInitHoistedConstants() {
	_quantizeBaseHoistOnce.Do(func() {
		BaseQuantizeFloat32_AVX512_max255Vec_f32 = archsimd.BroadcastFloat32x16(255.0)
	})
}

func BaseDequantizeUint8_avx512(input []uint8, output []float32, min float32, scale float32) {
	_quantizeBaseInitHoistedConstants()
	if len(input) == 0 {
		return
	}
	n := len(input)
	if len(output) < n {
		n = len(output)
	}
	lanes := 16
	minVec := archsimd.BroadcastFloat32x16(min)
	scaleVec := archsimd.BroadcastFloat32x16(scale)
	buf := [16]float32{}
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		for j := range lanes {
			buf[j] = float32(input[i+j])
		}
		v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
		result := v.MulAdd(scaleVec, minVec)
		result.Store((*[16]float32)(unsafe.Pointer(&output[i])))
		for j := range lanes {
			buf[j] = float32(input[i+j+16])
		}
		v1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
		result1 := v1.MulAdd(scaleVec, minVec)
		result1.Store((*[16]float32)(unsafe.Pointer(&output[i+16])))
		for j := range lanes {
			buf[j] = float32(input[i+j+32])
		}
		v2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&buf[0])))
		result2 := v2.MulAdd(scaleVec, minVec)
		result2.Store((*[16]float32)(unsafe.Pointer(&output[i+32])))
	}
	for ; i < n; i++ {
		output[i] = min + float32(input[i])*scale
	}
}

func BaseQuantizeFloat32_avx512(input []float32, output []uint8, min float32, scale float32) {
	_quantizeBaseInitHoistedConstants()
	if len(input) == 0 {
		return
	}
	n := len(input)
	if len(output) < n {
		n = len(output)
	}
	lanes := 16
	minVec := archsimd.BroadcastFloat32x16(min)
	invScaleVec := archsimd.BroadcastFloat32x16(1.0 / scale)
	zeroVec := archsimd.BroadcastFloat32x16(0)
	max255Vec := BaseQuantizeFloat32_AVX512_max255Vec_f32
	buf := [16]float32{}
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[i])))
		diff := v.Sub(minVec).Mul(invScaleVec)
		rounded := hwy.Clamp(archsimd.Round(diff), zeroVec, max255Vec)
		rounded.Store((*[16]float32)(unsafe.Pointer(&buf[0])))
		for j := range lanes {
			output[i+j] = uint8(buf[j])
		}
		v1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[i+16])))
		diff1 := v1.Sub(minVec).Mul(invScaleVec)
		rounded1 := hwy.Clamp(archsimd.Round(diff1), zeroVec, max255Vec)
		rounded1.Store((*[16]float32)(unsafe.Pointer(&buf[0])))
		for j := range lanes {
			output[i+j+16] = uint8(buf[j])
		}
		v2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[i+32])))
		diff2 := v2.Sub(minVec).Mul(invScaleVec)
		rounded2 := hwy.Clamp(archsimd.Round(diff2), zeroVec, max255Vec)
		rounded2.Store((*[16]float32)(unsafe.Pointer(&buf[0])))
		for j := range lanes {
			output[i+j+32] = uint8(buf[j])
		}
	}
	for ; i < n; i++ {
		val := (input[i] - min) / scale
		rounded := float32(int32(val + 0.5))
		if rounded < 0 {
			rounded = 0
		}
		if rounded > 255 {
			rounded = 255
		}
		output[i] = uint8(rounded)
	}
}
